; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30152.0 

	TITLE	c:\dev\stringliterals\bin\intermediates\win32\release\main.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_0BA@ELKIONDK@bad?5locale?5name@		; `string'
PUBLIC	??_C@_01NBENCBCI@?$CK@				; `string'
PUBLIC	??_C@_02PLJDPFIO@00@				; `string'
PUBLIC	??_C@_05FBADLLFO@Ethan@				; `string'
PUBLIC	??_C@_15CNAMGDF@?$AA0?$AA1@			; `string'
PUBLIC	??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@	; `string'
PUBLIC	??_C@_15BAGFGJNL@?$AA0?$AA2@			; `string'
PUBLIC	??_C@_2M@JLEBFLAK@?$AA?$AA?$AA0?$AA?$AA?$AA3@	; `string'
PUBLIC	??_C@_2BI@CPCKAEFF@?$AA?$AA?$AAE?$AA?$AA?$AAt?$AA?$AA?$AAh?$AA?$AA?$AAa?$AA?$AA?$AAn@ ; `string'
PUBLIC	??_C@_0BC@GBLLDDOB@Line1?6Line2?6Line3@		; `string'
PUBLIC	??_C@_0BD@CGOJJEID@line4?6line5?6line6?6@	; `string'
PUBLIC	??_C@_03LFPOMIKD@chs@				; `string'
PUBLIC	??_C@_01LOCGONAA@?$AA@				; `string'
PUBLIC	??_C@_1M@PAFHHBLA@?$AAE?$AAt?$AAa?$AAh?$AAn@	; `string'
PUBLIC	??_C@_2BI@GPPIDABK@?$AA?$AA?$AAE?$AA?$AA?$AAt?$AA?$AA?$AAa?$AA?$AA?$AAh?$AA?$AA?$AAn@ ; `string'
PUBLIC	??_C@_05HKGIJGOH@name?3@			; `string'
PUBLIC	??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@		; `string'
PUBLIC	??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ ; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
EXTRN	__imp_??0_Locinfo@std@@QAE@HPBD@Z:PROC
EXTRN	__imp_??1_Locinfo@std@@QAE@XZ:PROC
EXTRN	__imp_?_Getname@_Locinfo@std@@QBEPBDXZ:PROC
EXTRN	__imp_?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ:PROC
EXTRN	__imp_?_Getdays@_Locinfo@std@@QBEPBDXZ:PROC
EXTRN	__imp_?_Getmonths@_Locinfo@std@@QBEPBDXZ:PROC
EXTRN	__imp_?_W_Getdays@_Locinfo@std@@QBEPBGXZ:PROC
EXTRN	__imp_?_W_Getmonths@_Locinfo@std@@QBEPBGXZ:PROC
EXTRN	__imp_?rdstate@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ:PROC
EXTRN	__imp_??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_?imbue@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAE?AVlocale@2@ABV32@@Z:PROC
EXTRN	__imp_??4?$_Yarn@D@std@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	__imp_?put@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@_W@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	__imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ:PROC
EXTRN	__imp_?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAE_JPB_W_J@Z:PROC
EXTRN	__imp___invalid_parameter_noinfo_noreturn:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp____std_terminate:PROC
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__imp____std_exception_copy:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	__imp_?wcout@std@@3V?$basic_ostream@_WU?$char_traits@_W@std@@@1@A:BYTE
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:PROC
EXTRN	__imp_?_Init@locale@std@@CAPAV_Locimp@12@_N@Z:PROC
EXTRN	__imp_?_New_Locimp@_Locimp@locale@std@@CAPAV123@_N@Z:PROC
EXTRN	__imp_?_Makeloc@_Locimp@locale@std@@CAPAV123@ABV_Locinfo@3@HPAV123@PBV23@@Z:PROC
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?_Xruntime_error@std@@YAXPBD@Z:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp__calloc:PROC
EXTRN	__imp___Mbrtowc:PROC
EXTRN	__imp____std_exception_destroy:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__imp____CxxFrameHandler3:PROC
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
CONST	SEGMENT
??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ DB ':'
	DB	00H, 'A', 00H, 'M', 00H, ':', 00H, 'a', 00H, 'm', 00H, ':', 00H
	DB	'P', 00H, 'M', 00H, ':', 00H, 'p', 00H, 'm', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
CONST	SEGMENT
??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@ DB ':AM:am:PM:pm', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05HKGIJGOH@name?3@
CONST	SEGMENT
??_C@_05HKGIJGOH@name?3@ DB 'name:', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_2BI@GPPIDABK@?$AA?$AA?$AAE?$AA?$AA?$AAt?$AA?$AA?$AAa?$AA?$AA?$AAh?$AA?$AA?$AAn@
CONST	SEGMENT
??_C@_2BI@GPPIDABK@?$AA?$AA?$AAE?$AA?$AA?$AAt?$AA?$AA?$AAa?$AA?$AA?$AAh?$AA?$AA?$AAn@ DB 'E'
	DB	00H, 00H, 00H, 't', 00H, 00H, 00H, 'a', 00H, 00H, 00H, 'h', 00H
	DB	00H, 00H, 'n', 00H, 00H, 00H, 00H, 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PAFHHBLA@?$AAE?$AAt?$AAa?$AAh?$AAn@
CONST	SEGMENT
??_C@_1M@PAFHHBLA@?$AAE?$AAt?$AAa?$AAh?$AAn@ DB 'E', 00H, 't', 00H, 'a', 00H
	DB	'h', 00H, 'n', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LOCGONAA@?$AA@
CONST	SEGMENT
??_C@_01LOCGONAA@?$AA@ DB 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LFPOMIKD@chs@
CONST	SEGMENT
??_C@_03LFPOMIKD@chs@ DB 'chs', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CGOJJEID@line4?6line5?6line6?6@
CONST	SEGMENT
??_C@_0BD@CGOJJEID@line4?6line5?6line6?6@ DB 'line4', 0aH, 'line5', 0aH, 'l'
	DB	'ine6', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GBLLDDOB@Line1?6Line2?6Line3@
CONST	SEGMENT
??_C@_0BC@GBLLDDOB@Line1?6Line2?6Line3@ DB 'Line1', 0aH, 'Line2', 0aH, 'L'
	DB	'ine3', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_2BI@CPCKAEFF@?$AA?$AA?$AAE?$AA?$AA?$AAt?$AA?$AA?$AAh?$AA?$AA?$AAa?$AA?$AA?$AAn@
CONST	SEGMENT
??_C@_2BI@CPCKAEFF@?$AA?$AA?$AAE?$AA?$AA?$AAt?$AA?$AA?$AAh?$AA?$AA?$AAa?$AA?$AA?$AAn@ DB 'E'
	DB	00H, 00H, 00H, 't', 00H, 00H, 00H, 'h', 00H, 00H, 00H, 'a', 00H
	DB	00H, 00H, 'n', 00H, 00H, 00H, 00H, 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_2M@JLEBFLAK@?$AA?$AA?$AA0?$AA?$AA?$AA3@
CONST	SEGMENT
??_C@_2M@JLEBFLAK@?$AA?$AA?$AA0?$AA?$AA?$AA3@ DB '0', 00H, 00H, 00H, '3', 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_15BAGFGJNL@?$AA0?$AA2@
CONST	SEGMENT
??_C@_15BAGFGJNL@?$AA0?$AA2@ DB '0', 00H, '2', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@
CONST	SEGMENT
??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@ DB 'E', 00H, 't', 00H, 'h', 00H
	DB	'a', 00H, 'n', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_15CNAMGDF@?$AA0?$AA1@
CONST	SEGMENT
??_C@_15CNAMGDF@?$AA0?$AA1@ DB '0', 00H, '1', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05FBADLLFO@Ethan@
CONST	SEGMENT
??_C@_05FBADLLFO@Ethan@ DB 'Ethan', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PLJDPFIO@00@
CONST	SEGMENT
??_C@_02PLJDPFIO@00@ DB '00', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01NBENCBCI@?$CK@
CONST	SEGMENT
??_C@_01NBENCBCI@?$CK@ DB '*', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ELKIONDK@bad?5locale?5name@
CONST	SEGMENT
??_C@_0BA@ELKIONDK@bad?5locale?5name@ DB 'bad locale name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
PUBLIC	??$forward@AAPA_S@std@@YAAAPA_SAAPA_S@Z		; std::forward<char16_t * &>
PUBLIC	??$forward@AAPA_U@std@@YAAAPA_UAAPA_U@Z		; std::forward<char32_t * &>
PUBLIC	??$forward@V?$allocator@_S@std@@@std@@YA$$QAV?$allocator@_S@0@AAV10@@Z ; std::forward<std::allocator<char16_t> >
PUBLIC	??$forward@V?$allocator@_U@std@@@std@@YA$$QAV?$allocator@_U@0@AAV10@@Z ; std::forward<std::allocator<char32_t> >
PUBLIC	??$forward@ABQA_S@std@@YAABQA_SABQA_S@Z		; std::forward<char16_t * const &>
PUBLIC	??$_Voidify_iter@PAPA_S@std@@YAPAXPAPA_S@Z	; std::_Voidify_iter<char16_t * *>
PUBLIC	??$addressof@PA_S@std@@YAPAPA_SAAPA_S@Z		; std::addressof<char16_t *>
PUBLIC	??$forward@ABQA_U@std@@YAABQA_UABQA_U@Z		; std::forward<char32_t * const &>
PUBLIC	??$_Voidify_iter@PAPA_U@std@@YAPAXPAPA_U@Z	; std::_Voidify_iter<char32_t * *>
PUBLIC	??$addressof@PA_U@std@@YAPAPA_UAAPA_U@Z		; std::addressof<char32_t *>
PUBLIC	??$addressof@$$CBV?$_String_val@U?$_Simple_types@_S@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@_S@std@@@0@ABV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char16_t> > const >
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@_S@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@_S@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char16_t> > >
PUBLIC	??$addressof@$$CBV?$_String_val@U?$_Simple_types@_U@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@_U@std@@@0@ABV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char32_t> > const >
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@_U@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@_U@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char32_t> > >
PUBLIC	??$_Construct_in_place@PA_SAAPA_S@std@@YAXAAPA_S0@Z ; std::_Construct_in_place<char16_t *,char16_t * &>
PUBLIC	??$_Reallocate_grow_by@V<lambda_98ae700cc7810ca9f391bc310db97391>@@PB_SI@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEAAV01@IV<lambda_98ae700cc7810ca9f391bc310db97391>@@PB_SI@Z ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Reallocate_grow_by<<lambda_98ae700cc7810ca9f391bc310db97391>,char16_t const *,unsigned int>
PUBLIC	??$_Construct_in_place@PA_UAAPA_U@std@@YAXAAPA_U0@Z ; std::_Construct_in_place<char32_t *,char32_t * &>
PUBLIC	??$_Reallocate_grow_by@V<lambda_aabcc5df0dcdbd223414bc3ba38ad6d9>@@PB_UI@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEAAV01@IV<lambda_aabcc5df0dcdbd223414bc3ba38ad6d9>@@PB_UI@Z ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Reallocate_grow_by<<lambda_aabcc5df0dcdbd223414bc3ba38ad6d9>,char32_t const *,unsigned int>
PUBLIC	??$?0V?$allocator@_S@std@@$$V@?$_Compressed_pair@V?$allocator@_S@std@@V?$_String_val@U?$_Simple_types@_S@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@_S@1@@Z ; std::_Compressed_pair<std::allocator<char16_t>,std::_String_val<std::_Simple_types<char16_t> >,1>::_Compressed_pair<std::allocator<char16_t>,std::_String_val<std::_Simple_types<char16_t> >,1><std::allocator<char16_t> >
PUBLIC	??$move@AAV?$allocator@_S@std@@@std@@YA$$QAV?$allocator@_S@0@AAV10@@Z ; std::move<std::allocator<char16_t> &>
PUBLIC	??$_Get_size_of_n@$03@std@@YAII@Z		; std::_Get_size_of_n<4>
PUBLIC	??$?0V?$allocator@_U@std@@$$V@?$_Compressed_pair@V?$allocator@_U@std@@V?$_String_val@U?$_Simple_types@_U@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@_U@1@@Z ; std::_Compressed_pair<std::allocator<char32_t>,std::_String_val<std::_Simple_types<char32_t> >,1>::_Compressed_pair<std::allocator<char32_t>,std::_String_val<std::_Simple_types<char32_t> >,1><std::allocator<char32_t> >
PUBLIC	??$move@AAV?$allocator@_U@std@@@std@@YA$$QAV?$allocator@_U@0@AAV10@@Z ; std::move<std::allocator<char32_t> &>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$forward@ABQA_W@std@@YAABQA_WABQA_W@Z		; std::forward<wchar_t * const &>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$forward@ABQAD@std@@YAABQADABQAD@Z		; std::forward<char * const &>
PUBLIC	??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z	; std::_Voidify_iter<char * *>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z		; std::forward<wchar_t * &>
PUBLIC	??$_Voidify_iter@PAPA_W@std@@YAPAXPAPA_W@Z	; std::_Voidify_iter<wchar_t * *>
PUBLIC	??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z		; std::addressof<wchar_t *>
PUBLIC	??$_Construct_in_place@PA_SABQA_S@std@@YAXAAPA_SABQA_S@Z ; std::_Construct_in_place<char16_t *,char16_t * const &>
PUBLIC	??$_Construct_in_place@PA_UABQA_U@std@@YAXAAPA_UABQA_U@Z ; std::_Construct_in_place<char32_t *,char32_t * const &>
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$forward@V?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z ; std::forward<std::allocator<wchar_t> >
PUBLIC	??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z ; std::_Insert_string<wchar_t,std::char_traits<wchar_t>,unsigned int>
PUBLIC	??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
PUBLIC	??$move@AAV?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@@std@@YA$$QAV?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@0@AAV10@@Z ; std::move<std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > &>
PUBLIC	??$move@AAV?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@@std@@YA$$QAV?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@0@AAV10@@Z ; std::move<std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > &>
PUBLIC	?_Memcpy_val_from@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEXABV12@@Z ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Memcpy_val_from
PUBLIC	?_Swap_proxy_and_iterators@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEXAAV12@@Z ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Swap_proxy_and_iterators
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@_S@std@@V?$_String_val@U?$_Simple_types@_S@std@@@2@$00@std@@QBEABV?$allocator@_S@2@XZ ; std::_Compressed_pair<std::allocator<char16_t>,std::_String_val<std::_Simple_types<char16_t> >,1>::_Get_first
PUBLIC	?_Memcpy_val_from@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEXABV12@@Z ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Memcpy_val_from
PUBLIC	?_Swap_proxy_and_iterators@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEXAAV12@@Z ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Swap_proxy_and_iterators
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@_U@std@@V?$_String_val@U?$_Simple_types@_U@std@@@2@$00@std@@QBEABV?$allocator@_U@2@XZ ; std::_Compressed_pair<std::allocator<char32_t>,std::_String_val<std::_Simple_types<char32_t> >,1>::_Get_first
PUBLIC	??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
PUBLIC	?length@?$_WChar_traits@_S@std@@SAIPB_S@Z	; std::_WChar_traits<char16_t>::length
PUBLIC	?length@?$_Char_traits@_UI@std@@SAIPB_U@Z	; std::_Char_traits<char32_t,unsigned int>::length
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
PUBLIC	?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAIIII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@_S@std@@@std@@SAIABV?$allocator@_S@2@@Z ; std::_Default_allocator_traits<std::allocator<char16_t> >::max_size
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@_S@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char16_t> >::_Bxty::_Bxty
PUBLIC	?_Take_contents@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEXAAV12@@Z ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Take_contents
PUBLIC	??R<lambda_98ae700cc7810ca9f391bc310db97391>@@QBE@QA_SQB_SI1I@Z ; <lambda_98ae700cc7810ca9f391bc310db97391>::operator()
PUBLIC	?append@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAEAAV12@QB_SI@Z ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::append
PUBLIC	?_Calculate_growth@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@CAIIII@Z ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Calculate_growth
PUBLIC	?_Getal@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@ABEABV?$allocator@_S@2@XZ ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@_U@std@@@std@@SAIABV?$allocator@_U@2@@Z ; std::_Default_allocator_traits<std::allocator<char32_t> >::max_size
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@_U@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char32_t> >::_Bxty::_Bxty
PUBLIC	?_Take_contents@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEXAAV12@@Z ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Take_contents
PUBLIC	??R<lambda_aabcc5df0dcdbd223414bc3ba38ad6d9>@@QBE@QA_UQB_UI1I@Z ; <lambda_aabcc5df0dcdbd223414bc3ba38ad6d9>::operator()
PUBLIC	?append@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAEAAV12@QB_UI@Z ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::append
PUBLIC	?_Calculate_growth@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@CAIIII@Z ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Calculate_growth
PUBLIC	?_Getal@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@ABEABV?$allocator@_U@2@XZ ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Getal
PUBLIC	??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	??0?$allocator@_W@std@@QAE@XZ			; std::allocator<wchar_t>::allocator<wchar_t>
PUBLIC	??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data
PUBLIC	?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
PUBLIC	??0?$allocator@_S@std@@QAE@XZ			; std::allocator<char16_t>::allocator<char16_t>
PUBLIC	?allocate@?$allocator@_S@std@@QAEPA_SI@Z	; std::allocator<char16_t>::allocate
PUBLIC	??0?$_String_val@U?$_Simple_types@_S@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char16_t> >::_String_val<std::_Simple_types<char16_t> >
PUBLIC	??0?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >
PUBLIC	?append@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAEAAV12@QB_S@Z ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::append
PUBLIC	?max_size@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QBEIXZ ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@ABEII@Z ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Calculate_growth
PUBLIC	??0?$allocator@_U@std@@QAE@XZ			; std::allocator<char32_t>::allocator<char32_t>
PUBLIC	?allocate@?$allocator@_U@std@@QAEPA_UI@Z	; std::allocator<char32_t>::allocate
PUBLIC	??0?$_String_val@U?$_Simple_types@_U@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char32_t> >::_String_val<std::_Simple_types<char32_t> >
PUBLIC	??0?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >
PUBLIC	?append@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAEAAV12@QB_U@Z ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::append
PUBLIC	?max_size@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QBEIXZ ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@ABEII@Z ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Calculate_growth
PUBLIC	??$_Get_size_of_n@$01@std@@YAII@Z		; std::_Get_size_of_n<2>
PUBLIC	??$_Reallocate_grow_by@V<lambda_2fb699096920f2dc628cb0826b07831d>@@PB_WI@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_2fb699096920f2dc628cb0826b07831d>@@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_2fb699096920f2dc628cb0826b07831d>,wchar_t const *,unsigned int>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Get_size_of_n@$00@std@@YAII@Z		; std::_Get_size_of_n<1>
PUBLIC	??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$addressof@$$CBV?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@_W@std@@@0@ABV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > const >
PUBLIC	??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@_W@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Construct_in_place@PADAAPAD@std@@YAXAAPAD0@Z ; std::_Construct_in_place<char *,char * &>
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Unfancy@_W@std@@YAPA_WPA_W@Z		; std::_Unfancy<wchar_t>
PUBLIC	??$_Construct_in_place@PA_WAAPA_W@std@@YAXAAPA_W0@Z ; std::_Construct_in_place<wchar_t *,wchar_t * &>
PUBLIC	??$_Reallocate_for@V<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_for<<lambda_03628ca18370b1f44a99b655e704819b>,wchar_t const *>
PUBLIC	??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z	; std::_Destroy_in_place<wchar_t *>
PUBLIC	??$_Unfancy@_S@std@@YAPA_SPA_S@Z		; std::_Unfancy<char16_t>
PUBLIC	??$_Reallocate_for@V<lambda_493290ea8cd8fcd66ff9f3cecf244fbc>@@PB_S@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEAAV01@IV<lambda_493290ea8cd8fcd66ff9f3cecf244fbc>@@PB_S@Z ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Reallocate_for<<lambda_493290ea8cd8fcd66ff9f3cecf244fbc>,char16_t const *>
PUBLIC	??$_Destroy_in_place@PA_S@std@@YAXAAPA_S@Z	; std::_Destroy_in_place<char16_t *>
PUBLIC	??$_Unfancy@_U@std@@YAPA_UPA_U@Z		; std::_Unfancy<char32_t>
PUBLIC	??$_Reallocate_for@V<lambda_02ffc73a80c062ba6e5e6c9f53d514cc>@@PB_U@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEAAV01@IV<lambda_02ffc73a80c062ba6e5e6c9f53d514cc>@@PB_U@Z ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Reallocate_for<<lambda_02ffc73a80c062ba6e5e6c9f53d514cc>,char32_t const *>
PUBLIC	??$_Destroy_in_place@PA_U@std@@YAXAAPA_U@Z	; std::_Destroy_in_place<char32_t *>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::move<std::allocator<char> &>
PUBLIC	??$_Convert_size@I@std@@YAII@Z			; std::_Convert_size<unsigned int>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><>
PUBLIC	??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@_W@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >
PUBLIC	??$move@AAV?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z ; std::move<std::allocator<wchar_t> &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@_S@std@@V?$_String_val@U?$_Simple_types@_S@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char16_t>,std::_String_val<std::_Simple_types<char16_t> >,1>::_Compressed_pair<std::allocator<char16_t>,std::_String_val<std::_Simple_types<char16_t> >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@_U@std@@V?$_String_val@U?$_Simple_types@_U@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char32_t>,std::_String_val<std::_Simple_types<char32_t> >,1>::_Compressed_pair<std::allocator<char32_t>,std::_String_val<std::_Simple_types<char32_t> >,1><>
PUBLIC	??$min@I@std@@YAABIABI0@Z			; std::min<unsigned int>
PUBLIC	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &>
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$endl@_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@@Z ; std::endl<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?H_UU?$char_traits@_U@std@@V?$allocator@_U@1@@std@@YA?AV?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@0@$$QAV10@QB_U@Z ; std::operator+<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >
PUBLIC	??$?H_SU?$char_traits@_S@std@@V?$allocator@_S@1@@std@@YA?AV?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@0@$$QAV10@QB_S@Z ; std::operator+<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@QB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ; std::_Default_allocator_traits<std::allocator<wchar_t> >::max_size
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	?length@?$_WChar_traits@_W@std@@SAIPB_W@Z	; std::_WChar_traits<wchar_t>::length
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?allocate@?$allocator@_W@std@@QAEPA_WI@Z	; std::allocator<wchar_t>::allocate
PUBLIC	??R<lambda_2fb699096920f2dc628cb0826b07831d>@@QBE@QA_WQB_WI1I@Z ; <lambda_2fb699096920f2dc628cb0826b07831d>::operator()
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$allocator@_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@_S@std@@V?$_String_val@U?$_Simple_types@_S@std@@@2@$00@std@@QAEAAV?$allocator@_S@2@XZ ; std::_Compressed_pair<std::allocator<char16_t>,std::_String_val<std::_Simple_types<char16_t> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@_U@std@@V?$_String_val@U?$_Simple_types@_U@std@@@2@$00@std@@QAEAAV?$allocator@_U@2@XZ ; std::_Compressed_pair<std::allocator<char32_t>,std::_String_val<std::_Simple_types<char32_t> >,1>::_Get_first
PUBLIC	?copy@?$_Char_traits@_SG@std@@SAPA_SQA_SQB_SI@Z	; std::_Char_traits<char16_t,unsigned short>::copy
PUBLIC	?move@?$_Char_traits@_SG@std@@SAPA_SQA_SQB_SI@Z	; std::_Char_traits<char16_t,unsigned short>::move
PUBLIC	?assign@?$_WChar_traits@_S@std@@SAXAA_SAB_S@Z	; std::_WChar_traits<char16_t>::assign
PUBLIC	?copy@?$_Char_traits@_UI@std@@SAPA_UQA_UQB_UI@Z	; std::_Char_traits<char32_t,unsigned int>::copy
PUBLIC	?move@?$_Char_traits@_UI@std@@SAPA_UQA_UQB_UI@Z	; std::_Char_traits<char32_t,unsigned int>::move
PUBLIC	?assign@?$_Char_traits@_UI@std@@SAXAA_UAB_U@Z	; std::_Char_traits<char32_t,unsigned int>::assign
PUBLIC	?move@?$_Char_traits@_WG@std@@SAPA_WQA_WQB_WI@Z	; std::_Char_traits<wchar_t,unsigned short>::move
PUBLIC	?assign@?$_WChar_traits@_W@std@@SAXAA_WAB_W@Z	; std::_WChar_traits<wchar_t>::assign
PUBLIC	?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z	; std::_Char_traits<char,int>::move
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?deallocate@?$allocator@D@std@@QAEXQADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@_W@std@@QAEXQA_WI@Z	; std::allocator<wchar_t>::deallocate
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged
PUBLIC	?_Memcpy_val_from@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Memcpy_val_from
PUBLIC	?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Swap_proxy_and_iterators
PUBLIC	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEABV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$allocator@_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@_S@std@@QAEXQA_SI@Z	; std::allocator<char16_t>::deallocate
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@_S@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char16_t> >::_Large_string_engaged
PUBLIC	?_Getal@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEAAV?$allocator@_S@2@XZ ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Getal
PUBLIC	??$max@I@std@@YAABIABI0@Z			; std::max<unsigned int>
PUBLIC	?deallocate@?$allocator@_U@std@@QAEXQA_UI@Z	; std::allocator<char32_t>::deallocate
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@_U@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char32_t> >::_Large_string_engaged
PUBLIC	?_Getal@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEAAV?$allocator@_U@2@XZ ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Getal
PUBLIC	?copy@?$_Char_traits@_WG@std@@SAPA_WQA_WQB_WI@Z	; std::_Char_traits<wchar_t,unsigned short>::copy
PUBLIC	?eq_int_type@?$_WChar_traits@_W@std@@SA_NABG0@Z	; std::_WChar_traits<wchar_t>::eq_int_type
PUBLIC	?eof@?$_WChar_traits@_W@std@@SAGXZ		; std::_WChar_traits<wchar_t>::eof
PUBLIC	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z	; std::_Char_traits<char,int>::copy
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z	; std::_Narrow_char_traits<char,int>::length
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
PUBLIC	??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBE@QADIQBD@Z ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator()
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
PUBLIC	?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Take_contents
PUBLIC	??R<lambda_03628ca18370b1f44a99b655e704819b>@@QBE@QA_WIQB_W@Z ; <lambda_03628ca18370b1f44a99b655e704819b>::operator()
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
PUBLIC	?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
PUBLIC	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_S@std@@@std@@QAEPA_SXZ ; std::_String_val<std::_Simple_types<char16_t> >::_Myptr
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@_S@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char16_t> >::_Bxty::~_Bxty
PUBLIC	??R<lambda_493290ea8cd8fcd66ff9f3cecf244fbc>@@QBE@QA_SIQB_S@Z ; <lambda_493290ea8cd8fcd66ff9f3cecf244fbc>::operator()
PUBLIC	?assign@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAEAAV12@QB_SI@Z ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::assign
PUBLIC	?_Tidy_init@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEXXZ ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEXXZ ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Tidy_deallocate
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_U@std@@@std@@QAEPA_UXZ ; std::_String_val<std::_Simple_types<char32_t> >::_Myptr
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@_U@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char32_t> >::_Bxty::~_Bxty
PUBLIC	??R<lambda_02ffc73a80c062ba6e5e6c9f53d514cc>@@QBE@QA_UIQB_U@Z ; <lambda_02ffc73a80c062ba6e5e6c9f53d514cc>::operator()
PUBLIC	?assign@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAEAAV12@QB_UI@Z ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::assign
PUBLIC	?_Tidy_init@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEXXZ ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEXXZ ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Tidy_deallocate
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
PUBLIC	??1?$_String_val@U?$_Simple_types@_S@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char16_t> >::~_String_val<std::_Simple_types<char16_t> >
PUBLIC	??1?$_String_val@U?$_Simple_types@_U@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char32_t> >::~_String_val<std::_Simple_types<char32_t> >
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>
PUBLIC	??1?$_Compressed_pair@V?$allocator@_S@std@@V?$_String_val@U?$_Simple_types@_S@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char16_t>,std::_String_val<std::_Simple_types<char16_t> >,1>::~_Compressed_pair<std::allocator<char16_t>,std::_String_val<std::_Simple_types<char16_t> >,1>
PUBLIC	??1?$_Compressed_pair@V?$allocator@_U@std@@V?$_String_val@U?$_Simple_types@_U@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char32_t>,std::_String_val<std::_Simple_types<char32_t> >,1>::~_Compressed_pair<std::allocator<char32_t>,std::_String_val<std::_Simple_types<char32_t> >,1>
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAE@QB_SI@Z ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >
PUBLIC	??1?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAE@XZ ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::~basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >
PUBLIC	?_Unchecked_begin@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAEPA_SXZ ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAEPA_SXZ ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Unchecked_end
PUBLIC	??0?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAE@QB_UI@Z ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >
PUBLIC	??1?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAE@XZ ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::~basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >
PUBLIC	?_Unchecked_begin@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAEPA_UXZ ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAEPA_UXZ ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Unchecked_end
PUBLIC	_main
PUBLIC	?_Badname@locale@std@@AAE_NABV_Locinfo@2@@Z	; std::locale::_Badname
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
PUBLIC	??0locale@std@@QAE@PBDH@Z			; std::locale::locale
PUBLIC	?_Construct@locale@std@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::locale::_Construct
PUBLIC	??1_Facet_guard@locale@std@@QAE@XZ		; std::locale::_Facet_guard::~_Facet_guard
PUBLIC	??__Ks@string_literals@literals@std@@YA?AV?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@3@PB_UI@Z ; std::literals::string_literals::operator "" s
PUBLIC	??__Ks@string_literals@literals@std@@YA?AV?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@3@PB_SI@Z ; std::literals::string_literals::operator "" s
PUBLIC	??__Ks@string_literals@literals@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@3@PB_WI@Z ; std::literals::string_literals::operator "" s
PUBLIC	??__Ks@string_literals@literals@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@PBDI@Z ; std::literals::string_literals::operator "" s
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	?_Swap_proxy_and_iterators@_Container_base0@std@@QAEXAAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AAE@QBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	??2@YAPAXIPAX@Z					; operator new
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___std_terminate:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Construct@locale@std@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Construct@locale@std@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Construct@locale@std@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Construct@locale@std@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Construct@locale@std@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0locale@std@@QAE@PBDH@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0locale@std@@QAE@PBDH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0locale@std@@QAE@PBDH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0locale@std@@QAE@PBDH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0locale@std@@QAE@PBDH@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$??0locale@std@@QAE@PBDH@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$_main DD 019930522H
	DD	010H
	DD	FLAT:__unwindtable$_main
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$_main DD 0ffffffffH
	DD	FLAT:__unwindfunclet$_main$0
	DD	00H
	DD	FLAT:__unwindfunclet$_main$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_main$1
	DD	02H
	DD	FLAT:__unwindfunclet$_main$2
	DD	03H
	DD	FLAT:__unwindfunclet$_main$3
	DD	02H
	DD	FLAT:__unwindfunclet$_main$3
	DD	05H
	DD	FLAT:__unwindfunclet$_main$4
	DD	06H
	DD	FLAT:__unwindfunclet$_main$5
	DD	05H
	DD	FLAT:__unwindfunclet$_main$5
	DD	08H
	DD	FLAT:__unwindfunclet$_main$6
	DD	09H
	DD	FLAT:__unwindfunclet$_main$7
	DD	08H
	DD	FLAT:__unwindfunclet$_main$7
	DD	0bH
	DD	FLAT:__unwindfunclet$_main$42
	DD	0cH
	DD	FLAT:__unwindfunclet$_main$45
	DD	0dH
	DD	FLAT:__unwindfunclet$_main$46
	DD	0bH
	DD	FLAT:__unwindfunclet$_main$8
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	04H
	DD	FLAT:___std_terminate
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$6
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	04H
	DD	FLAT:___std_terminate
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$6
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	04H
	DD	FLAT:___std_terminate
__tryblocktable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$6
__catchsym$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	04H
	DD	FLAT:___std_terminate
__tryblocktable$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z$6
__catchsym$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z$0
xdata$x	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT
; __Size$dead$ = ecx
; __Where$ = edx

; 168  :         (void)_Size;
; 169  :         return _Where;

	mov	eax, edx

; 170  :     }

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 66   :     {

	push	ebp
	mov	ebp, esp

; 67   :         _Data._What = _Message;

	mov	eax, DWORD PTR __Message$[ebp]
	xorps	xmm0, xmm0
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [ecx+4], xmm0
	mov	DWORD PTR [ecx+4], eax

; 68   :     }

	mov	eax, ecx
	pop	ebp
	ret	8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0
	lea	eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR __Other$[ebp]
	add	eax, 4
	push	eax
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8

; 74   :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	pop	ecx

; 91   :     }

	ret	0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
	test	ecx, ecx
	cmovne	eax, ecx

; 96   :     }

	ret	0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 89   :     {

	push	esi
	mov	esi, ecx

; 90   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN6@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN6@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AAE@QBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@AAE@QBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 130  :     {

	push	ebp
	mov	ebp, esp

; 67   :         _Data._What = _Message;

	mov	eax, DWORD PTR __Message$[ebp]
	xorps	xmm0, xmm0

; 65   :         : _Data()

	movq	QWORD PTR [ecx+4], xmm0

; 66   :     {
; 67   :         _Data._What = _Message;

	mov	DWORD PTR [ecx+4], eax

; 131  :     }

	mov	eax, ecx
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	pop	ebp
	ret	4
??0bad_alloc@std@@AAE@QBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 89   :     {

	push	esi
	mov	esi, ecx

; 90   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN9@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN9@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	pop	ecx
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

	xorps	xmm0, xmm0

; 142  :     }

	mov	eax, ecx

; 65   :         : _Data()

	movq	QWORD PTR [ecx+4], xmm0

; 66   :     {
; 67   :         _Data._What = _Message;

	mov	DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 141  :     {

	mov	DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

	ret	0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 89   :     {

	push	esi
	mov	esi, ecx

; 90   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN12@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN12@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	pop	ecx
	ret	0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 315  : [[noreturn]] inline void _Throw_bad_array_new_length() {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 316  :     _THROW(bad_array_new_length{});

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0bad_array_new_length@std@@QAE@XZ	; std::bad_array_new_length::bad_array_new_length
	push	OFFSET __TI3?AVbad_array_new_length@std@@
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	__CxxThrowException@8
$LN3@Throw_bad_:
	int	3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 72   :     {

	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0

; 71   :         : _Data()

	lea	eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8
	mov	DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 72   :     {

	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0

; 71   :         : _Data()

	lea	eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 541  :         return INT_MAX;

	mov	eax, 2147483647				; 7fffffffH

; 542  :     }

	ret	0
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT
; __Bytes$ = ecx

; 79   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 80   :     }

	ret	0
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT
; __Ptr$ = ecx
; __Bytes$ = edx

; 146  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 147  :     _Bytes += _Non_user_size;

	add	DWORD PTR [edx], 35			; 00000023H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax-4]

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN7@Adjust_man

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	DWORD PTR [ecx], edx

; 166  : }

	ret	0
$LN7@Adjust_man:

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 982  :     _CONSTEXPR20_CONTAINER void _Orphan_all() noexcept {}

	ret	0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators@_Container_base0@std@@QAEXAAU12@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
?_Swap_proxy_and_iterators@_Container_base0@std@@QAEXAAU12@@Z PROC ; std::_Container_base0::_Swap_proxy_and_iterators, COMDAT
; _this$dead$ = ecx

; 983  :     _CONSTEXPR20_CONTAINER void _Swap_proxy_and_iterators(_Container_base0&) noexcept {}

	ret	4
?_Swap_proxy_and_iterators@_Container_base0@std@@QAEXAAU12@@Z ENDP ; std::_Container_base0::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT
; _this$dead$ = ecx

; 984  :     _CONSTEXPR20_CONTAINER void _Alloc_proxy(const _Fake_allocator&) noexcept {}

	ret	4
?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT
; _this$ = ecx

; 1250 :     _CONSTEXPR20_CONTAINER _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

	mov	eax, ecx
	ret	8
??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ
_TEXT	SEGMENT
?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ PROC		; std::_Fake_proxy_ptr_impl::_Release, COMDAT
; _this$dead$ = ecx

; 1253 :     _CONSTEXPR20_CONTAINER void _Release() noexcept {}

	ret	0
?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ ENDP		; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2340 :     _Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlen_strin:
	int	3
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??__Ks@string_literals@literals@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@PBDI@Z
_TEXT	SEGMENT
___$ReturnUdt$ = -4					; size = 4
__Len$dead$ = 8						; size = 4
??__Ks@string_literals@literals@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@PBDI@Z PROC ; std::literals::string_literals::operator "" s, COMDAT
; ___$ReturnUdt$ = ecx
; __Str$dead$ = edx

; 4959 :         _NODISCARD _CONSTEXPR20_STRING_LITERALS string operator"" s(const char* _Str, size_t _Len) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 2469 :         assign(_Ptr, _Count);

	push	5
	push	OFFSET ??_C@_05FBADLLFO@Ethan@

; 4959 :         _NODISCARD _CONSTEXPR20_STRING_LITERALS string operator"" s(const char* _Str, size_t _Len) {

	mov	DWORD PTR ___$ReturnUdt$[ebp], esi

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [esi], 0

; 4562 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [esi], 0

; 2469 :         assign(_Ptr, _Count);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 4960 :             return string(_Str, _Len);

	mov	eax, esi
	pop	esi

; 4961 :         }

	mov	esp, ebp
	pop	ebp
	ret	0
??__Ks@string_literals@literals@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@PBDI@Z ENDP ; std::literals::string_literals::operator "" s
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??__Ks@string_literals@literals@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@3@PB_WI@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$ = -4				; size = 4
___$ReturnUdt$ = -4					; size = 4
__Len$dead$ = 8						; size = 4
??__Ks@string_literals@literals@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@3@PB_WI@Z PROC ; std::literals::string_literals::operator "" s, COMDAT
; ___$ReturnUdt$ = ecx
; __Str$dead$ = edx

; 4963 :         _NODISCARD _CONSTEXPR20_STRING_LITERALS wstring operator"" s(const wchar_t* _Str, size_t _Len) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	xor	eax, eax

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	push	10					; 0000000aH
	push	OFFSET ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@

; 4963 :         _NODISCARD _CONSTEXPR20_STRING_LITERALS wstring operator"" s(const wchar_t* _Str, size_t _Len) {

	mov	DWORD PTR ___$ReturnUdt$[ebp], esi

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [esi], 0

; 4562 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 7

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [esi], ax

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	push	esi

; 4963 :         _NODISCARD _CONSTEXPR20_STRING_LITERALS wstring operator"" s(const wchar_t* _Str, size_t _Len) {

	mov	DWORD PTR ___$ReturnUdt$GSCopy$[ebp], esi

; 3214 :             _Mypair._Myval2._Mysize = _Count;

	mov	DWORD PTR [esi+16], 5

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	call	_memmove
	add	esp, 12					; 0000000cH

; 3216 :             _Traits::assign(_Old_ptr[_Count], _Elem());

	xor	eax, eax
	mov	WORD PTR [esi+10], ax

; 4964 :             return wstring(_Str, _Len);

	mov	eax, esi
	pop	esi

; 4965 :         }

	mov	esp, ebp
	pop	ebp
	ret	0
??__Ks@string_literals@literals@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@3@PB_WI@Z ENDP ; std::literals::string_literals::operator "" s
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??__Ks@string_literals@literals@std@@YA?AV?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@3@PB_SI@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$ = -4				; size = 4
___$ReturnUdt$ = -4					; size = 4
__Len$dead$ = 8						; size = 4
??__Ks@string_literals@literals@std@@YA?AV?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@3@PB_SI@Z PROC ; std::literals::string_literals::operator "" s, COMDAT
; ___$ReturnUdt$ = ecx
; __Str$dead$ = edx

; 4973 :         _NODISCARD _CONSTEXPR20_STRING_LITERALS u16string operator"" s(const char16_t* _Str, size_t _Len) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	xor	eax, eax

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	push	10					; 0000000aH
	push	OFFSET ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@

; 4973 :         _NODISCARD _CONSTEXPR20_STRING_LITERALS u16string operator"" s(const char16_t* _Str, size_t _Len) {

	mov	DWORD PTR ___$ReturnUdt$[ebp], esi

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [esi], 0

; 4562 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 7

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [esi], ax

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	push	esi

; 4973 :         _NODISCARD _CONSTEXPR20_STRING_LITERALS u16string operator"" s(const char16_t* _Str, size_t _Len) {

	mov	DWORD PTR ___$ReturnUdt$GSCopy$[ebp], esi

; 3214 :             _Mypair._Myval2._Mysize = _Count;

	mov	DWORD PTR [esi+16], 5

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	call	_memmove
	add	esp, 12					; 0000000cH

; 3216 :             _Traits::assign(_Old_ptr[_Count], _Elem());

	xor	eax, eax
	mov	WORD PTR [esi+10], ax

; 4974 :             return u16string(_Str, _Len);

	mov	eax, esi
	pop	esi

; 4975 :         }

	mov	esp, ebp
	pop	ebp
	ret	0
??__Ks@string_literals@literals@std@@YA?AV?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@3@PB_SI@Z ENDP ; std::literals::string_literals::operator "" s
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??__Ks@string_literals@literals@std@@YA?AV?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@3@PB_UI@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$ = -4				; size = 4
___$ReturnUdt$ = -4					; size = 4
__Len$dead$ = 8						; size = 4
??__Ks@string_literals@literals@std@@YA?AV?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@3@PB_UI@Z PROC ; std::literals::string_literals::operator "" s, COMDAT
; ___$ReturnUdt$ = ecx
; __Str$dead$ = edx

; 4977 :         _NODISCARD _CONSTEXPR20_STRING_LITERALS u32string operator"" s(const char32_t* _Str, size_t _Len) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR ___$ReturnUdt$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

	push	32					; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4977 :         _NODISCARD _CONSTEXPR20_STRING_LITERALS u32string operator"" s(const char32_t* _Str, size_t _Len) {

	mov	DWORD PTR ___$ReturnUdt$GSCopy$[ebp], esi

; 4562 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 3

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	DWORD PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

	call	??2@YAPAXI@Z				; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4489 :         _Mypair._Myval2._Mysize = _New_size;

	mov	DWORD PTR [esi+16], 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4490 :         _Mypair._Myval2._Myres  = _New_capacity;

	mov	DWORD PTR [esi+20], 7

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR ??_C@_2BI@CPCKAEFF@?$AA?$AA?$AAE?$AA?$AA?$AAt?$AA?$AA?$AAh?$AA?$AA?$AAa?$AA?$AA?$AAn@
	movups	XMMWORD PTR [eax], xmm0
	mov	ecx, DWORD PTR ??_C@_2BI@CPCKAEFF@?$AA?$AA?$AAE?$AA?$AA?$AAt?$AA?$AA?$AAh?$AA?$AA?$AAa?$AA?$AA?$AAn@+16
	mov	DWORD PTR [eax+16], ecx

; 3224 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	DWORD PTR [eax+20], 0

; 4496 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

	mov	DWORD PTR [esi], eax

; 4978 :             return u32string(_Str, _Len);

	mov	eax, esi
	pop	esi

; 4979 :         }

	mov	esp, ebp
	pop	ebp
	ret	0
??__Ks@string_literals@literals@std@@YA?AV?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@3@PB_UI@Z ENDP ; std::literals::string_literals::operator "" s
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??1_Facet_guard@locale@std@@QAE@XZ
_TEXT	SEGMENT
??1_Facet_guard@locale@std@@QAE@XZ PROC			; std::locale::_Facet_guard::~_Facet_guard, COMDAT
; _this$ = ecx

; 161  :             if (_Target) {

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@Facet_guar

; 162  :                 delete _Target->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN4@Facet_guar
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN4@Facet_guar:

; 163  :             }
; 164  :         }

	ret	0
??1_Facet_guard@locale@std@@QAE@XZ ENDP			; std::locale::_Facet_guard::~_Facet_guard
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ?_Construct@locale@std@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
__Guard$10 = -76					; size = 4
__Bad$1$ = -69						; size = 1
__Lobj$11 = -68						; size = 52
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Str$ = 8						; size = 4
__Cat$dead$ = 12					; size = 4
?_Construct@locale@std@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::locale::_Construct, COMDAT
; _this$ = ecx

; 285  :     void _Construct(const string& _Str, category _Cat) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Construct@locale@std@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	edi, DWORD PTR __Str$[ebp]

; 286  :         // construct a locale with named facets
; 287  :         bool _Bad = false;
; 288  :         _Init();

	push	0
	mov	BYTE PTR __Bad$1$[ebp], 0
	call	DWORD PTR __imp_?_Init@locale@std@@CAPAV_Locimp@12@_N@Z

; 289  :         if (_Cat != none) { // worth adding, do it
; 290  :             _Facet_guard _Guard{_Ptr};

	mov	eax, DWORD PTR [ebx+4]
	add	esp, 4
	mov	DWORD PTR __Guard$10[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2272 :         const value_type* _Result = _Bx._Buf;

	mov	eax, edi

; 2273 :         if (_Large_string_engaged()) {

	cmp	DWORD PTR [edi+20], 16			; 00000010H
	jb	SHORT $LN33@Construct

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [edi]
$LN33@Construct:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 291  :             _BEGIN_LOCINFO(_Lobj(_Cat, _Str.c_str()))

	push	eax
	push	63					; 0000003fH
	lea	ecx, DWORD PTR __Lobj$11[ebp]
	call	DWORD PTR __imp_??0_Locinfo@std@@QAE@HPBD@Z

; 407  :         return _CSTD strcmp(_Lobj._Getname(), "*") == 0;

	lea	ecx, DWORD PTR __Lobj$11[ebp]

; 291  :             _BEGIN_LOCINFO(_Lobj(_Cat, _Str.c_str()))

	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 407  :         return _CSTD strcmp(_Lobj._Getname(), "*") == 0;

	mov	esi, OFFSET ??_C@_01NBENCBCI@?$CK@
	call	DWORD PTR __imp_?_Getname@_Locinfo@std@@QBEPBDXZ
$LL34@Construct:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN35@Construct
	test	cl, cl
	je	SHORT $LN36@Construct
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN35@Construct
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $LL34@Construct
$LN36@Construct:
	xor	eax, eax
	jmp	SHORT $LN37@Construct
$LN35@Construct:
	sbb	eax, eax
	or	eax, 1
$LN37@Construct:
	test	eax, eax

; 292  :             if (_Badname(_Lobj)) {

	jne	SHORT $LN3@Construct

; 293  :                 _Bad = true;

	mov	BYTE PTR __Bad$1$[ebp], 1

; 294  :             } else { // name okay, build the locale

	jmp	SHORT $LN4@Construct
$LN3@Construct:

; 295  :                 _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, nullptr);

	push	0
	push	DWORD PTR [ebx+4]
	lea	eax, DWORD PTR __Lobj$11[ebp]
	push	63					; 0000003fH
	push	eax
	call	DWORD PTR __imp_?_Makeloc@_Locimp@locale@std@@CAPAV123@ABV_Locinfo@3@HPAV123@PBV23@@Z

; 296  :                 _Ptr->_Catmask = _Cat;

	mov	eax, DWORD PTR [ebx+4]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [eax+16], 63			; 0000003fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2273 :         if (_Large_string_engaged()) {

	cmp	DWORD PTR [edi+20], 16			; 00000010H
	jb	SHORT $LN23@Construct

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

	mov	edi, DWORD PTR [edi]
$LN23@Construct:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 297  :                 _Ptr->_Name    = _Str.c_str();

	mov	ecx, DWORD PTR [ebx+4]
	push	edi
	add	ecx, 24					; 00000018H
	call	DWORD PTR __imp_??4?$_Yarn@D@std@@QAEAAV01@PBD@Z
$LN4@Construct:

; 298  :             }
; 299  :             _END_LOCINFO()

	lea	ecx, DWORD PTR __Lobj$11[ebp]
	call	DWORD PTR __imp_??1_Locinfo@std@@QAE@XZ

; 300  :             _Guard._Target = nullptr;
; 301  :         }
; 302  : 
; 303  :         if (_Bad) { // Don't throw within _BEGIN_LOCINFO if we can avoid it

	cmp	BYTE PTR __Bad$1$[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	je	SHORT $LN5@Construct

; 304  :             delete _Ptr->_Decref();

	mov	ecx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN7@Construct
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN7@Construct:

; 305  :             _Xruntime_error("bad locale name");

	push	OFFSET ??_C@_0BA@ELKIONDK@bad?5locale?5name@
	call	DWORD PTR __imp_?_Xruntime_error@std@@YAXPBD@Z
$LN5@Construct:

; 306  :         }
; 307  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
$LN39@Construct:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Construct@locale@std@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0:
	lea	ecx, DWORD PTR __Guard$10[ebp]
	jmp	??1_Facet_guard@locale@std@@QAE@XZ	; std::locale::_Facet_guard::~_Facet_guard
__unwindfunclet$?_Construct@locale@std@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$1:
	lea	ecx, DWORD PTR __Lobj$11[ebp]
	jmp	DWORD PTR __imp_??1_Locinfo@std@@QAE@XZ
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?_Construct@locale@std@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Construct@locale@std@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Construct@locale@std@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::locale::_Construct
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??0locale@std@@QAE@PBDH@Z
_TEXT	SEGMENT
__Guard$15 = -96					; size = 4
$T1 = -92						; size = 24
__Lobj$16 = -68						; size = 52
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Locname$dead$ = 8					; size = 4
__Cat$dead$ = 12					; size = 4
??0locale@std@@QAE@PBDH@Z PROC				; std::locale::locale, COMDAT
; _this$ = ecx

; 310  :     explicit locale(const char* _Locname, category _Cat = all) : _Ptr(_Locimp::_New_Locimp()) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0locale@std@@QAE@PBDH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	push	0
	call	DWORD PTR __imp_?_New_Locimp@_Locimp@locale@std@@CAPAV123@_N@Z
	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR $T1[ebp], 0

; 3230 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	ecx, DWORD PTR $T1[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 310  :     explicit locale(const char* _Locname, category _Cat = all) : _Ptr(_Locimp::_New_Locimp()) {

	mov	DWORD PTR [edi+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4562 :         _My_data._Mysize = 0;

	mov	DWORD PTR $T1[ebp+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR $T1[ebp+20], 15		; 0000000fH

; 3230 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	push	3
	push	OFFSET ??_C@_03LFPOMIKD@chs@

; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[ebp], 0

; 3230 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 288  :         _Init();

	push	0

; 311  :         // construct a locale with named facets
; 312  :         // _Locname might have been returned from setlocale().
; 313  :         // Therefore, _Construct() takes const string&.
; 314  :         if (_Locname) {
; 315  :             _Construct(_Locname, _Cat);

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 287  :         bool _Bad = false;

	xor	bl, bl

; 288  :         _Init();

	call	DWORD PTR __imp_?_Init@locale@std@@CAPAV_Locimp@12@_N@Z

; 289  :         if (_Cat != none) { // worth adding, do it
; 290  :             _Facet_guard _Guard{_Ptr};

	mov	eax, DWORD PTR [edi+4]
	add	esp, 4
	mov	DWORD PTR __Guard$15[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2272 :         const value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR $T1[ebp]

; 2273 :         if (_Large_string_engaged()) {

	cmp	DWORD PTR $T1[ebp+20], 16		; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 291  :             _BEGIN_LOCINFO(_Lobj(_Cat, _Str.c_str()))

	lea	ecx, DWORD PTR __Lobj$16[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2273 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR $T1[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 291  :             _BEGIN_LOCINFO(_Lobj(_Cat, _Str.c_str()))

	push	eax
	push	63					; 0000003fH
	call	DWORD PTR __imp_??0_Locinfo@std@@QAE@HPBD@Z

; 407  :         return _CSTD strcmp(_Lobj._Getname(), "*") == 0;

	lea	ecx, DWORD PTR __Lobj$16[ebp]

; 291  :             _BEGIN_LOCINFO(_Lobj(_Cat, _Str.c_str()))

	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 407  :         return _CSTD strcmp(_Lobj._Getname(), "*") == 0;

	mov	esi, OFFSET ??_C@_01NBENCBCI@?$CK@
	call	DWORD PTR __imp_?_Getname@_Locinfo@std@@QBEPBDXZ
	npad	6
$LL80@locale:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN81@locale
	test	cl, cl
	je	SHORT $LN82@locale
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN81@locale
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $LL80@locale
$LN82@locale:
	xor	eax, eax
	jmp	SHORT $LN83@locale
$LN81@locale:
	sbb	eax, eax
	or	eax, 1
$LN83@locale:
	test	eax, eax

; 292  :             if (_Badname(_Lobj)) {

	jne	SHORT $LN23@locale

; 293  :                 _Bad = true;

	mov	bl, 1

; 294  :             } else { // name okay, build the locale

	jmp	SHORT $LN24@locale
$LN23@locale:

; 295  :                 _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, nullptr);

	push	0
	push	DWORD PTR [edi+4]
	lea	eax, DWORD PTR __Lobj$16[ebp]
	push	63					; 0000003fH
	push	eax
	call	DWORD PTR __imp_?_Makeloc@_Locimp@locale@std@@CAPAV123@ABV_Locinfo@3@HPAV123@PBV23@@Z

; 296  :                 _Ptr->_Catmask = _Cat;

	mov	eax, DWORD PTR [edi+4]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [eax+16], 63			; 0000003fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2272 :         const value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR $T1[ebp]

; 2273 :         if (_Large_string_engaged()) {

	cmp	DWORD PTR $T1[ebp+20], 16		; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 297  :                 _Ptr->_Name    = _Str.c_str();

	mov	ecx, DWORD PTR [edi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2273 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR $T1[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 297  :                 _Ptr->_Name    = _Str.c_str();

	add	ecx, 24					; 00000018H
	push	eax
	call	DWORD PTR __imp_??4?$_Yarn@D@std@@QAEAAV01@PBD@Z
$LN24@locale:

; 298  :             }
; 299  :             _END_LOCINFO()

	lea	ecx, DWORD PTR __Lobj$16[ebp]
	call	DWORD PTR __imp_??1_Locinfo@std@@QAE@XZ

; 300  :             _Guard._Target = nullptr;
; 301  :         }

	mov	BYTE PTR __$EHRec$[ebp+8], 0

; 302  : 
; 303  :         if (_Bad) { // Don't throw within _BEGIN_LOCINFO if we can avoid it

	test	bl, bl
	je	SHORT $LN25@locale

; 304  :             delete _Ptr->_Decref();

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN27@locale
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN27@locale:

; 305  :             _Xruntime_error("bad locale name");

	push	OFFSET ??_C@_0BA@ELKIONDK@bad?5locale?5name@
	call	DWORD PTR __imp_?_Xruntime_error@std@@YAXPBD@Z
$LN25@locale:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR $T1[ebp+20]
	cmp	edx, 16					; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN65@locale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T1[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN75@locale

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN75@locale
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN75@locale:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN65@locale:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 320  :     }

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
$LN85@locale:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0locale@std@@QAE@PBDH@Z$0:
	lea	ecx, DWORD PTR $T1[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0locale@std@@QAE@PBDH@Z$3:
	lea	ecx, DWORD PTR __Guard$15[ebp]
	jmp	??1_Facet_guard@locale@std@@QAE@XZ	; std::locale::_Facet_guard::~_Facet_guard
__unwindfunclet$??0locale@std@@QAE@PBDH@Z$4:
	lea	ecx, DWORD PTR __Lobj$16[ebp]
	jmp	DWORD PTR __imp_??1_Locinfo@std@@QAE@XZ
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0locale@std@@QAE@PBDH@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-100]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0locale@std@@QAE@PBDH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0locale@std@@QAE@PBDH@Z ENDP				; std::locale::locale
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 346  :         if (_Ptr) {

	mov	ecx, DWORD PTR [ecx+4]
	test	ecx, ecx
	je	SHORT $LN4@locale

; 347  :             delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN4@locale
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN4@locale:

; 348  :         }
; 349  :     }

	ret	0
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ?_Badname@locale@std@@AAE_NABV_Locinfo@2@@Z
_TEXT	SEGMENT
__Lobj$ = 8						; size = 4
?_Badname@locale@std@@AAE_NABV_Locinfo@2@@Z PROC	; std::locale::_Badname, COMDAT
; _this$dead$ = ecx

; 406  :     bool _Badname(const _Locinfo& _Lobj) { // test if name is "*"

	push	ebp
	mov	ebp, esp

; 407  :         return _CSTD strcmp(_Lobj._Getname(), "*") == 0;

	mov	ecx, DWORD PTR __Lobj$[ebp]
	push	esi
	mov	esi, OFFSET ??_C@_01NBENCBCI@?$CK@
	call	DWORD PTR __imp_?_Getname@_Locinfo@std@@QBEPBDXZ
$LL3@Badname:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN4@Badname
	test	cl, cl
	je	SHORT $LN5@Badname
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN4@Badname
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $LL3@Badname
$LN5@Badname:
	xor	eax, eax
	test	eax, eax
	pop	esi
	sete	al

; 408  :     }

	pop	ebp
	ret	4
$LN4@Badname:

; 407  :         return _CSTD strcmp(_Lobj._Getname(), "*") == 0;

	sbb	eax, eax
	or	eax, 1
	test	eax, eax
	pop	esi
	sete	al

; 408  :     }

	pop	ebp
	ret	4
?_Badname@locale@std@@AAE_NABV_Locinfo@2@@Z ENDP	; std::locale::_Badname
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp
;	COMDAT _main
_TEXT	SEGMENT
$T112 = -244						; size = 8
$T97 = -236						; size = 8
$T67 = -228						; size = 24
$T2 = -228						; size = 24
$T98 = -204						; size = 24
$T41 = -204						; size = 24
$T15 = -204						; size = 24
__Bad$1$ = -177						; size = 1
$T135 = -176						; size = 4
$T88 = -176						; size = 1
$T9 = -176						; size = 1
__Guard$136 = -176					; size = 4
__Lobj$137 = -172					; size = 52
_name02$ = -120						; size = 24
_name03$ = -96						; size = 24
_name00$ = -72						; size = 24
_name01$ = -48						; size = 24
_Name$ = -24						; size = 6
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_main	PROC						; COMDAT

; 9    : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$_main
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2469 :         assign(_Ptr, _Count);

	push	5

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR $T2[ebp], 0

; 2469 :         assign(_Ptr, _Count);

	lea	ecx, DWORD PTR $T2[ebp]
	push	OFFSET ??_C@_05FBADLLFO@Ethan@

; 4562 :         _My_data._Mysize = 0;

	mov	DWORD PTR $T2[ebp+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR $T2[ebp+20], 15		; 0000000fH

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T2[ebp], 0

; 2469 :         assign(_Ptr, _Count);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp

; 12   : 	std::string name00 = u8"Ethan"s + "00";

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3120 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	edx, DWORD PTR $T2[ebp+20]
	mov	eax, edx
	mov	ecx, DWORD PTR $T2[ebp+16]
	sub	eax, ecx

; 3121 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	eax, 2
	jb	SHORT $LN44@main

; 3122 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [ecx+2]

; 2264 :         if (_Large_string_engaged()) {

	cmp	edx, 16					; 00000010H

; 3122 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	DWORD PTR $T2[ebp+16], eax

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	edx, 12336				; 00003030H

; 2263 :         value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR $T2[ebp]

; 2264 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR $T2[ebp]

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	WORD PTR [eax+ecx], dx

; 3125 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [eax+ecx+2], 0

; 3126 :             return *this;

	lea	eax, DWORD PTR $T2[ebp]
	jmp	SHORT $LN43@main
$LN44@main:

; 3127 :         }
; 3128 : 
; 3129 :         return _Reallocate_grow_by(

	push	2
	push	ecx
	mov	BYTE PTR $T9[ebp], 0
	lea	ecx, DWORD PTR $T2[ebp]
	push	DWORD PTR $T9[ebp]
	push	2
	call	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN43@main:

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR _name00$[ebp], 0

; 2322 :     size_type _Mysize = 0; // current length of string

	mov	DWORD PTR _name00$[ebp+16], 0

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

	mov	DWORD PTR _name00$[ebp+20], 0

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR _name00$[ebp], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR _name00$[ebp+16], xmm0

; 4562 :         _My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [eax], 0
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp

; 12   : 	std::string name00 = u8"Ethan"s + "00";

	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

	mov	edx, DWORD PTR $T2[ebp+20]
	cmp	edx, 16					; 00000010H
	jb	SHORT $LN90@main
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T2[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN100@main

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN100@main
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN100@main:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN90@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	ax, WORD PTR ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@+8

; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	esi, 7

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	movq	xmm0, QWORD PTR ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@
	mov	WORD PTR $T15[ebp+8], ax

; 3216 :             _Traits::assign(_Old_ptr[_Count], _Elem());

	xor	eax, eax

; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR $T15[ebp+20], esi

; 3214 :             _Mypair._Myval2._Mysize = _Count;

	lea	edx, DWORD PTR [esi-2]

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	movq	QWORD PTR $T15[ebp], xmm0

; 3216 :             _Traits::assign(_Old_ptr[_Count], _Elem());

	mov	WORD PTR $T15[ebp+10], ax
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp

; 13   : 	std::wstring name01 = L"Ethan"s + L"01";

	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2263 :         value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR $T15[ebp]

; 3122 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	ecx, DWORD PTR [edx+2]
	mov	DWORD PTR $T15[ebp+16], ecx

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	DWORD PTR [eax+edx*2], 3211312		; 00310030H

; 3125 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	xor	edx, edx
	mov	WORD PTR [eax+ecx*2], dx

; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	xor	ecx, ecx

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR _name01$[ebp], edx

; 2322 :     size_type _Mysize = 0; // current length of string

	mov	DWORD PTR _name01$[ebp+16], edx

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

	mov	DWORD PTR _name01$[ebp+20], edx

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR _name01$[ebp], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR _name01$[ebp+16], xmm0

; 4562 :         _My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], edx

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], esi

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [eax], cx
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp

; 13   : 	std::wstring name01 = L"Ethan"s + L"01";

	mov	BYTE PTR __$EHRec$[ebp+8], 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

	mov	edx, DWORD PTR $T15[ebp+20]
	cmp	edx, 8
	jb	SHORT $LN249@main
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T15[ebp]
	lea	edx, DWORD PTR [edx*2+2]
	mov	eax, ecx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN259@main

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN259@main
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN259@main:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN249@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	ax, WORD PTR ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@+8

; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	esi, 7

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	movq	xmm0, QWORD PTR ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@
	mov	WORD PTR $T41[ebp+8], ax

; 3216 :             _Traits::assign(_Old_ptr[_Count], _Elem());

	xor	eax, eax

; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR $T41[ebp+20], esi

; 3214 :             _Mypair._Myval2._Mysize = _Count;

	lea	edx, DWORD PTR [esi-2]

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	movq	QWORD PTR $T41[ebp], xmm0

; 3216 :             _Traits::assign(_Old_ptr[_Count], _Elem());

	mov	WORD PTR $T41[ebp+10], ax
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp

; 14   : 	std::u16string name02 = u"Ethan"s + u"02";

	mov	BYTE PTR __$EHRec$[ebp+8], 6
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2263 :         value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR $T41[ebp]

; 3122 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	ecx, DWORD PTR [edx+2]
	mov	DWORD PTR $T41[ebp+16], ecx

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	DWORD PTR [eax+edx*2], 3276848		; 00320030H

; 3125 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	xor	edx, edx
	mov	WORD PTR [eax+ecx*2], dx

; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	xor	ecx, ecx

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR _name02$[ebp], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR _name02$[ebp+16], xmm0

; 4562 :         _My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], edx

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], esi

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [eax], cx
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp

; 14   : 	std::u16string name02 = u"Ethan"s + u"02";

	mov	BYTE PTR __$EHRec$[ebp+8], 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

	mov	edx, DWORD PTR $T41[ebp+20]
	cmp	edx, 8
	jb	SHORT $LN407@main
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T41[ebp]
	lea	edx, DWORD PTR [edx*2+2]
	mov	eax, ecx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN417@main

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN417@main
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN417@main:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN407@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	xor	eax, eax
	mov	DWORD PTR $T41[ebp+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

	push	32					; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4600 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR $T41[ebp+20], 7

; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	WORD PTR $T41[ebp], ax

; 4562 :         _My_data._Mysize = 0;

	mov	DWORD PTR $T67[ebp+16], eax

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR $T67[ebp+20], 3

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	DWORD PTR $T67[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

	call	??2@YAPAXI@Z				; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR ??_C@_2BI@CPCKAEFF@?$AA?$AA?$AAE?$AA?$AA?$AAt?$AA?$AA?$AAh?$AA?$AA?$AAa?$AA?$AA?$AAn@

; 4489 :         _Mypair._Myval2._Mysize = _New_size;

	mov	DWORD PTR $T67[ebp+16], 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4490 :         _Mypair._Myval2._Myres  = _New_capacity;

	mov	DWORD PTR $T67[ebp+20], 7

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	XMMWORD PTR [eax], xmm0
	mov	ecx, DWORD PTR ??_C@_2BI@CPCKAEFF@?$AA?$AA?$AAE?$AA?$AA?$AAt?$AA?$AA?$AAh?$AA?$AA?$AAa?$AA?$AA?$AAn@+16
	mov	DWORD PTR [eax+16], ecx

; 3224 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	DWORD PTR [eax+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 235  :         return _Traits::_Allocate(_Bytes);

	mov	DWORD PTR $T135[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4496 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

	mov	DWORD PTR $T67[ebp], eax
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp

; 15   : 	std::u32string name03 = U"Ethan"s + U"03";

	mov	BYTE PTR __$EHRec$[ebp+8], 9
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3141 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	eax, OFFSET ??_C@_2M@JLEBFLAK@?$AA?$AA?$AA0?$AA?$AA?$AA3@

; 144  :         size_t _Count = 0;

	xor	edx, edx
	npad	6
$LL519@main:

; 145  :         while (*_First != _Elem()) {
; 146  :             ++_Count;
; 147  :             ++_First;

	lea	eax, DWORD PTR [eax+4]
	inc	edx
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LL519@main

; 3120 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	eax, DWORD PTR $T67[ebp+20]
	mov	ecx, DWORD PTR $T67[ebp+16]
	sub	eax, ecx

; 3121 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	edx, eax
	ja	SHORT $LN523@main

; 2264 :         if (_Large_string_engaged()) {

	cmp	DWORD PTR $T67[ebp+20], 4
	lea	esi, DWORD PTR $T67[ebp]

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	lea	eax, DWORD PTR [edx*4]

; 2264 :         if (_Large_string_engaged()) {

	cmovae	esi, DWORD PTR $T135[ebp]

; 3122 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	edi, DWORD PTR [edx+ecx]

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	push	eax
	push	OFFSET ??_C@_2M@JLEBFLAK@?$AA?$AA?$AA0?$AA?$AA?$AA3@

; 3122 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	DWORD PTR $T67[ebp+16], edi

; 3123 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3124 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	lea	ecx, DWORD PTR [esi+ecx*4]

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	push	ecx
	call	_memmove
	add	esp, 12					; 0000000cH

; 3125 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	DWORD PTR [esi+edi*4], 0

; 3126 :             return *this;

	lea	eax, DWORD PTR $T67[ebp]
	jmp	SHORT $LN522@main
$LN523@main:

; 3127 :         }
; 3128 : 
; 3129 :         return _Reallocate_grow_by(

	push	edx
	push	ecx
	mov	BYTE PTR $T88[ebp], 0
	lea	ecx, DWORD PTR $T67[ebp]
	push	DWORD PTR $T88[ebp]
	push	edx
	call	??$_Reallocate_grow_by@V<lambda_aabcc5df0dcdbd223414bc3ba38ad6d9>@@PB_UI@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEAAV01@IV<lambda_aabcc5df0dcdbd223414bc3ba38ad6d9>@@PB_UI@Z ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Reallocate_grow_by<<lambda_aabcc5df0dcdbd223414bc3ba38ad6d9>,char32_t const *,unsigned int>
$LN522@main:

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR _name03$[ebp], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR _name03$[ebp+16], xmm0

; 4562 :         _My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 3

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	DWORD PTR [eax], 0
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp

; 15   : 	std::u32string name03 = U"Ethan"s + U"03";

	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

	mov	edx, DWORD PTR $T67[ebp+20]
	cmp	edx, 4
	jb	SHORT $LN569@main
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T67[ebp]
	lea	edx, DWORD PTR [edx*4+4]
	mov	eax, ecx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN579@main

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN579@main
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN579@main:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN569@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2273 :         if (_Large_string_engaged()) {

	cmp	DWORD PTR _name00$[ebp+20], 16		; 00000010H
	lea	edx, DWORD PTR _name00$[ebp]

; 4947 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A

; 2273 :         if (_Large_string_engaged()) {

	cmovae	edx, DWORD PTR _name00$[ebp]
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp

; 25   : 	std::cout << name00 << std::endl;

	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4947 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

	push	DWORD PTR _name00$[ebp+16]

; 4599 :             _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR $T67[ebp+16], 0

; 4600 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR $T67[ebp+20], 3

; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	DWORD PTR $T67[ebp], 0

; 4947 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

	call	??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
	add	esp, 4
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp

; 25   : 	std::cout << name00 << std::endl;

	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 310  :     explicit locale(const char* _Locname, category _Cat = all) : _Ptr(_Locimp::_New_Locimp()) {

	push	0
	call	DWORD PTR __imp_?_New_Locimp@_Locimp@locale@std@@CAPAV123@_N@Z
	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR $T98[ebp], 0

; 3230 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	ecx, DWORD PTR $T98[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 310  :     explicit locale(const char* _Locname, category _Cat = all) : _Ptr(_Locimp::_New_Locimp()) {

	mov	DWORD PTR $T97[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4562 :         _My_data._Mysize = 0;

	mov	DWORD PTR $T98[ebp+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR $T98[ebp+20], 15		; 0000000fH

; 3230 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	push	3
	push	OFFSET ??_C@_03LFPOMIKD@chs@

; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T98[ebp], 0

; 3230 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 288  :         _Init();

	push	0

; 315  :             _Construct(_Locname, _Cat);

	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH

; 287  :         bool _Bad = false;

	mov	BYTE PTR __Bad$1$[ebp], 0

; 288  :         _Init();

	call	DWORD PTR __imp_?_Init@locale@std@@CAPAV_Locimp@12@_N@Z

; 289  :         if (_Cat != none) { // worth adding, do it
; 290  :             _Facet_guard _Guard{_Ptr};

	mov	eax, DWORD PTR $T97[ebp+4]
	add	esp, 4
	mov	DWORD PTR __Guard$136[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2272 :         const value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR $T98[ebp]

; 2273 :         if (_Large_string_engaged()) {

	cmp	DWORD PTR $T98[ebp+20], 16		; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 291  :             _BEGIN_LOCINFO(_Lobj(_Cat, _Str.c_str()))

	lea	ecx, DWORD PTR __Lobj$137[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2273 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR $T98[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 291  :             _BEGIN_LOCINFO(_Lobj(_Cat, _Str.c_str()))

	push	eax
	push	63					; 0000003fH
	call	DWORD PTR __imp_??0_Locinfo@std@@QAE@HPBD@Z

; 407  :         return _CSTD strcmp(_Lobj._Getname(), "*") == 0;

	lea	ecx, DWORD PTR __Lobj$137[ebp]

; 291  :             _BEGIN_LOCINFO(_Lobj(_Cat, _Str.c_str()))

	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH

; 407  :         return _CSTD strcmp(_Lobj._Getname(), "*") == 0;

	mov	esi, OFFSET ??_C@_01NBENCBCI@?$CK@
	call	DWORD PTR __imp_?_Getname@_Locinfo@std@@QBEPBDXZ
$LL841@main:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN842@main
	test	cl, cl
	je	SHORT $LN843@main
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN842@main
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $LL841@main
$LN843@main:
	xor	eax, eax
	jmp	SHORT $LN844@main
$LN842@main:
	sbb	eax, eax
	or	eax, 1
$LN844@main:
	test	eax, eax

; 292  :             if (_Badname(_Lobj)) {

	jne	SHORT $LN615@main

; 293  :                 _Bad = true;

	mov	BYTE PTR __Bad$1$[ebp], 1

; 294  :             } else { // name okay, build the locale

	jmp	SHORT $LN616@main
$LN615@main:

; 295  :                 _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, nullptr);

	push	0
	push	DWORD PTR $T97[ebp+4]
	lea	eax, DWORD PTR __Lobj$137[ebp]
	push	63					; 0000003fH
	push	eax
	call	DWORD PTR __imp_?_Makeloc@_Locimp@locale@std@@CAPAV123@ABV_Locinfo@3@HPAV123@PBV23@@Z

; 296  :                 _Ptr->_Catmask = _Cat;

	mov	eax, DWORD PTR $T97[ebp+4]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [eax+16], 63			; 0000003fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2272 :         const value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR $T98[ebp]

; 2273 :         if (_Large_string_engaged()) {

	cmp	DWORD PTR $T98[ebp+20], 16		; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 297  :                 _Ptr->_Name    = _Str.c_str();

	mov	ecx, DWORD PTR $T97[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2273 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR $T98[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 297  :                 _Ptr->_Name    = _Str.c_str();

	push	eax
	lea	ecx, DWORD PTR [ecx+24]
	call	DWORD PTR __imp_??4?$_Yarn@D@std@@QAEAAV01@PBD@Z
$LN616@main:

; 298  :             }
; 299  :             _END_LOCINFO()

	lea	ecx, DWORD PTR __Lobj$137[ebp]
	call	DWORD PTR __imp_??1_Locinfo@std@@QAE@XZ

; 300  :             _Guard._Target = nullptr;
; 301  :         }
; 302  : 
; 303  :         if (_Bad) { // Don't throw within _BEGIN_LOCINFO if we can avoid it

	cmp	BYTE PTR __Bad$1$[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	je	SHORT $LN617@main

; 304  :             delete _Ptr->_Decref();

	mov	ecx, DWORD PTR $T97[ebp+4]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+8]
	call	eax
	test	eax, eax
	je	SHORT $LN619@main
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN619@main:

; 305  :             _Xruntime_error("bad locale name");

	push	OFFSET ??_C@_0BA@ELKIONDK@bad?5locale?5name@
	call	DWORD PTR __imp_?_Xruntime_error@std@@YAXPBD@Z
$LN617@main:

; 315  :             _Construct(_Locname, _Cat);

	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

	mov	edx, DWORD PTR $T98[ebp+20]
	cmp	edx, 16					; 00000010H
	jb	SHORT $LN657@main
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T98[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN667@main

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN667@main
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN667@main:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN657@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4599 :             _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR $T98[ebp+16], 0

; 4600 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR $T98[ebp+20], 15		; 0000000fH

; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T98[ebp], 0
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp

; 27   : 	wcout.imbue(locale("chs"));

	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	lea	eax, DWORD PTR $T97[ebp]
	mov	edx, DWORD PTR __imp_?wcout@std@@3V?$basic_ostream@_WU?$char_traits@_W@std@@@1@A
	push	eax
	lea	eax, DWORD PTR $T112[ebp]
	push	eax
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	call	DWORD PTR __imp_?imbue@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAE?AVlocale@2@ABV32@@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 346  :         if (_Ptr) {

	mov	ecx, DWORD PTR $T112[ebp+4]
	test	ecx, ecx
	je	SHORT $LN675@main

; 347  :             delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+8]
	call	eax
	test	eax, eax
	je	SHORT $LN675@main
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN675@main:
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp

; 27   : 	wcout.imbue(locale("chs"));

	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale

; 346  :         if (_Ptr) {

	mov	ecx, DWORD PTR $T97[ebp+4]
	test	ecx, ecx
	je	SHORT $LN680@main

; 347  :             delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+8]
	call	eax
	test	eax, eax
	je	SHORT $LN680@main
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN680@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR _name01$[ebp+20], 8

; 2272 :         const value_type* _Result = _Bx._Buf;

	lea	edx, DWORD PTR _name01$[ebp]

; 4947 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

	mov	ecx, DWORD PTR __imp_?wcout@std@@3V?$basic_ostream@_WU?$char_traits@_W@std@@@1@A

; 2273 :         if (_Large_string_engaged()) {

	cmovae	edx, DWORD PTR _name01$[ebp]
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp

; 28   : 	wcout << name01 << endl;

	push	OFFSET ??$endl@_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@@Z ; std::endl<wchar_t,std::char_traits<wchar_t> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4947 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

	push	DWORD PTR _name01$[ebp+16]
	call	??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z ; std::_Insert_string<wchar_t,std::char_traits<wchar_t>,unsigned int>
	add	esp, 4
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp

; 28   : 	wcout << name01 << endl;

	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR _name02$[ebp+20], 8

; 2263 :         value_type* _Result = _Bx._Buf;

	lea	ecx, DWORD PTR _name02$[ebp]

; 3715 :         return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;

	mov	eax, DWORD PTR _name02$[ebp+16]

; 2263 :         value_type* _Result = _Bx._Buf;

	lea	esi, DWORD PTR _name02$[ebp]

; 2264 :         if (_Large_string_engaged()) {

	cmovae	ecx, DWORD PTR _name02$[ebp]
	cmovae	esi, DWORD PTR _name02$[ebp]

; 3715 :         return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;

	lea	edi, DWORD PTR [ecx+eax*2]
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp

; 30   : 	for (const auto& c : name02)

	cmp	esi, edi
	je	SHORT $LN3@main
$LL4@main:

; 31   : 		std::cout << static_cast<char>(c);

	mov	dl, BYTE PTR [esi]
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
	add	esi, 2
	cmp	esi, edi
	jne	SHORT $LL4@main
$LN3@main:

; 32   : 	std::cout << "\0" << std::endl;

	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	mov	edx, OFFSET ??_C@_01LOCGONAA@?$AA@
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR _name03$[ebp+20], 4

; 2263 :         value_type* _Result = _Bx._Buf;

	lea	ecx, DWORD PTR _name03$[ebp]

; 2264 :         if (_Large_string_engaged()) {

	mov	edi, DWORD PTR _name03$[ebp]
	lea	esi, DWORD PTR _name03$[ebp]

; 3715 :         return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;

	mov	eax, DWORD PTR _name03$[ebp+16]

; 2264 :         if (_Large_string_engaged()) {

	cmovae	ecx, edi
	cmovae	esi, edi

; 3715 :         return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;

	lea	eax, DWORD PTR [ecx+eax*4]
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp

; 34   : 	for (const auto& c : name03)

	cmp	esi, eax
	je	SHORT $LN6@main
	mov	edi, eax
$LL7@main:

; 35   : 		std::cout << static_cast<char>(c);

	mov	dl, BYTE PTR [esi]
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
	add	esi, 4
	cmp	esi, edi
	jne	SHORT $LL7@main
	mov	edi, DWORD PTR _name03$[ebp]
$LN6@main:

; 36   : 	std::cout << "\0" << std::endl;

	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	mov	edx, OFFSET ??_C@_01LOCGONAA@?$AA@
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 37   : 
; 38   : 	std::cout << example << std::endl;

	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	mov	edx, OFFSET ??_C@_0BC@GBLLDDOB@Line1?6Line2?6Line3@
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 39   : 	std::cout << ex << std::endl;

	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	mov	edx, OFFSET ??_C@_0BD@CGOJJEID@line4?6line5?6line6?6@
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 40   : 
; 41   : 	char Name[] = u8"Ethan";	//

	mov	eax, DWORD PTR ??_C@_05FBADLLFO@Ethan@

; 42   : 	const char* name = Name;
; 43   : 
; 44   : 	//
; 45   : 	const wchar_t* name2 = L"Ethan";	//
; 46   : 
; 47   : 	const char16_t* name3 = u"Etahn";	//16
; 48   : 	const char32_t* name4 = U"Etahn";	//32
; 49   : 
; 50   : 	std::cout << "name:" << name << std::endl;

	mov	edx, OFFSET ??_C@_05HKGIJGOH@name?3@
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	mov	DWORD PTR _Name$[ebp], eax
	mov	ax, WORD PTR ??_C@_05FBADLLFO@Ethan@+4
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	WORD PTR _Name$[ebp+4], ax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	lea	edx, DWORD PTR _Name$[ebp]
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 51   : 	
; 52   : 	std::cin.get();

	mov	ecx, DWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
	call	DWORD PTR __imp_?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

	mov	eax, DWORD PTR _name03$[ebp+20]
	cmp	eax, 4

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN731@main
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	ecx, DWORD PTR [eax*4+4]
	mov	eax, edi

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN741@main

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edi, DWORD PTR [edi-4]
	add	ecx, 35					; 00000023H
	sub	eax, edi

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	$LN819@main
$LN741@main:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN731@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

	mov	eax, DWORD PTR _name02$[ebp+20]
	cmp	eax, 8

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN758@main
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR _name02$[ebp]
	lea	edx, DWORD PTR [eax*2+2]
	mov	eax, ecx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN768@main

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN819@main
$LN768@main:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN758@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR _name01$[ebp+20]
	cmp	edx, 8

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN785@main
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR _name01$[ebp]
	lea	edx, DWORD PTR [edx*2+2]
	mov	eax, ecx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN795@main

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN819@main
$LN795@main:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN785@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR _name00$[ebp+20]

; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	xor	eax, eax
	mov	DWORD PTR _name01$[ebp+16], 0
	mov	DWORD PTR _name01$[ebp+20], 7
	mov	WORD PTR _name01$[ebp], ax

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN812@main
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR _name00$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN822@main

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN822@main
$LN819@main:
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN822@main:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN812@main:
; File C:\dev\StringLiterals\StringLiterals\src\main.cpp

; 53   : }

	xor	eax, eax
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN846@main:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_main$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_main$1:
	lea	ecx, DWORD PTR _name00$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_main$2:
	lea	ecx, DWORD PTR $T15[ebp]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$_main$3:
	lea	ecx, DWORD PTR _name01$[ebp]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$_main$4:
	lea	ecx, DWORD PTR $T41[ebp]
	jmp	??1?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAE@XZ ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::~basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >
__unwindfunclet$_main$5:
	lea	ecx, DWORD PTR _name02$[ebp]
	jmp	??1?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAE@XZ ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::~basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >
__unwindfunclet$_main$6:
	lea	ecx, DWORD PTR $T67[ebp]
	jmp	??1?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAE@XZ ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::~basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >
__unwindfunclet$_main$7:
	lea	ecx, DWORD PTR _name03$[ebp]
	jmp	??1?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAE@XZ ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::~basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >
__unwindfunclet$_main$42:
	lea	ecx, DWORD PTR $T98[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_main$45:
	lea	ecx, DWORD PTR __Guard$136[ebp]
	jmp	??1_Facet_guard@locale@std@@QAE@XZ	; std::locale::_Facet_guard::~_Facet_guard
__unwindfunclet$_main$46:
	lea	ecx, DWORD PTR __Lobj$137[ebp]
	jmp	DWORD PTR __imp_??1_Locinfo@std@@QAE@XZ
__unwindfunclet$_main$8:
	lea	ecx, DWORD PTR $T97[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$_main:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$_main
	jmp	___CxxFrameHandler3
text$x	ENDS
_main	ENDP
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Unchecked_end@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAEPA_UXZ
_TEXT	SEGMENT
?_Unchecked_end@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAEPA_UXZ PROC ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 4

; 2263 :         value_type* _Result = _Bx._Buf;

	mov	edx, ecx

; 2264 :         if (_Large_string_engaged()) {

	jb	SHORT $LN4@Unchecked_

; 2265 :             _Result = _Unfancy(_Bx._Ptr);

	mov	edx, DWORD PTR [ecx]
$LN4@Unchecked_:

; 3715 :         return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;

	mov	eax, DWORD PTR [ecx+16]
	lea	eax, DWORD PTR [edx+eax*4]

; 3716 :     }

	ret	0
?_Unchecked_end@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAEPA_UXZ ENDP ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Unchecked_begin@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAEPA_UXZ
_TEXT	SEGMENT
?_Unchecked_begin@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAEPA_UXZ PROC ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 4

; 2264 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@Unchecked_

; 3707 :         return _Mypair._Myval2._Myptr();

	mov	eax, DWORD PTR [ecx]

; 3708 :     }

	ret	0
$LN8@Unchecked_:

; 3707 :         return _Mypair._Myval2._Myptr();

	mov	eax, ecx

; 3708 :     }

	ret	0
?_Unchecked_begin@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAEPA_UXZ ENDP ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??1?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAE@XZ PROC ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::~basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >, COMDAT
; _this$ = ecx

; 2968 :     _CONSTEXPR20_CONTAINER ~basic_string() noexcept {

	push	esi
	mov	esi, ecx

; 2286 :         return _BUF_SIZE <= _Myres;

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 4

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN12@basic_stri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ecx*4+4]

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN22@basic_stri

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN19@basic_stri

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN22@basic_stri:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN12@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4599 :             _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 4600 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 3

; 4601 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	DWORD PTR [esi], 0
	pop	esi

; 2976 :     }

	ret	0
$LN19@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN27@basic_stri:
	int	3
??1?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAE@XZ ENDP ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::~basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAE@QB_UI@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
??0?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAE@QB_UI@Z PROC ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >, COMDAT
; _this$ = ecx

; 2465 :         : _Mypair(_Zero_then_variadic_args_t{}) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

	push	32					; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4562 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 3

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	DWORD PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

	call	??2@YAPAXI@Z				; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4489 :         _Mypair._Myval2._Mysize = _New_size;

	mov	DWORD PTR [esi+16], 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 79   :         return ::operator new(_Bytes);

	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4490 :         _Mypair._Myval2._Myres  = _New_capacity;

	mov	DWORD PTR [esi+20], 7

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR ??_C@_2BI@CPCKAEFF@?$AA?$AA?$AAE?$AA?$AA?$AAt?$AA?$AA?$AAh?$AA?$AA?$AAa?$AA?$AA?$AAn@
	movups	XMMWORD PTR [eax], xmm0
	mov	ecx, DWORD PTR ??_C@_2BI@CPCKAEFF@?$AA?$AA?$AAE?$AA?$AA?$AAt?$AA?$AA?$AAh?$AA?$AA?$AAa?$AA?$AA?$AAn@+16
	mov	DWORD PTR [eax+16], ecx

; 3224 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	DWORD PTR [eax+20], 0

; 4496 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

	mov	DWORD PTR [esi], eax

; 2466 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2467 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2468 :         _Tidy_init();
; 2469 :         assign(_Ptr, _Count);
; 2470 :         _Proxy._Release();
; 2471 :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	8
??0?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAE@QB_UI@Z ENDP ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Unchecked_end@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAEPA_SXZ
_TEXT	SEGMENT
?_Unchecked_end@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAEPA_SXZ PROC ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 8

; 2263 :         value_type* _Result = _Bx._Buf;

	mov	edx, ecx

; 2264 :         if (_Large_string_engaged()) {

	jb	SHORT $LN4@Unchecked_

; 2265 :             _Result = _Unfancy(_Bx._Ptr);

	mov	edx, DWORD PTR [ecx]
$LN4@Unchecked_:

; 3715 :         return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;

	mov	eax, DWORD PTR [ecx+16]
	lea	eax, DWORD PTR [edx+eax*2]

; 3716 :     }

	ret	0
?_Unchecked_end@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAEPA_SXZ ENDP ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Unchecked_begin@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAEPA_SXZ
_TEXT	SEGMENT
?_Unchecked_begin@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAEPA_SXZ PROC ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 8

; 2264 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@Unchecked_

; 3707 :         return _Mypair._Myval2._Myptr();

	mov	eax, DWORD PTR [ecx]

; 3708 :     }

	ret	0
$LN8@Unchecked_:

; 3707 :         return _Mypair._Myval2._Myptr();

	mov	eax, ecx

; 3708 :     }

	ret	0
?_Unchecked_begin@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAEPA_SXZ ENDP ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??1?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAE@XZ PROC ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::~basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >, COMDAT
; _this$ = ecx

; 2968 :     _CONSTEXPR20_CONTAINER ~basic_string() noexcept {

	push	esi
	mov	esi, ecx

; 2286 :         return _BUF_SIZE <= _Myres;

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 8

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN12@basic_stri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ecx*2+2]

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN22@basic_stri

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN19@basic_stri

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN22@basic_stri:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN12@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	xor	eax, eax
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 7
	mov	WORD PTR [esi], ax
	pop	esi

; 2976 :     }

	ret	0
$LN19@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN27@basic_stri:
	int	3
??1?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAE@XZ ENDP ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::~basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAE@QB_SI@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
??0?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAE@QB_SI@Z PROC ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >, COMDAT
; _this$ = ecx

; 2465 :         : _Mypair(_Zero_then_variadic_args_t{}) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	push	10					; 0000000aH
	push	OFFSET ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@
	push	esi

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [esi], 0

; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 7

; 3214 :             _Mypair._Myval2._Mysize = _Count;

	mov	DWORD PTR [esi+16], 5

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	call	_memmove
	add	esp, 12					; 0000000cH

; 3216 :             _Traits::assign(_Old_ptr[_Count], _Elem());

	xor	eax, eax
	mov	WORD PTR [esi+10], ax

; 2466 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2467 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2468 :         _Tidy_init();
; 2469 :         assign(_Ptr, _Count);
; 2470 :         _Proxy._Release();
; 2471 :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	8
??0?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAE@QB_SI@Z ENDP ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 2968 :     _CONSTEXPR20_CONTAINER ~basic_string() noexcept {

	push	esi
	mov	esi, ecx

; 2286 :         return _BUF_SIZE <= _Myres;

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 8

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN12@basic_stri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ecx*2+2]

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN22@basic_stri

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN19@basic_stri

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN22@basic_stri:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN12@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	xor	eax, eax
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 7
	mov	WORD PTR [esi], ax
	pop	esi

; 2976 :     }

	ret	0
$LN19@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN27@basic_stri:
	int	3
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 2571 :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

	push	ebp
	mov	ebp, esp

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	eax, DWORD PTR __Right$[ebp]

; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	xor	edx, edx

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [ecx], 0

; 2322 :     size_type _Mysize = 0; // current length of string

	mov	DWORD PTR [ecx+16], 0

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

	mov	DWORD PTR [ecx+20], 0

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 4562 :         _My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 7

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [eax], dx

; 2572 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2573 :         _Take_contents(_Right);
; 2574 :     }

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_WI@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 2465 :         : _Mypair(_Zero_then_variadic_args_t{}) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	push	10					; 0000000aH
	push	OFFSET ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@
	push	esi

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [esi], 0

; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 7

; 3214 :             _Mypair._Myval2._Mysize = _Count;

	mov	DWORD PTR [esi+16], 5

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	call	_memmove
	add	esp, 12					; 0000000cH

; 3216 :             _Traits::assign(_Old_ptr[_Count], _Elem());

	xor	eax, eax
	mov	WORD PTR [esi+10], ax

; 2466 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2467 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2468 :         _Tidy_init();
; 2469 :         assign(_Ptr, _Count);
; 2470 :         _Proxy._Release();
; 2471 :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	8
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2273 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@c_str

; 3888 :         return _Mypair._Myval2._Myptr();

	mov	eax, DWORD PTR [ecx]

; 3889 :     }

	ret	0
$LN8@c_str:

; 3888 :         return _Mypair._Myval2._Myptr();

	mov	eax, ecx

; 3889 :     }

	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
$T5 = -4						; size = 1
__Ptr$dead$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 3140 :     _CONSTEXPR20_CONTAINER basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	edx, ecx
	push	esi

; 3121 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	ecx, DWORD PTR [edx+20]
	mov	eax, ecx
	mov	esi, DWORD PTR [edx+16]
	sub	eax, esi
	cmp	eax, 2
	jb	SHORT $LN6@append

; 3122 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [esi+2]
	mov	DWORD PTR [edx+16], eax

; 2263 :         value_type* _Result = _Bx._Buf;

	mov	eax, edx

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	ecx, 16					; 00000010H

; 2264 :         if (_Large_string_engaged()) {

	jb	SHORT $LN9@append

; 2265 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [edx]
$LN9@append:

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	cx, WORD PTR ??_C@_02PLJDPFIO@00@
	mov	WORD PTR [eax+esi], cx

; 3125 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [eax+esi+2], 0

; 3141 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	eax, edx
	pop	esi

; 3142 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN6@append:

; 3129 :         return _Reallocate_grow_by(

	push	2
	push	ecx
	mov	BYTE PTR $T5[ebp], 0
	mov	ecx, edx
	push	DWORD PTR $T5[ebp]
	push	2
	call	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
	pop	esi

; 3142 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2968 :     _CONSTEXPR20_CONTAINER ~basic_string() noexcept {

	push	esi
	mov	esi, ecx

; 2286 :         return _BUF_SIZE <= _Myres;

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN12@basic_stri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN22@basic_stri

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN19@basic_stri

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN22@basic_stri:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN12@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4599 :             _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 4600 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 4601 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [esi], 0
	pop	esi

; 2976 :     }

	ret	0
$LN19@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN27@basic_stri:
	int	3
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2571 :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

	push	ebp
	mov	ebp, esp

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	eax, DWORD PTR __Right$[ebp]

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [ecx], 0

; 2322 :     size_type _Mysize = 0; // current length of string

	mov	DWORD PTR [ecx+16], 0

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

	mov	DWORD PTR [ecx+20], 0

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 4562 :         _My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [eax], 0

; 2572 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2573 :         _Take_contents(_Right);
; 2574 :     }

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2483 :     _CONSTEXPR20_CONTAINER basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

	push	esi
	mov	esi, ecx

; 3230 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	push	3
	push	OFFSET ??_C@_03LFPOMIKD@chs@

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [esi], 0

; 4562 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 3230 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2484 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2485 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2486 :         _Tidy_init();
; 2487 :         assign(_Ptr);
; 2488 :         _Proxy._Release();
; 2489 :     }

	mov	eax, esi
	pop	esi
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2465 :         : _Mypair(_Zero_then_variadic_args_t{}) {

	push	esi
	mov	esi, ecx

; 2466 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2467 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2468 :         _Tidy_init();
; 2469 :         assign(_Ptr, _Count);

	push	5
	push	OFFSET ??_C@_05FBADLLFO@Ethan@

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [esi], 0

; 4562 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2466 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2467 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2468 :         _Tidy_init();
; 2469 :         assign(_Ptr, _Count);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2470 :         _Proxy._Release();
; 2471 :     }

	mov	eax, esi
	pop	esi
	ret	8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@_U@std@@V?$_String_val@U?$_Simple_types@_U@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@V?$allocator@_U@std@@V?$_String_val@U?$_Simple_types@_U@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char32_t>,std::_String_val<std::_Simple_types<char32_t> >,1>::~_Compressed_pair<std::allocator<char32_t>,std::_String_val<std::_Simple_types<char32_t> >,1>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Compressed_pair@V?$allocator@_U@std@@V?$_String_val@U?$_Simple_types@_U@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char32_t>,std::_String_val<std::_Simple_types<char32_t> >,1>::~_Compressed_pair<std::allocator<char32_t>,std::_String_val<std::_Simple_types<char32_t> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@_S@std@@V?$_String_val@U?$_Simple_types@_S@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@V?$allocator@_S@std@@V?$_String_val@U?$_Simple_types@_S@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char16_t>,std::_String_val<std::_Simple_types<char16_t> >,1>::~_Compressed_pair<std::allocator<char16_t>,std::_String_val<std::_Simple_types<char16_t> >,1>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Compressed_pair@V?$allocator@_S@std@@V?$_String_val@U?$_Simple_types@_S@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char16_t>,std::_String_val<std::_Simple_types<char16_t> >,1>::~_Compressed_pair<std::allocator<char16_t>,std::_String_val<std::_Simple_types<char16_t> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@_U@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@_U@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char32_t> >::~_String_val<std::_Simple_types<char32_t> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_val@U?$_Simple_types@_U@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char32_t> >::~_String_val<std::_Simple_types<char32_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@_S@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@_S@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char16_t> >::~_String_val<std::_Simple_types<char16_t> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_val@U?$_Simple_types@_S@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char16_t> >::~_String_val<std::_Simple_types<char16_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEXXZ PROC ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4582 :     _CONSTEXPR20_CONTAINER void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

	push	esi
	mov	esi, ecx

; 2286 :         return _BUF_SIZE <= _Myres;

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 4

; 4583 :         _Mypair._Myval2._Orphan_all();
; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN10@Tidy_deall
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ecx*4+4]

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN20@Tidy_deall

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN17@Tidy_deall

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN20@Tidy_deall:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4599 :             _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 4600 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 3

; 4601 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	DWORD PTR [esi], 0
	pop	esi

; 4604 :     }

	ret	0
$LN17@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN24@Tidy_deall:
	int	3
?_Tidy_deallocate@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEXXZ ENDP ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy_init@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEXXZ PROC ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4561 :         auto& _My_data   = _Mypair._Myval2;
; 4562 :         _My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 3

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	DWORD PTR [ecx], 0

; 4579 :         }
; 4580 :     }

	ret	0
?_Tidy_init@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEXXZ ENDP ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAEAAV12@QB_UI@Z
_TEXT	SEGMENT
$T14 = -4						; size = 4
__Ptr$dead$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?assign@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAEAAV12@QB_UI@Z PROC ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::assign, COMDAT
; _this$ = ecx

; 3210 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 3211 :         // assign [_Ptr, _Ptr + _Count)
; 3212 :         if (_Count <= _Mypair._Myval2._Myres) {

	mov	ebx, DWORD PTR [edi+20]
	cmp	ebx, 5
	jb	SHORT $LN12@assign

; 2265 :             _Result = _Unfancy(_Bx._Ptr);

	mov	esi, DWORD PTR [edi]

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	push	20					; 00000014H
	push	OFFSET ??_C@_2BI@CPCKAEFF@?$AA?$AA?$AAE?$AA?$AA?$AAt?$AA?$AA?$AAh?$AA?$AA?$AAa?$AA?$AA?$AAn@
	push	esi

; 3213 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3214 :             _Mypair._Myval2._Mysize = _Count;

	mov	DWORD PTR [edi+16], 5

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	call	_memmove
	add	esp, 12					; 0000000cH

; 3215 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3216 :             _Traits::assign(_Old_ptr[_Count], _Elem());

	mov	DWORD PTR [esi+20], 0

; 3227 :     }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN12@assign:

; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	ecx, ebx
	mov	eax, 1073741822				; 3ffffffeH
	shr	ecx, 1
	sub	eax, ecx
	cmp	ebx, eax
	jbe	SHORT $LN20@assign

; 4460 :             return _Max;

	mov	DWORD PTR $T14[ebp], 1073741822		; 3ffffffeH
	mov	eax, -4					; fffffffcH
	jmp	SHORT $LN73@assign
$LN20@assign:

; 4461 :         }
; 4462 : 
; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [ecx+ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 43   :     return _Left < _Right ? _Right : _Left;

	mov	esi, 7
	cmp	eax, esi
	cmova	esi, eax
	mov	DWORD PTR $T14[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4481 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [esi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 60   :         if (_Count > _Max_possible) {

	cmp	eax, 1073741823				; 3fffffffH
	ja	$LN74@assign

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	shl	eax, 2

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN31@assign
$LN73@assign:

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	ecx, DWORD PTR [eax+35]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	ecx, eax
	jbe	$LN74@assign

; 79   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	$LN66@assign

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	esi, DWORD PTR [eax+35]
	and	esi, -32				; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [esi-4], eax

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN30@assign
$LN31@assign:

; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

	test	eax, eax
	je	SHORT $LN32@assign

; 79   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 235  :         return _Traits::_Allocate(_Bytes);

	mov	esi, eax
	jmp	SHORT $LN30@assign
$LN32@assign:

; 236  :     }
; 237  : 
; 238  :     return nullptr;

	xor	esi, esi
$LN30@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4490 :         _Mypair._Myval2._Myres  = _New_capacity;

	mov	eax, DWORD PTR $T14[ebp]
	mov	DWORD PTR [edi+16], 5
	mov	DWORD PTR [edi+20], eax

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR ??_C@_2BI@CPCKAEFF@?$AA?$AA?$AAE?$AA?$AA?$AAt?$AA?$AA?$AAh?$AA?$AA?$AAa?$AA?$AA?$AAn@
	movups	XMMWORD PTR [esi], xmm0
	mov	eax, DWORD PTR ??_C@_2BI@CPCKAEFF@?$AA?$AA?$AAE?$AA?$AA?$AAt?$AA?$AA?$AAh?$AA?$AA?$AAa?$AA?$AA?$AAn@+16
	mov	DWORD PTR [esi+16], eax

; 3224 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	DWORD PTR [esi+20], 0

; 4492 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	ebx, 4
	jb	SHORT $LN13@assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [edi]
	lea	ebx, DWORD PTR [ebx*4+4]

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ebx, 4096				; 00001000H
	jb	SHORT $LN69@assign

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [eax-4]
	add	ebx, 35					; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, ecx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN66@assign

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, ecx
$LN69@assign:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	ebx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN13@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3220 :         return _Reallocate_for(

	mov	DWORD PTR [edi], esi

; 3227 :     }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN66@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN74@assign:

; 131  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN75@assign:
	int	3
?assign@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAEAAV12@QB_UI@Z ENDP ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??R<lambda_02ffc73a80c062ba6e5e6c9f53d514cc>@@QBE@QA_UIQB_U@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
__Ptr$dead$ = 16					; size = 4
??R<lambda_02ffc73a80c062ba6e5e6c9f53d514cc>@@QBE@QA_UIQB_U@Z PROC ; <lambda_02ffc73a80c062ba6e5e6c9f53d514cc>::operator(), COMDAT
; _this$dead$ = ecx

; 3222 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {

	push	ebp
	mov	ebp, esp

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	ecx, DWORD PTR __New_ptr$[ebp]
	movups	xmm0, XMMWORD PTR ??_C@_2BI@CPCKAEFF@?$AA?$AA?$AAE?$AA?$AA?$AAt?$AA?$AA?$AAh?$AA?$AA?$AAa?$AA?$AA?$AAn@
	movups	XMMWORD PTR [ecx], xmm0
	mov	eax, DWORD PTR ??_C@_2BI@CPCKAEFF@?$AA?$AA?$AAE?$AA?$AA?$AAt?$AA?$AA?$AAh?$AA?$AA?$AAa?$AA?$AA?$AAn@+16
	mov	DWORD PTR [ecx+16], eax

; 3223 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3224 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	DWORD PTR [ecx+20], 0

; 3225 :             },

	pop	ebp
	ret	12					; 0000000cH
??R<lambda_02ffc73a80c062ba6e5e6c9f53d514cc>@@QBE@QA_UIQB_U@Z ENDP ; <lambda_02ffc73a80c062ba6e5e6c9f53d514cc>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@_U@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@_U@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char32_t> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 2315 :         _CONSTEXPR20_CONTAINER ~_Bxty() noexcept {} // user-provided, for fancy pointers

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@_U@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char32_t> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_U@std@@@std@@QAEPA_UXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@_U@std@@@std@@QAEPA_UXZ PROC ; std::_String_val<std::_Simple_types<char32_t> >::_Myptr, COMDAT
; _this$ = ecx

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 4

; 2263 :         value_type* _Result = _Bx._Buf;
; 2264 :         if (_Large_string_engaged()) {

	jb	SHORT $LN6@Myptr

; 2265 :             _Result = _Unfancy(_Bx._Ptr);
; 2266 :         }
; 2267 : 
; 2268 :         return _Result;

	mov	eax, DWORD PTR [ecx]

; 2269 :     }

	ret	0
$LN6@Myptr:

; 2265 :             _Result = _Unfancy(_Bx._Ptr);
; 2266 :         }
; 2267 : 
; 2268 :         return _Result;

	mov	eax, ecx

; 2269 :     }

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@_U@std@@@std@@QAEPA_UXZ ENDP ; std::_String_val<std::_Simple_types<char32_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEXXZ PROC ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4582 :     _CONSTEXPR20_CONTAINER void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

	push	esi
	mov	esi, ecx

; 2286 :         return _BUF_SIZE <= _Myres;

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 8

; 4583 :         _Mypair._Myval2._Orphan_all();
; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN10@Tidy_deall
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ecx*2+2]

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN20@Tidy_deall

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN17@Tidy_deall

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN20@Tidy_deall:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	xor	eax, eax
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 7
	mov	WORD PTR [esi], ax
	pop	esi

; 4604 :     }

	ret	0
$LN17@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN24@Tidy_deall:
	int	3
?_Tidy_deallocate@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEXXZ ENDP ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy_init@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEXXZ PROC ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4561 :         auto& _My_data   = _Mypair._Myval2;
; 4562 :         _My_data._Mysize = 0;
; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;
; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	xor	eax, eax
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 7
	mov	WORD PTR [ecx], ax

; 4579 :         }
; 4580 :     }

	ret	0
?_Tidy_init@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEXXZ ENDP ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAEAAV12@QB_SI@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?assign@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAEAAV12@QB_SI@Z PROC ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::assign, COMDAT
; _this$ = ecx

; 3210 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 3211 :         // assign [_Ptr, _Ptr + _Count)
; 3212 :         if (_Count <= _Mypair._Myval2._Myres) {

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 5
	jb	SHORT $LN12@assign

; 2263 :         value_type* _Result = _Bx._Buf;

	mov	edi, esi

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	ecx, 8

; 2264 :         if (_Large_string_engaged()) {

	jb	SHORT $LN5@assign

; 2265 :             _Result = _Unfancy(_Bx._Ptr);

	mov	edi, DWORD PTR [esi]
$LN5@assign:

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	push	10					; 0000000aH
	push	OFFSET ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@
	push	edi

; 3213 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3214 :             _Mypair._Myval2._Mysize = _Count;

	mov	DWORD PTR [esi+16], 5

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	call	_memmove
	add	esp, 12					; 0000000cH

; 3215 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3216 :             _Traits::assign(_Old_ptr[_Count], _Elem());

	xor	eax, eax
	mov	WORD PTR [edi+10], ax

; 3227 :     }

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	ret	8
$LN12@assign:

; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	edx, ecx
	mov	eax, 2147483646				; 7ffffffeH
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN20@assign

; 4460 :             return _Max;

	mov	edi, 2147483646				; 7ffffffeH
	mov	eax, -2					; fffffffeH
	jmp	SHORT $LN73@assign
$LN20@assign:

; 4461 :         }
; 4462 : 
; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 43   :     return _Left < _Right ? _Right : _Left;

	mov	edi, 7
	cmp	eax, edi
	cmova	edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4481 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [edi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 60   :         if (_Count > _Max_possible) {

	cmp	eax, 2147483647				; 7fffffffH
	ja	$LN74@assign

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	add	eax, eax

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN31@assign
$LN73@assign:

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	ecx, DWORD PTR [eax+35]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	ecx, eax
	jbe	$LN74@assign

; 79   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	SHORT $LN66@assign

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	edx, DWORD PTR [eax+35]
	and	edx, -32				; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [edx-4], eax

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	DWORD PTR [esi+20], edi
	mov	DWORD PTR [esi+16], 5
	movq	xmm0, QWORD PTR ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@
	movq	QWORD PTR [edx], xmm0
	mov	ax, WORD PTR ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@+8
	mov	WORD PTR [edx+8], ax
	xor	eax, eax
	mov	WORD PTR [edx+10], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3227 :     }

	mov	eax, esi
	pop	edi
	mov	DWORD PTR [esi], edx
	pop	esi
	pop	ebp
	ret	8
$LN66@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN31@assign:

; 234  :     if (_Bytes != 0) {

	test	eax, eax
	je	SHORT $LN32@assign

; 79   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new

; 235  :         return _Traits::_Allocate(_Bytes);

	mov	edx, eax
	mov	DWORD PTR [esi+20], edi
	mov	DWORD PTR [esi+16], 5

; 79   :         return ::operator new(_Bytes);

	add	esp, 4

; 235  :         return _Traits::_Allocate(_Bytes);

	movq	xmm0, QWORD PTR ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@
	xor	eax, eax
	movq	QWORD PTR [edx], xmm0
	mov	cx, WORD PTR ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@+8
	mov	WORD PTR [edx+8], cx
	mov	WORD PTR [edx+10], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3227 :     }

	mov	eax, esi
	pop	edi
	mov	DWORD PTR [esi], edx
	pop	esi
	pop	ebp
	ret	8
$LN32@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :     return nullptr;

	mov	DWORD PTR [esi+20], edi
	xor	ecx, ecx
	mov	DWORD PTR [esi+16], 5
	xor	edx, edx
	movq	xmm0, QWORD PTR ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@
	pop	edi
	movq	QWORD PTR [ecx], xmm0
	mov	ax, WORD PTR ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@+8
	mov	WORD PTR [ecx+8], ax
	xor	eax, eax
	mov	WORD PTR ds:10, ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3227 :     }

	mov	eax, esi
	mov	DWORD PTR [esi], edx
	pop	esi
	pop	ebp
	ret	8
$LN74@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 131  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN75@assign:
	int	3
?assign@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAEAAV12@QB_SI@Z ENDP ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??R<lambda_493290ea8cd8fcd66ff9f3cecf244fbc>@@QBE@QA_SIQB_S@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
__Ptr$dead$ = 16					; size = 4
??R<lambda_493290ea8cd8fcd66ff9f3cecf244fbc>@@QBE@QA_SIQB_S@Z PROC ; <lambda_493290ea8cd8fcd66ff9f3cecf244fbc>::operator(), COMDAT
; _this$dead$ = ecx

; 3222 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {

	push	ebp
	mov	ebp, esp

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	ecx, DWORD PTR __New_ptr$[ebp]
	movq	xmm0, QWORD PTR ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@
	movq	QWORD PTR [ecx], xmm0
	mov	ax, WORD PTR ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@+8
	mov	WORD PTR [ecx+8], ax

; 3223 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3224 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	xor	eax, eax
	mov	WORD PTR [ecx+10], ax

; 3225 :             },

	pop	ebp
	ret	12					; 0000000cH
??R<lambda_493290ea8cd8fcd66ff9f3cecf244fbc>@@QBE@QA_SIQB_S@Z ENDP ; <lambda_493290ea8cd8fcd66ff9f3cecf244fbc>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@_S@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@_S@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char16_t> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 2315 :         _CONSTEXPR20_CONTAINER ~_Bxty() noexcept {} // user-provided, for fancy pointers

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@_S@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char16_t> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_S@std@@@std@@QAEPA_SXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@_S@std@@@std@@QAEPA_SXZ PROC ; std::_String_val<std::_Simple_types<char16_t> >::_Myptr, COMDAT
; _this$ = ecx

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 8

; 2263 :         value_type* _Result = _Bx._Buf;
; 2264 :         if (_Large_string_engaged()) {

	jb	SHORT $LN6@Myptr

; 2265 :             _Result = _Unfancy(_Bx._Ptr);
; 2266 :         }
; 2267 : 
; 2268 :         return _Result;

	mov	eax, DWORD PTR [ecx]

; 2269 :     }

	ret	0
$LN6@Myptr:

; 2265 :             _Result = _Unfancy(_Bx._Ptr);
; 2266 :         }
; 2267 : 
; 2268 :         return _Result;

	mov	eax, ecx

; 2269 :     }

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@_S@std@@@std@@QAEPA_SXZ ENDP ; std::_String_val<std::_Simple_types<char16_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV?$allocator@_W@2@XZ
_TEXT	SEGMENT
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV?$allocator@_W@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal, COMDAT
; _this$ = ecx

; 4617 :         return _Mypair._Get_first();

	mov	eax, ecx

; 4618 :     }

	ret	0
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV?$allocator@_W@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4582 :     _CONSTEXPR20_CONTAINER void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

	push	esi
	mov	esi, ecx

; 2286 :         return _BUF_SIZE <= _Myres;

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 8

; 4583 :         _Mypair._Myval2._Orphan_all();
; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN10@Tidy_deall
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ecx*2+2]

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN20@Tidy_deall

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN17@Tidy_deall

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN20@Tidy_deall:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	xor	eax, eax
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 7
	mov	WORD PTR [esi], ax
	pop	esi

; 4604 :     }

	ret	0
$LN17@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN24@Tidy_deall:
	int	3
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4561 :         auto& _My_data   = _Mypair._Myval2;
; 4562 :         _My_data._Mysize = 0;
; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;
; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	xor	eax, eax
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 7
	mov	WORD PTR [ecx], ax

; 4579 :         }
; 4580 :     }

	ret	0
?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size, COMDAT
; _this$ = ecx

; 3906 :         return _Mypair._Myval2._Mysize;

	mov	eax, DWORD PTR [ecx+16]

; 3907 :     }

	ret	0
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 3210 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 3211 :         // assign [_Ptr, _Ptr + _Count)
; 3212 :         if (_Count <= _Mypair._Myval2._Myres) {

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 5
	jb	SHORT $LN12@assign

; 2263 :         value_type* _Result = _Bx._Buf;

	mov	edi, esi

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	ecx, 8

; 2264 :         if (_Large_string_engaged()) {

	jb	SHORT $LN5@assign

; 2265 :             _Result = _Unfancy(_Bx._Ptr);

	mov	edi, DWORD PTR [esi]
$LN5@assign:

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	push	10					; 0000000aH
	push	OFFSET ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@
	push	edi

; 3213 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3214 :             _Mypair._Myval2._Mysize = _Count;

	mov	DWORD PTR [esi+16], 5

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	call	_memmove
	add	esp, 12					; 0000000cH

; 3215 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3216 :             _Traits::assign(_Old_ptr[_Count], _Elem());

	xor	eax, eax
	mov	WORD PTR [edi+10], ax

; 3227 :     }

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	ret	8
$LN12@assign:

; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	edx, ecx
	mov	eax, 2147483646				; 7ffffffeH
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN20@assign

; 4460 :             return _Max;

	mov	edi, 2147483646				; 7ffffffeH
	jmp	SHORT $LN18@assign
$LN20@assign:

; 4461 :         }
; 4462 : 
; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 43   :     return _Left < _Right ? _Right : _Left;

	mov	edi, 7
	cmp	eax, edi
	cmova	edi, eax
$LN18@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4481 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	xor	ecx, ecx
	mov	eax, edi
	add	eax, 1
	setb	cl
	neg	ecx
	or	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 60   :         if (_Count > _Max_possible) {

	cmp	ecx, 2147483647				; 7fffffffH
	ja	$LN73@assign

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	add	ecx, ecx

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN31@assign

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	eax, ecx
	jbe	$LN73@assign

; 79   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	SHORT $LN66@assign

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	edx, DWORD PTR [eax+35]
	and	edx, -32				; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [edx-4], eax

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	DWORD PTR [esi+20], edi
	mov	DWORD PTR [esi+16], 5
	movq	xmm0, QWORD PTR ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@
	movq	QWORD PTR [edx], xmm0
	mov	ax, WORD PTR ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@+8
	mov	WORD PTR [edx+8], ax
	xor	eax, eax
	mov	WORD PTR [edx+10], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3227 :     }

	mov	eax, esi
	pop	edi
	mov	DWORD PTR [esi], edx
	pop	esi
	pop	ebp
	ret	8
$LN66@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN31@assign:

; 234  :     if (_Bytes != 0) {

	test	ecx, ecx
	je	SHORT $LN32@assign

; 79   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new

; 235  :         return _Traits::_Allocate(_Bytes);

	mov	edx, eax
	mov	DWORD PTR [esi+20], edi
	mov	DWORD PTR [esi+16], 5

; 79   :         return ::operator new(_Bytes);

	add	esp, 4

; 235  :         return _Traits::_Allocate(_Bytes);

	movq	xmm0, QWORD PTR ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@
	xor	eax, eax
	movq	QWORD PTR [edx], xmm0
	mov	cx, WORD PTR ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@+8
	mov	WORD PTR [edx+8], cx
	mov	WORD PTR [edx+10], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3227 :     }

	mov	eax, esi
	pop	edi
	mov	DWORD PTR [esi], edx
	pop	esi
	pop	ebp
	ret	8
$LN32@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :     return nullptr;

	mov	DWORD PTR [esi+20], edi
	xor	ecx, ecx
	mov	DWORD PTR [esi+16], 5
	xor	edx, edx
	movq	xmm0, QWORD PTR ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@
	pop	edi
	movq	QWORD PTR [ecx], xmm0
	mov	ax, WORD PTR ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@+8
	mov	WORD PTR [ecx+8], ax
	xor	eax, eax
	mov	WORD PTR ds:10, ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3227 :     }

	mov	eax, esi
	mov	DWORD PTR [esi], edx
	pop	esi
	pop	ebp
	ret	8
$LN73@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 131  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN74@assign:
	int	3
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??R<lambda_03628ca18370b1f44a99b655e704819b>@@QBE@QA_WIQB_W@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
__Ptr$dead$ = 16					; size = 4
??R<lambda_03628ca18370b1f44a99b655e704819b>@@QBE@QA_WIQB_W@Z PROC ; <lambda_03628ca18370b1f44a99b655e704819b>::operator(), COMDAT
; _this$dead$ = ecx

; 3222 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {

	push	ebp
	mov	ebp, esp

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	ecx, DWORD PTR __New_ptr$[ebp]
	movq	xmm0, QWORD PTR ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@
	movq	QWORD PTR [ecx], xmm0
	mov	ax, WORD PTR ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@+8
	mov	WORD PTR [ecx+8], ax

; 3223 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3224 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	xor	eax, eax
	mov	WORD PTR [ecx+10], ax

; 3225 :             },

	pop	ebp
	ret	12					; 0000000cH
??R<lambda_03628ca18370b1f44a99b655e704819b>@@QBE@QA_WIQB_W@Z ENDP ; <lambda_03628ca18370b1f44a99b655e704819b>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Take_contents, COMDAT
; _this$ = ecx

; 2838 :     _CONSTEXPR20_CONTAINER void _Take_contents(basic_string& _Right) noexcept {

	push	ebp
	mov	ebp, esp

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	eax, DWORD PTR __Right$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	xor	ecx, ecx
	mov	DWORD PTR [eax+16], 0
	mov	DWORD PTR [eax+20], 7
	mov	WORD PTR [eax], cx

; 2839 :         // assign by stealing _Right's buffer
; 2840 :         // pre: this != &_Right
; 2841 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2842 :         // pre: *this owns no memory, iterators orphaned
; 2843 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2844 :         auto& _My_data    = _Mypair._Myval2;
; 2845 :         auto& _Right_data = _Right._Mypair._Myval2;
; 2846 : 
; 2847 :         if constexpr (_Can_memcpy_val) {
; 2848 : #ifdef __cpp_lib_constexpr_string
; 2849 :             if (!_STD is_constant_evaluated())
; 2850 : #endif // __cpp_lib_constexpr_string
; 2851 :             {
; 2852 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2853 :                 if (_Right_data._Large_string_engaged()) {
; 2854 :                     // take ownership of _Right's iterators along with its buffer
; 2855 :                     _Swap_proxy_and_iterators(_Right);
; 2856 :                 } else {
; 2857 :                     _Right_data._Orphan_all();
; 2858 :                 }
; 2859 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2860 : 
; 2861 :                 _Memcpy_val_from(_Right);
; 2862 :                 _Right._Tidy_init();
; 2863 :                 return;
; 2864 :             }
; 2865 :         }
; 2866 : 
; 2867 :         if (_Right_data._Large_string_engaged()) { // steal buffer
; 2868 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
; 2869 :             _Right_data._Bx._Ptr = nullptr;
; 2870 :             _Swap_proxy_and_iterators(_Right);
; 2871 :         } else { // copy small string buffer
; 2872 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
; 2873 :             _Right_data._Orphan_all();
; 2874 :         }
; 2875 : 
; 2876 :         _My_data._Mysize = _Right_data._Mysize;
; 2877 :         _My_data._Myres  = _Right_data._Myres;
; 2878 :         _Right._Tidy_init();
; 2879 :     }

	pop	ebp
	ret	4
?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 2315 :         _CONSTEXPR20_CONTAINER ~_Bxty() noexcept {} // user-provided, for fancy pointers

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 8

; 2272 :         const value_type* _Result = _Bx._Buf;
; 2273 :         if (_Large_string_engaged()) {

	jb	SHORT $LN6@Myptr

; 2274 :             _Result = _Unfancy(_Bx._Ptr);
; 2275 :         }
; 2276 : 
; 2277 :         return _Result;

	mov	eax, DWORD PTR [ecx]

; 2278 :     }

	ret	0
$LN6@Myptr:

; 2274 :             _Result = _Unfancy(_Bx._Ptr);
; 2275 :         }
; 2276 : 
; 2277 :         return _Result;

	mov	eax, ecx

; 2278 :     }

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 8

; 2263 :         value_type* _Result = _Bx._Buf;
; 2264 :         if (_Large_string_engaged()) {

	jb	SHORT $LN6@Myptr

; 2265 :             _Result = _Unfancy(_Bx._Ptr);
; 2266 :         }
; 2267 : 
; 2268 :         return _Result;

	mov	eax, DWORD PTR [ecx]

; 2269 :     }

	ret	0
$LN6@Myptr:

; 2265 :             _Result = _Unfancy(_Bx._Ptr);
; 2266 :         }
; 2267 : 
; 2268 :         return _Result;

	mov	eax, ecx

; 2269 :     }

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 4621 :         return _Mypair._Get_first();

	mov	eax, ecx

; 4622 :     }

	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 4617 :         return _Mypair._Get_first();

	mov	eax, ecx

; 4618 :     }

	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4582 :     _CONSTEXPR20_CONTAINER void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

	push	esi
	mov	esi, ecx

; 2286 :         return _BUF_SIZE <= _Myres;

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 4583 :         _Mypair._Myval2._Orphan_all();
; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN10@Tidy_deall
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN20@Tidy_deall

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN17@Tidy_deall

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN20@Tidy_deall:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4599 :             _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 4600 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 4601 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [esi], 0
	pop	esi

; 4604 :     }

	ret	0
$LN17@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN24@Tidy_deall:
	int	3
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4561 :         auto& _My_data   = _Mypair._Myval2;
; 4562 :         _My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 4579 :         }
; 4580 :     }

	ret	0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 3906 :         return _Mypair._Myval2._Mysize;

	mov	eax, DWORD PTR [ecx+16]

; 3907 :     }

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3230 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	push	3
	push	OFFSET ??_C@_03LFPOMIKD@chs@
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 3231 :     }

	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Old$1$ = -12						; size = 4
__Ptr$GSCopy$1$ = -8					; size = 4
$T13 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3210 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR __Ptr$GSCopy$1$[ebp], eax
	push	edi
	mov	edi, DWORD PTR __Count$[ebp]

; 3211 :         // assign [_Ptr, _Ptr + _Count)
; 3212 :         if (_Count <= _Mypair._Myval2._Myres) {

	mov	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR __Old$1$[ebp], ecx
	cmp	edi, ecx
	ja	SHORT $LN2@assign

; 2263 :         value_type* _Result = _Bx._Buf;

	mov	ebx, esi

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	ecx, 16					; 00000010H

; 2264 :         if (_Large_string_engaged()) {

	jb	SHORT $LN5@assign

; 2265 :             _Result = _Unfancy(_Bx._Ptr);

	mov	ebx, DWORD PTR [esi]
$LN5@assign:

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	push	edi
	push	eax
	push	ebx

; 3213 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3214 :             _Mypair._Myval2._Mysize = _Count;

	mov	DWORD PTR [esi+16], edi

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	call	_memmove
	add	esp, 12					; 0000000cH

; 3215 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3216 :             _Traits::assign(_Old_ptr[_Count], _Elem());

	mov	BYTE PTR [edi+ebx], 0

; 3227 :     }

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN2@assign:

; 4474 :         if (_New_size > max_size()) {

	cmp	edi, 2147483647				; 7fffffffH
	ja	$LN74@assign

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	ebx, edi
	or	ebx, 15					; 0000000fH
	cmp	ebx, 2147483647				; 7fffffffH

; 4455 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN19@assign

; 4456 :             return _Max;

	mov	ebx, 2147483647				; 7fffffffH
	jmp	SHORT $LN18@assign
$LN19@assign:

; 4457 :         }
; 4458 : 
; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	edx, ecx
	mov	eax, 2147483647				; 7fffffffH
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN20@assign

; 4460 :             return _Max;

	mov	ebx, 2147483647				; 7fffffffH
	jmp	SHORT $LN18@assign
$LN20@assign:

; 4461 :         }
; 4462 : 
; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 43   :     return _Left < _Right ? _Right : _Left;

	cmp	ebx, eax
	cmovb	ebx, eax
$LN18@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4481 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	xor	ecx, ecx
	mov	eax, ebx
	add	eax, 1
	setb	cl
	neg	ecx
	or	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN27@assign

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	eax, ecx
	jbe	$LN75@assign

; 79   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new

; 134  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 79   :         return ::operator new(_Bytes);

	add	esp, 4

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN63@assign

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN72@assign
$LN27@assign:

; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

	test	ecx, ecx
	je	SHORT $LN28@assign

; 79   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 235  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN72@assign
$LN28@assign:

; 236  :     }
; 237  : 
; 238  :     return nullptr;

	xor	eax, eax
$LN72@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	push	edi
	push	DWORD PTR __Ptr$GSCopy$1$[ebp]

; 4489 :         _Mypair._Myval2._Mysize = _New_size;

	mov	DWORD PTR $T13[ebp], eax

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	push	eax

; 4489 :         _Mypair._Myval2._Mysize = _New_size;

	mov	DWORD PTR [esi+16], edi

; 4490 :         _Mypair._Myval2._Myres  = _New_capacity;

	mov	DWORD PTR [esi+20], ebx

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	_memcpy

; 3224 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	ebx, DWORD PTR $T13[ebp]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	add	esp, 12					; 0000000cH

; 4492 :         if (_BUF_SIZE <= _Old_capacity) {

	mov	eax, DWORD PTR __Old$1$[ebp]

; 3224 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	BYTE PTR [edi+ebx], 0

; 4492 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN13@assign

; 4493 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

	lea	ecx, DWORD PTR [eax+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN66@assign

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN63@assign

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN66@assign:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN13@assign:
	pop	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3220 :         return _Reallocate_for(

	mov	DWORD PTR [esi], ebx

; 3227 :     }

	mov	eax, esi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN63@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN74@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4475 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
$LN75@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 131  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN70@assign:
	int	3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBE@QADIQBD@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBE@QADIQBD@Z PROC ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator(), COMDAT
; _this$dead$ = ecx

; 3222 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {

	push	ebp
	mov	ebp, esp
	push	esi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	esi, DWORD PTR __New_ptr$[ebp]

; 3222 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {

	push	edi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	edi, DWORD PTR __Count$[ebp]
	push	edi
	push	DWORD PTR __Ptr$[ebp]
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3223 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3224 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	BYTE PTR [esi+edi], 0
	pop	edi
	pop	esi

; 3225 :             },

	pop	ebp
	ret	12					; 0000000cH
??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBE@QADIQBD@Z ENDP ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
$T3 = 12						; size = 1
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 3118 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

	push	ebp
	mov	ebp, esp
	push	ebx

; 3119 :         // append [_Ptr, _Ptr + _Count)
; 3120 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3121 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	ebx, DWORD PTR __Count$[ebp]
	push	edi
	mov	edi, ecx
	mov	edx, DWORD PTR [edi+20]
	mov	eax, edx
	mov	ecx, DWORD PTR [edi+16]
	sub	eax, ecx
	cmp	ebx, eax
	ja	SHORT $LN2@append

; 3122 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [ecx+ebx]
	mov	DWORD PTR [edi+16], eax

; 2263 :         value_type* _Result = _Bx._Buf;

	mov	eax, edi

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 2264 :         if (_Large_string_engaged()) {

	jb	SHORT $LN5@append

; 2265 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [edi]
$LN5@append:
	push	esi

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	push	ebx

; 3123 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3124 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	lea	esi, DWORD PTR [eax+ecx]

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	push	OFFSET ??_C@_02PLJDPFIO@00@
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 3125 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [esi+ebx], 0

; 3126 :             return *this;

	mov	eax, edi
	pop	esi
	pop	edi

; 3130 :             _Count,
; 3131 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 3132 :                 const size_type _Count) {
; 3133 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3134 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 3136 :             },
; 3137 :             _Ptr, _Count);
; 3138 :     }

	pop	ebx
	pop	ebp
	ret	8
$LN2@append:

; 3127 :         }
; 3128 : 
; 3129 :         return _Reallocate_grow_by(

	push	ebx
	push	ecx
	mov	BYTE PTR $T3[ebp], 0
	mov	ecx, edi
	push	DWORD PTR $T3[ebp]
	push	ebx
	call	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
	pop	edi

; 3130 :             _Count,
; 3131 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 3132 :                 const size_type _Count) {
; 3133 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3134 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 3136 :             },
; 3137 :             _Ptr, _Count);
; 3138 :     }

	pop	ebx
	pop	ebp
	ret	8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ptr$dead$ = 20					; size = 4
__Count$ = 24						; size = 4
??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z PROC ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator(), COMDAT
; _this$dead$ = ecx

; 3132 :                 const size_type _Count) {

	push	ebp
	mov	ebp, esp
	push	esi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	esi, DWORD PTR __New_ptr$[ebp]

; 3132 :                 const size_type _Count) {

	push	edi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	edi, DWORD PTR __Old_size$[ebp]
	push	edi
	push	DWORD PTR __Old_ptr$[ebp]
	push	esi
	call	_memcpy

; 3133 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3134 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

	add	edi, esi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	esi, DWORD PTR __Count$[ebp]
	push	esi
	push	OFFSET ??_C@_02PLJDPFIO@00@
	push	edi
	call	_memcpy
	add	esp, 24					; 00000018H

; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [edi+esi], 0
	pop	edi
	pop	esi

; 3136 :             },

	pop	ebp
	ret	20					; 00000014H
??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z ENDP ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents, COMDAT
; _this$ = ecx

; 2838 :     _CONSTEXPR20_CONTAINER void _Take_contents(basic_string& _Right) noexcept {

	push	ebp
	mov	ebp, esp

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	eax, DWORD PTR __Right$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 4562 :         _My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [eax], 0

; 2839 :         // assign by stealing _Right's buffer
; 2840 :         // pre: this != &_Right
; 2841 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2842 :         // pre: *this owns no memory, iterators orphaned
; 2843 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2844 :         auto& _My_data    = _Mypair._Myval2;
; 2845 :         auto& _Right_data = _Right._Mypair._Myval2;
; 2846 : 
; 2847 :         if constexpr (_Can_memcpy_val) {
; 2848 : #ifdef __cpp_lib_constexpr_string
; 2849 :             if (!_STD is_constant_evaluated())
; 2850 : #endif // __cpp_lib_constexpr_string
; 2851 :             {
; 2852 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2853 :                 if (_Right_data._Large_string_engaged()) {
; 2854 :                     // take ownership of _Right's iterators along with its buffer
; 2855 :                     _Swap_proxy_and_iterators(_Right);
; 2856 :                 } else {
; 2857 :                     _Right_data._Orphan_all();
; 2858 :                 }
; 2859 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2860 : 
; 2861 :                 _Memcpy_val_from(_Right);
; 2862 :                 _Right._Tidy_init();
; 2863 :                 return;
; 2864 :             }
; 2865 :         }
; 2866 : 
; 2867 :         if (_Right_data._Large_string_engaged()) { // steal buffer
; 2868 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
; 2869 :             _Right_data._Bx._Ptr = nullptr;
; 2870 :             _Swap_proxy_and_iterators(_Right);
; 2871 :         } else { // copy small string buffer
; 2872 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
; 2873 :             _Right_data._Orphan_all();
; 2874 :         }
; 2875 : 
; 2876 :         _My_data._Mysize = _Right_data._Mysize;
; 2877 :         _My_data._Myres  = _Right_data._Myres;
; 2878 :         _Right._Tidy_init();
; 2879 :     }

	pop	ebp
	ret	4
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 2315 :         _CONSTEXPR20_CONTAINER ~_Bxty() noexcept {} // user-provided, for fancy pointers

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2272 :         const value_type* _Result = _Bx._Buf;
; 2273 :         if (_Large_string_engaged()) {

	jb	SHORT $LN6@Myptr

; 2274 :             _Result = _Unfancy(_Bx._Ptr);
; 2275 :         }
; 2276 : 
; 2277 :         return _Result;

	mov	eax, DWORD PTR [ecx]

; 2278 :     }

	ret	0
$LN6@Myptr:

; 2274 :             _Result = _Unfancy(_Bx._Ptr);
; 2275 :         }
; 2276 : 
; 2277 :         return _Result;

	mov	eax, ecx

; 2278 :     }

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2263 :         value_type* _Result = _Bx._Buf;
; 2264 :         if (_Large_string_engaged()) {

	jb	SHORT $LN6@Myptr

; 2265 :             _Result = _Unfancy(_Bx._Ptr);
; 2266 :         }
; 2267 : 
; 2268 :         return _Result;

	mov	eax, DWORD PTR [ecx]

; 2269 :     }

	ret	0
$LN6@Myptr:

; 2265 :             _Result = _Unfancy(_Bx._Ptr);
; 2266 :         }
; 2267 : 
; 2268 :         return _Result;

	mov	eax, ecx

; 2269 :     }

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ PROC		; std::_Narrow_char_traits<char,int>::eof, COMDAT

; 470  :         return static_cast<int_type>(EOF);

	or	eax, -1

; 471  :     }

	ret	0
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ENDP		; std::_Narrow_char_traits<char,int>::eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z PROC ; std::_Narrow_char_traits<char,int>::eq_int_type, COMDAT

; 461  :     _NODISCARD static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {

	push	ebp
	mov	ebp, esp

; 462  :         return _Left == _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Right$[ebp]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 463  :     }

	pop	ebp
	ret	0
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ENDP ; std::_Narrow_char_traits<char,int>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z
_TEXT	SEGMENT
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT
; __First$ = ecx

; 389  :         // find length of null-terminated string
; 390  : #if _HAS_CXX17
; 391  : #ifdef __cpp_char8_t
; 392  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 393  : #if _HAS_U8_INTRINSICS
; 394  :             return __builtin_u8strlen(_First);
; 395  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 396  :             return _Primary_char_traits::length(_First);
; 397  : #endif // _HAS_U8_INTRINSICS
; 398  :         } else
; 399  : #endif // __cpp_char8_t
; 400  :         {
; 401  :             return __builtin_strlen(_First);
; 402  :         }
; 403  : #else // _HAS_CXX17
; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	lea	edx, DWORD PTR [ecx+1]
$LL3@length:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL3@length
	sub	ecx, edx
	mov	eax, ecx

; 405  : #endif // _HAS_CXX17
; 406  :     }

	ret	0
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Char_traits<char,int>::copy, COMDAT
; __First1$ = ecx
; __First2$ = edx

; 48   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	push	esi

; 49   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 50   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 51   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 52   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^ / vvv !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 53   : #ifdef __cpp_lib_is_constant_evaluated
; 54   :         if (_STD is_constant_evaluated()) {
; 55   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap; see LWG-3085
; 56   :             for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {
; 57   :                 _First1[_Idx] = _First2[_Idx];
; 58   :             }
; 59   : 
; 60   :             return _First1;
; 61   :         }
; 62   : #endif // __cpp_lib_is_constant_evaluated
; 63   : 
; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	push	DWORD PTR __Count$[ebp]
	mov	esi, ecx
	push	edx
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH

; 65   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 66   : 
; 67   :         return _First1;

	mov	eax, esi
	pop	esi

; 68   :     }

	pop	ebp
	ret	0
?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?eof@?$_WChar_traits@_W@std@@SAGXZ
_TEXT	SEGMENT
?eof@?$_WChar_traits@_W@std@@SAGXZ PROC			; std::_WChar_traits<wchar_t>::eof, COMDAT

; 327  :         return WEOF;

	mov	eax, 65535				; 0000ffffH

; 328  :     }

	ret	0
?eof@?$_WChar_traits@_W@std@@SAGXZ ENDP			; std::_WChar_traits<wchar_t>::eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?eq_int_type@?$_WChar_traits@_W@std@@SA_NABG0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$_WChar_traits@_W@std@@SA_NABG0@Z PROC	; std::_WChar_traits<wchar_t>::eq_int_type, COMDAT

; 318  :     _NODISCARD static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {

	push	ebp
	mov	ebp, esp

; 319  :         return _Left == _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	cx, WORD PTR [eax]
	mov	eax, DWORD PTR __Right$[ebp]
	cmp	cx, WORD PTR [eax]
	sete	al

; 320  :     }

	pop	ebp
	ret	0
?eq_int_type@?$_WChar_traits@_W@std@@SA_NABG0@Z ENDP	; std::_WChar_traits<wchar_t>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?copy@?$_Char_traits@_WG@std@@SAPA_WQA_WQB_WI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?copy@?$_Char_traits@_WG@std@@SAPA_WQA_WQB_WI@Z PROC	; std::_Char_traits<wchar_t,unsigned short>::copy, COMDAT
; __First1$ = ecx
; __First2$ = edx

; 48   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp

; 49   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 50   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 51   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 52   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^ / vvv !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 53   : #ifdef __cpp_lib_is_constant_evaluated
; 54   :         if (_STD is_constant_evaluated()) {
; 55   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap; see LWG-3085
; 56   :             for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {
; 57   :                 _First1[_Idx] = _First2[_Idx];
; 58   :             }
; 59   : 
; 60   :             return _First1;
; 61   :         }
; 62   : #endif // __cpp_lib_is_constant_evaluated
; 63   : 
; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR __Count$[ebp]
	push	esi
	add	eax, eax
	mov	esi, ecx
	push	eax
	push	edx
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH

; 65   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 66   : 
; 67   :         return _First1;

	mov	eax, esi
	pop	esi

; 68   :     }

	pop	ebp
	ret	0
?copy@?$_Char_traits@_WG@std@@SAPA_WQA_WQB_WI@Z ENDP	; std::_Char_traits<wchar_t,unsigned short>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Getal@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEAAV?$allocator@_U@2@XZ
_TEXT	SEGMENT
?_Getal@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEAAV?$allocator@_U@2@XZ PROC ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Getal, COMDAT
; _this$ = ecx

; 4617 :         return _Mypair._Get_first();

	mov	eax, ecx

; 4618 :     }

	ret	0
?_Getal@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEAAV?$allocator@_U@2@XZ ENDP ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@_U@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?_Large_string_engaged@?$_String_val@U?$_Simple_types@_U@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char32_t> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 2281 : #ifdef __cpp_lib_constexpr_string
; 2282 :         if (_STD is_constant_evaluated()) {
; 2283 :             return true;
; 2284 :         }
; 2285 : #endif // __cpp_lib_constexpr_string
; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 4
	setae	al

; 2287 :     }

	ret	0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@_U@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char32_t> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@_U@std@@QAEXQA_UI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@_U@std@@QAEXQA_UI@Z PROC	; std::allocator<char32_t>::deallocate, COMDAT
; _this$dead$ = ecx

; 795  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

	push	ebp
	mov	ebp, esp

; 796  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	lea	edx, DWORD PTR [eax*4]

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 147  :     _Bytes += _Non_user_size;

	push	esi

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	esi, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	ecx, esi

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [ecx-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN12@deallocate

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	ecx, esi
	pop	esi
$LN15@deallocate:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 798  :     }

	pop	ebp
	ret	8
$LN12@deallocate:

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@deallocate:
	int	3
?deallocate@?$allocator@_U@std@@QAEXQA_UI@Z ENDP	; std::allocator<char32_t>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$max@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
??$max@I@std@@YAABIABI0@Z PROC				; std::max<unsigned int>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 42   :     // return larger of _Left and _Right
; 43   :     return _Left < _Right ? _Right : _Left;

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	cmovb	ecx, edx
	mov	eax, ecx

; 44   : }

	ret	0
??$max@I@std@@YAABIABI0@Z ENDP				; std::max<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Getal@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEAAV?$allocator@_S@2@XZ
_TEXT	SEGMENT
?_Getal@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEAAV?$allocator@_S@2@XZ PROC ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Getal, COMDAT
; _this$ = ecx

; 4617 :         return _Mypair._Get_first();

	mov	eax, ecx

; 4618 :     }

	ret	0
?_Getal@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEAAV?$allocator@_S@2@XZ ENDP ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@_S@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?_Large_string_engaged@?$_String_val@U?$_Simple_types@_S@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char16_t> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 2281 : #ifdef __cpp_lib_constexpr_string
; 2282 :         if (_STD is_constant_evaluated()) {
; 2283 :             return true;
; 2284 :         }
; 2285 : #endif // __cpp_lib_constexpr_string
; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 8
	setae	al

; 2287 :     }

	ret	0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@_S@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char16_t> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@_S@std@@QAEXQA_SI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@_S@std@@QAEXQA_SI@Z PROC	; std::allocator<char16_t>::deallocate, COMDAT
; _this$dead$ = ecx

; 795  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

	push	ebp
	mov	ebp, esp

; 796  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	lea	edx, DWORD PTR [eax+eax]

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 147  :     _Bytes += _Non_user_size;

	push	esi

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	esi, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	ecx, esi

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [ecx-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN12@deallocate

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	ecx, esi
	pop	esi
$LN15@deallocate:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 798  :     }

	pop	ebp
	ret	8
$LN12@deallocate:

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@deallocate:
	int	3
?deallocate@?$allocator@_S@std@@QAEXQA_SI@Z ENDP	; std::allocator<char16_t>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$allocator@_W@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$allocator@_W@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$allocator@_W@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEABV?$allocator@_W@2@XZ
_TEXT	SEGMENT
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEABV?$allocator@_W@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal, COMDAT
; _this$ = ecx

; 4621 :         return _Mypair._Get_first();

	mov	eax, ecx

; 4622 :     }

	ret	0
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEABV?$allocator@_W@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Swap_proxy_and_iterators, COMDAT
; _this$dead$ = ecx

; 4613 :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 4614 :     }

	ret	4
?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Memcpy_val_from@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Memcpy_val_from@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXABV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Memcpy_val_from, COMDAT
; _this$ = ecx

; 2829 :     void _Memcpy_val_from(const basic_string& _Right) noexcept {

	push	ebp
	mov	ebp, esp

; 2830 :         _STL_INTERNAL_CHECK(_Can_memcpy_val); // TRANSITION, if constexpr
; 2831 :         const auto _My_data_mem =
; 2832 :             reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 2833 :         const auto _Right_data_mem =
; 2834 :             reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	eax, DWORD PTR __Right$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 2836 :     }

	pop	ebp
	ret	4
?_Memcpy_val_from@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXABV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Memcpy_val_from
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 2281 : #ifdef __cpp_lib_constexpr_string
; 2282 :         if (_STD is_constant_evaluated()) {
; 2283 :             return true;
; 2284 :         }
; 2285 : #endif // __cpp_lib_constexpr_string
; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 8
	setae	al

; 2287 :     }

	ret	0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXQA_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@_W@std@@QAEXQA_WI@Z PROC	; std::allocator<wchar_t>::deallocate, COMDAT
; _this$dead$ = ecx

; 795  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

	push	ebp
	mov	ebp, esp

; 796  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	lea	edx, DWORD PTR [eax+eax]

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 147  :     _Bytes += _Non_user_size;

	push	esi

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	esi, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	ecx, esi

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [ecx-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN12@deallocate

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	ecx, esi
	pop	esi
$LN15@deallocate:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 798  :     }

	pop	ebp
	ret	8
$LN12@deallocate:

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@deallocate:
	int	3
?deallocate@?$allocator@_W@std@@QAEXQA_WI@Z ENDP	; std::allocator<wchar_t>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators, COMDAT
; _this$dead$ = ecx

; 4613 :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 4614 :     }

	ret	4
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$dead$ = ecx

; 3910 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());
; 3911 :         const size_type _Storage_max = // can always store small string
; 3912 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 3913 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	eax, 2147483647				; 7fffffffH

; 3914 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3915 :         );
; 3916 :     }

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from, COMDAT
; _this$ = ecx

; 2829 :     void _Memcpy_val_from(const basic_string& _Right) noexcept {

	push	ebp
	mov	ebp, esp

; 2830 :         _STL_INTERNAL_CHECK(_Can_memcpy_val); // TRANSITION, if constexpr
; 2831 :         const auto _My_data_mem =
; 2832 :             reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 2833 :         const auto _Right_data_mem =
; 2834 :             reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	eax, DWORD PTR __Right$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 2836 :     }

	pop	ebp
	ret	4
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 2281 : #ifdef __cpp_lib_constexpr_string
; 2282 :         if (_STD is_constant_evaluated()) {
; 2283 :             return true;
; 2284 :         }
; 2285 : #endif // __cpp_lib_constexpr_string
; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	setae	al

; 2287 :     }

	ret	0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$dead$ = ecx

; 800  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

	push	ebp
	mov	ebp, esp

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN4@allocate

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	ecx, DWORD PTR [eax+35]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	ecx, eax
	jbe	SHORT $LN26@allocate

; 79   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new

; 134  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 79   :         return ::operator new(_Bytes);

	add	esp, 4

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN13@allocate

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 801  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 802  :     }

	pop	ebp
	ret	4
$LN13@allocate:

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4@allocate:

; 234  :     if (_Bytes != 0) {

	test	eax, eax
	je	SHORT $LN5@allocate

; 79   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 801  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 802  :     }

	pop	ebp
	ret	4
$LN5@allocate:

; 238  :     return nullptr;

	xor	eax, eax

; 801  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 802  :     }

	pop	ebp
	ret	4
$LN26@allocate:

; 131  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN24@allocate:
	int	3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXQADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXQADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$dead$ = ecx

; 795  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

	push	ebp
	mov	ebp, esp

; 796  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN12@deallocate

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN15@deallocate:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 798  :     }

	pop	ebp
	ret	8
$LN12@deallocate:

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@deallocate:
	int	3
?deallocate@?$allocator@D@std@@QAEXQADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z
_TEXT	SEGMENT
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z PROC	; std::_Narrow_char_traits<char,int>::assign, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 442  :         _Left = _Right;

	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 443  :     }

	ret	0
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ENDP	; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Char_traits<char,int>::move, COMDAT
; __First1$ = ecx
; __First2$ = edx

; 79   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	push	esi

; 80   :         // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
; 81   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 82   :         __builtin_memmove(_First1, _First2, _Count * sizeof(_Elem));
; 83   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^ / vvv !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 84   : #ifdef __cpp_lib_is_constant_evaluated
; 85   :         if (_STD is_constant_evaluated()) {
; 86   :             // dest: [_First1, _First1 + _Count)
; 87   :             // src: [_First2, _First2 + _Count)
; 88   :             // We need to handle overlapping ranges.
; 89   :             // If _First1 is in the src range, we need a backward loop.
; 90   :             // Otherwise, the forward loop works (even if the back of dest overlaps the front of src).
; 91   : 
; 92   :             if (_First1 == _First2) {
; 93   :                 return _First1; // Self-assignment; either loop would work, but returning immediately is faster.
; 94   :             }
; 95   : 
; 96   :             // Usually, we would compare pointers with less-than, even though they could belong to different arrays.
; 97   :             // However, we're not allowed to do that during constant evaluation, so we need a linear scan for equality.
; 98   :             bool _Loop_forward = true;
; 99   : 
; 100  :             for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {
; 101  :                 if (_First1 == _Src) {
; 102  :                     _Loop_forward = false;
; 103  :                     break;
; 104  :                 }
; 105  :             }
; 106  : 
; 107  :             if (_Loop_forward) {
; 108  :                 for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {
; 109  :                     _First1[_Idx] = _First2[_Idx];
; 110  :                 }
; 111  :             } else {
; 112  :                 for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {
; 113  :                     _First1[_Count - 1 - _Idx] = _First2[_Count - 1 - _Idx];
; 114  :                 }
; 115  :             }
; 116  : 
; 117  :             return _First1;
; 118  :         }
; 119  : #endif // __cpp_lib_is_constant_evaluated
; 120  : 
; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	push	DWORD PTR __Count$[ebp]
	mov	esi, ecx
	push	edx
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 122  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 123  : 
; 124  :         return _First1;

	mov	eax, esi
	pop	esi

; 125  :     }

	pop	ebp
	ret	0
?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Char_traits<char,int>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$_WChar_traits@_W@std@@SAXAA_WAB_W@Z
_TEXT	SEGMENT
?assign@?$_WChar_traits@_W@std@@SAXAA_WAB_W@Z PROC	; std::_WChar_traits<wchar_t>::assign, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 299  :         _Left = _Right;

	mov	ax, WORD PTR [edx]
	mov	WORD PTR [ecx], ax

; 300  :     }

	ret	0
?assign@?$_WChar_traits@_W@std@@SAXAA_WAB_W@Z ENDP	; std::_WChar_traits<wchar_t>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?move@?$_Char_traits@_WG@std@@SAPA_WQA_WQB_WI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?move@?$_Char_traits@_WG@std@@SAPA_WQA_WQB_WI@Z PROC	; std::_Char_traits<wchar_t,unsigned short>::move, COMDAT
; __First1$ = ecx
; __First2$ = edx

; 79   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp

; 80   :         // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
; 81   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 82   :         __builtin_memmove(_First1, _First2, _Count * sizeof(_Elem));
; 83   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^ / vvv !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 84   : #ifdef __cpp_lib_is_constant_evaluated
; 85   :         if (_STD is_constant_evaluated()) {
; 86   :             // dest: [_First1, _First1 + _Count)
; 87   :             // src: [_First2, _First2 + _Count)
; 88   :             // We need to handle overlapping ranges.
; 89   :             // If _First1 is in the src range, we need a backward loop.
; 90   :             // Otherwise, the forward loop works (even if the back of dest overlaps the front of src).
; 91   : 
; 92   :             if (_First1 == _First2) {
; 93   :                 return _First1; // Self-assignment; either loop would work, but returning immediately is faster.
; 94   :             }
; 95   : 
; 96   :             // Usually, we would compare pointers with less-than, even though they could belong to different arrays.
; 97   :             // However, we're not allowed to do that during constant evaluation, so we need a linear scan for equality.
; 98   :             bool _Loop_forward = true;
; 99   : 
; 100  :             for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {
; 101  :                 if (_First1 == _Src) {
; 102  :                     _Loop_forward = false;
; 103  :                     break;
; 104  :                 }
; 105  :             }
; 106  : 
; 107  :             if (_Loop_forward) {
; 108  :                 for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {
; 109  :                     _First1[_Idx] = _First2[_Idx];
; 110  :                 }
; 111  :             } else {
; 112  :                 for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {
; 113  :                     _First1[_Count - 1 - _Idx] = _First2[_Count - 1 - _Idx];
; 114  :                 }
; 115  :             }
; 116  : 
; 117  :             return _First1;
; 118  :         }
; 119  : #endif // __cpp_lib_is_constant_evaluated
; 120  : 
; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR __Count$[ebp]
	push	esi
	add	eax, eax
	mov	esi, ecx
	push	eax
	push	edx
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 122  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 123  : 
; 124  :         return _First1;

	mov	eax, esi
	pop	esi

; 125  :     }

	pop	ebp
	ret	0
?move@?$_Char_traits@_WG@std@@SAPA_WQA_WQB_WI@Z ENDP	; std::_Char_traits<wchar_t,unsigned short>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$_Char_traits@_UI@std@@SAXAA_UAB_U@Z
_TEXT	SEGMENT
?assign@?$_Char_traits@_UI@std@@SAXAA_UAB_U@Z PROC	; std::_Char_traits<char32_t,unsigned int>::assign, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 185  : #ifdef __cpp_lib_constexpr_string
; 186  :         if (_STD is_constant_evaluated()) {
; 187  :             _STD construct_at(_STD addressof(_Left), _Right);
; 188  :         } else
; 189  : #endif // __cpp_lib_constexpr_string
; 190  :         {
; 191  :             _Left = _Right;

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 192  :         }
; 193  :     }

	ret	0
?assign@?$_Char_traits@_UI@std@@SAXAA_UAB_U@Z ENDP	; std::_Char_traits<char32_t,unsigned int>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?move@?$_Char_traits@_UI@std@@SAPA_UQA_UQB_UI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?move@?$_Char_traits@_UI@std@@SAPA_UQA_UQB_UI@Z PROC	; std::_Char_traits<char32_t,unsigned int>::move, COMDAT
; __First1$ = ecx
; __First2$ = edx

; 79   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp

; 80   :         // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
; 81   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 82   :         __builtin_memmove(_First1, _First2, _Count * sizeof(_Elem));
; 83   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^ / vvv !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 84   : #ifdef __cpp_lib_is_constant_evaluated
; 85   :         if (_STD is_constant_evaluated()) {
; 86   :             // dest: [_First1, _First1 + _Count)
; 87   :             // src: [_First2, _First2 + _Count)
; 88   :             // We need to handle overlapping ranges.
; 89   :             // If _First1 is in the src range, we need a backward loop.
; 90   :             // Otherwise, the forward loop works (even if the back of dest overlaps the front of src).
; 91   : 
; 92   :             if (_First1 == _First2) {
; 93   :                 return _First1; // Self-assignment; either loop would work, but returning immediately is faster.
; 94   :             }
; 95   : 
; 96   :             // Usually, we would compare pointers with less-than, even though they could belong to different arrays.
; 97   :             // However, we're not allowed to do that during constant evaluation, so we need a linear scan for equality.
; 98   :             bool _Loop_forward = true;
; 99   : 
; 100  :             for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {
; 101  :                 if (_First1 == _Src) {
; 102  :                     _Loop_forward = false;
; 103  :                     break;
; 104  :                 }
; 105  :             }
; 106  : 
; 107  :             if (_Loop_forward) {
; 108  :                 for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {
; 109  :                     _First1[_Idx] = _First2[_Idx];
; 110  :                 }
; 111  :             } else {
; 112  :                 for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {
; 113  :                     _First1[_Count - 1 - _Idx] = _First2[_Count - 1 - _Idx];
; 114  :                 }
; 115  :             }
; 116  : 
; 117  :             return _First1;
; 118  :         }
; 119  : #endif // __cpp_lib_is_constant_evaluated
; 120  : 
; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR __Count$[ebp]
	push	esi
	shl	eax, 2
	mov	esi, ecx
	push	eax
	push	edx
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 122  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 123  : 
; 124  :         return _First1;

	mov	eax, esi
	pop	esi

; 125  :     }

	pop	ebp
	ret	0
?move@?$_Char_traits@_UI@std@@SAPA_UQA_UQB_UI@Z ENDP	; std::_Char_traits<char32_t,unsigned int>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?copy@?$_Char_traits@_UI@std@@SAPA_UQA_UQB_UI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?copy@?$_Char_traits@_UI@std@@SAPA_UQA_UQB_UI@Z PROC	; std::_Char_traits<char32_t,unsigned int>::copy, COMDAT
; __First1$ = ecx
; __First2$ = edx

; 48   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp

; 49   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 50   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 51   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 52   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^ / vvv !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 53   : #ifdef __cpp_lib_is_constant_evaluated
; 54   :         if (_STD is_constant_evaluated()) {
; 55   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap; see LWG-3085
; 56   :             for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {
; 57   :                 _First1[_Idx] = _First2[_Idx];
; 58   :             }
; 59   : 
; 60   :             return _First1;
; 61   :         }
; 62   : #endif // __cpp_lib_is_constant_evaluated
; 63   : 
; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR __Count$[ebp]
	push	esi
	shl	eax, 2
	mov	esi, ecx
	push	eax
	push	edx
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH

; 65   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 66   : 
; 67   :         return _First1;

	mov	eax, esi
	pop	esi

; 68   :     }

	pop	ebp
	ret	0
?copy@?$_Char_traits@_UI@std@@SAPA_UQA_UQB_UI@Z ENDP	; std::_Char_traits<char32_t,unsigned int>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$_WChar_traits@_S@std@@SAXAA_SAB_S@Z
_TEXT	SEGMENT
?assign@?$_WChar_traits@_S@std@@SAXAA_SAB_S@Z PROC	; std::_WChar_traits<char16_t>::assign, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 299  :         _Left = _Right;

	mov	ax, WORD PTR [edx]
	mov	WORD PTR [ecx], ax

; 300  :     }

	ret	0
?assign@?$_WChar_traits@_S@std@@SAXAA_SAB_S@Z ENDP	; std::_WChar_traits<char16_t>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?move@?$_Char_traits@_SG@std@@SAPA_SQA_SQB_SI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?move@?$_Char_traits@_SG@std@@SAPA_SQA_SQB_SI@Z PROC	; std::_Char_traits<char16_t,unsigned short>::move, COMDAT
; __First1$ = ecx
; __First2$ = edx

; 79   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp

; 80   :         // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
; 81   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 82   :         __builtin_memmove(_First1, _First2, _Count * sizeof(_Elem));
; 83   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^ / vvv !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 84   : #ifdef __cpp_lib_is_constant_evaluated
; 85   :         if (_STD is_constant_evaluated()) {
; 86   :             // dest: [_First1, _First1 + _Count)
; 87   :             // src: [_First2, _First2 + _Count)
; 88   :             // We need to handle overlapping ranges.
; 89   :             // If _First1 is in the src range, we need a backward loop.
; 90   :             // Otherwise, the forward loop works (even if the back of dest overlaps the front of src).
; 91   : 
; 92   :             if (_First1 == _First2) {
; 93   :                 return _First1; // Self-assignment; either loop would work, but returning immediately is faster.
; 94   :             }
; 95   : 
; 96   :             // Usually, we would compare pointers with less-than, even though they could belong to different arrays.
; 97   :             // However, we're not allowed to do that during constant evaluation, so we need a linear scan for equality.
; 98   :             bool _Loop_forward = true;
; 99   : 
; 100  :             for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {
; 101  :                 if (_First1 == _Src) {
; 102  :                     _Loop_forward = false;
; 103  :                     break;
; 104  :                 }
; 105  :             }
; 106  : 
; 107  :             if (_Loop_forward) {
; 108  :                 for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {
; 109  :                     _First1[_Idx] = _First2[_Idx];
; 110  :                 }
; 111  :             } else {
; 112  :                 for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {
; 113  :                     _First1[_Count - 1 - _Idx] = _First2[_Count - 1 - _Idx];
; 114  :                 }
; 115  :             }
; 116  : 
; 117  :             return _First1;
; 118  :         }
; 119  : #endif // __cpp_lib_is_constant_evaluated
; 120  : 
; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR __Count$[ebp]
	push	esi
	add	eax, eax
	mov	esi, ecx
	push	eax
	push	edx
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 122  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 123  : 
; 124  :         return _First1;

	mov	eax, esi
	pop	esi

; 125  :     }

	pop	ebp
	ret	0
?move@?$_Char_traits@_SG@std@@SAPA_SQA_SQB_SI@Z ENDP	; std::_Char_traits<char16_t,unsigned short>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?copy@?$_Char_traits@_SG@std@@SAPA_SQA_SQB_SI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?copy@?$_Char_traits@_SG@std@@SAPA_SQA_SQB_SI@Z PROC	; std::_Char_traits<char16_t,unsigned short>::copy, COMDAT
; __First1$ = ecx
; __First2$ = edx

; 48   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp

; 49   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 50   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 51   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 52   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^ / vvv !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 53   : #ifdef __cpp_lib_is_constant_evaluated
; 54   :         if (_STD is_constant_evaluated()) {
; 55   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap; see LWG-3085
; 56   :             for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {
; 57   :                 _First1[_Idx] = _First2[_Idx];
; 58   :             }
; 59   : 
; 60   :             return _First1;
; 61   :         }
; 62   : #endif // __cpp_lib_is_constant_evaluated
; 63   : 
; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR __Count$[ebp]
	push	esi
	add	eax, eax
	mov	esi, ecx
	push	eax
	push	edx
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH

; 65   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 66   : 
; 67   :         return _First1;

	mov	eax, esi
	pop	esi

; 68   :     }

	pop	ebp
	ret	0
?copy@?$_Char_traits@_SG@std@@SAPA_SQA_SQB_SI@Z ENDP	; std::_Char_traits<char16_t,unsigned short>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@_U@std@@V?$_String_val@U?$_Simple_types@_U@std@@@2@$00@std@@QAEAAV?$allocator@_U@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@_U@std@@V?$_String_val@U?$_Simple_types@_U@std@@@2@$00@std@@QAEAAV?$allocator@_U@2@XZ PROC ; std::_Compressed_pair<std::allocator<char32_t>,std::_String_val<std::_Simple_types<char32_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@_U@std@@V?$_String_val@U?$_Simple_types@_U@std@@@2@$00@std@@QAEAAV?$allocator@_U@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char32_t>,std::_String_val<std::_Simple_types<char32_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@_S@std@@V?$_String_val@U?$_Simple_types@_S@std@@@2@$00@std@@QAEAAV?$allocator@_S@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@_S@std@@V?$_String_val@U?$_Simple_types@_S@std@@@2@$00@std@@QAEAAV?$allocator@_S@2@XZ PROC ; std::_Compressed_pair<std::allocator<char16_t>,std::_String_val<std::_Simple_types<char16_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@_S@std@@V?$_String_val@U?$_Simple_types@_S@std@@@2@$00@std@@QAEAAV?$allocator@_S@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char16_t>,std::_String_val<std::_Simple_types<char16_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$allocator@_W@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$allocator@_W@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$allocator@_W@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size, COMDAT
; _this$dead$ = ecx

; 3910 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());
; 3911 :         const size_type _Storage_max = // can always store small string
; 3912 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 3913 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	eax, 2147483646				; 7ffffffeH

; 3914 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3915 :         );
; 3916 :     }

	ret	0
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
tv201 = 12						; size = 4
$T3 = 12						; size = 1
__Count$ = 12						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 3118 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 3119 :         // append [_Ptr, _Ptr + _Count)
; 3120 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3121 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [esi+16]
	sub	eax, edx
	cmp	ecx, eax
	ja	SHORT $LN2@append

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [esi+20], 8

; 3122 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [edx+ecx]
	push	edi
	mov	DWORD PTR tv201[ebp], eax

; 2263 :         value_type* _Result = _Bx._Buf;

	mov	edi, esi

; 3122 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	DWORD PTR [esi+16], eax

; 2264 :         if (_Large_string_engaged()) {

	jb	SHORT $LN5@append

; 2265 :             _Result = _Unfancy(_Bx._Ptr);

	mov	edi, DWORD PTR [esi]
$LN5@append:

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	lea	eax, DWORD PTR [ecx+ecx]
	push	eax

; 3123 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3124 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	lea	eax, DWORD PTR [edi+edx*2]

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	push	OFFSET ??_C@_15CNAMGDF@?$AA0?$AA1@
	push	eax
	call	_memmove

; 3125 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	eax, DWORD PTR tv201[ebp]

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	add	esp, 12					; 0000000cH

; 3125 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	xor	ecx, ecx
	mov	WORD PTR [edi+eax*2], cx

; 3126 :             return *this;

	mov	eax, esi
	pop	edi
	pop	esi

; 3130 :             _Count,
; 3131 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 3132 :                 const size_type _Count) {
; 3133 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3134 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 3136 :             },
; 3137 :             _Ptr, _Count);
; 3138 :     }

	pop	ebp
	ret	8
$LN2@append:

; 3127 :         }
; 3128 : 
; 3129 :         return _Reallocate_grow_by(

	push	ecx
	push	ecx
	mov	BYTE PTR $T3[ebp], 0
	push	DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, esi
	call	??$_Reallocate_grow_by@V<lambda_2fb699096920f2dc628cb0826b07831d>@@PB_WI@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_2fb699096920f2dc628cb0826b07831d>@@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_2fb699096920f2dc628cb0826b07831d>,wchar_t const *,unsigned int>
	pop	esi

; 3130 :             _Count,
; 3131 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 3132 :                 const size_type _Count) {
; 3133 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3134 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 3136 :             },
; 3137 :             _Ptr, _Count);
; 3138 :     }

	pop	ebp
	ret	8
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??R<lambda_2fb699096920f2dc628cb0826b07831d>@@QBE@QA_WQB_WI1I@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ptr$dead$ = 20					; size = 4
__Count$ = 24						; size = 4
??R<lambda_2fb699096920f2dc628cb0826b07831d>@@QBE@QA_WQB_WI1I@Z PROC ; <lambda_2fb699096920f2dc628cb0826b07831d>::operator(), COMDAT
; _this$dead$ = ecx

; 3132 :                 const size_type _Count) {

	push	ebp
	mov	ebp, esp
	push	ebx

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	ebx, DWORD PTR __New_ptr$[ebp]

; 3132 :                 const size_type _Count) {

	push	esi
	push	edi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	edi, DWORD PTR __Old_size$[ebp]
	add	edi, edi
	push	edi
	push	DWORD PTR __Old_ptr$[ebp]
	push	ebx
	call	_memcpy
	mov	esi, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [esi+esi]
	push	eax

; 3133 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3134 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

	lea	eax, DWORD PTR [edi+ebx]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	push	OFFSET ??_C@_15CNAMGDF@?$AA0?$AA1@
	push	eax
	call	_memcpy

; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	eax, DWORD PTR __Old_size$[ebp]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	add	esp, 24					; 00000018H

; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	add	eax, esi
	xor	ecx, ecx
	pop	edi
	pop	esi
	mov	WORD PTR [ebx+eax*2], cx
	pop	ebx

; 3136 :             },

	pop	ebp
	ret	20					; 00000014H
??R<lambda_2fb699096920f2dc628cb0826b07831d>@@QBE@QA_WQB_WI1I@Z ENDP ; <lambda_2fb699096920f2dc628cb0826b07831d>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@_W@std@@QAEPA_WI@Z PROC		; std::allocator<wchar_t>::allocate, COMDAT
; _this$dead$ = ecx

; 800  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

	push	ebp
	mov	ebp, esp

; 60   :         if (_Count > _Max_possible) {

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, 2147483647				; 7fffffffH
	ja	SHORT $LN27@allocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	add	eax, eax

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN8@allocate

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	ecx, DWORD PTR [eax+35]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	ecx, eax
	jbe	SHORT $LN27@allocate

; 79   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new

; 134  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 79   :         return ::operator new(_Bytes);

	add	esp, 4

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN17@allocate

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 801  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 802  :     }

	pop	ebp
	ret	4
$LN17@allocate:

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN8@allocate:

; 234  :     if (_Bytes != 0) {

	test	eax, eax
	je	SHORT $LN9@allocate

; 79   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 801  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 802  :     }

	pop	ebp
	ret	4
$LN9@allocate:

; 238  :     return nullptr;

	xor	eax, eax

; 801  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 802  :     }

	pop	ebp
	ret	4
$LN27@allocate:

; 131  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN28@allocate:
	int	3
?allocate@?$allocator@_W@std@@QAEPA_WI@Z ENDP		; std::allocator<wchar_t>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT
; ___formal$dead$ = ecx

; 695  :         return static_cast<size_t>(-1) / sizeof(value_type);

	or	eax, -1

; 696  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?length@?$_WChar_traits@_W@std@@SAIPB_W@Z
_TEXT	SEGMENT
?length@?$_WChar_traits@_W@std@@SAIPB_W@Z PROC		; std::_WChar_traits<wchar_t>::length, COMDAT
; __First$dead$ = ecx

; 260  :         // find length of null-terminated sequence
; 261  : #if _HAS_CXX17
; 262  :         if constexpr (is_same_v<_Elem, wchar_t>) {
; 263  :             return __builtin_wcslen(_First);
; 264  :         } else {
; 265  :             return _Primary_char_traits::length(_First);
; 266  :         }
; 267  : #else // _HAS_CXX17
; 268  :         return _CSTD wcslen(reinterpret_cast<const wchar_t*>(_First));

	mov	eax, 2

; 269  : #endif // _HAS_CXX17
; 270  :     }

	ret	0
?length@?$_WChar_traits@_W@std@@SAIPB_W@Z ENDP		; std::_WChar_traits<wchar_t>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 124  :             return _Ok;

	mov	al, BYTE PTR [ecx+4]

; 125  :         }

	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 108  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 109  : #if !_HAS_EXCEPTIONS
; 110  :             const bool _Zero_uncaught_exceptions = true;
; 111  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 112  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ

; 113  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 114  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 115  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 116  : 
; 117  :             if (_Zero_uncaught_exceptions) {

	test	al, al
	jne	SHORT $LN2@sentry

; 118  :                 this->_Myostr._Osfx();

	mov	ecx, DWORD PTR [esi]
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN2@sentry:

; 77   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 78   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	ecx, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 79   :         return _Mystrbuf;

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 79   :             if (_Rdbuf) {

	test	ecx, ecx
	je	SHORT $LN5@sentry

; 80   :                 _Rdbuf->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN5@sentry:

; 119  :             }
; 120  :         }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 91   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	mov	edi, DWORD PTR __Ostr$[ebp]

; 70   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	mov	DWORD PTR [esi], edi

; 71   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	edx, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 79   :         return _Mystrbuf;

	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+edi+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 72   :             if (_Rdbuf) {

	test	ecx, ecx
	je	SHORT $LN8@sentry

; 73   :                 _Rdbuf->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
	mov	edx, DWORD PTR [edi]
$LN8@sentry:

; 91   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 272  :         return _Mystate;

	mov	eax, DWORD PTR [edx+4]

; 291  :         return rdstate() == ios_base::goodbit;

	cmp	DWORD PTR [eax+edi+12], 0

; 272  :         return _Mystate;

	lea	ecx, DWORD PTR [eax+edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 92   :             if (!_Ostr.good()) {

	je	SHORT $LN2@sentry

; 93   :                 _Ok = false;

	xor	al, al

; 94   :                 return;

	jmp	SHORT $LN23@sentry
$LN2@sentry:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 69   :         return _Tiestr;

	mov	ecx, DWORD PTR [ecx+60]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 98   :             if (!_Tied || _Tied == &_Ostr) {

	test	ecx, ecx
	je	SHORT $LN4@sentry
	cmp	ecx, edi
	je	SHORT $LN4@sentry

; 100  :                 return;
; 101  :             }
; 102  : 
; 103  :             _Tied->flush();

	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 291  :         return rdstate() == ios_base::goodbit;

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax+edi+12], 0
	sete	al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 104  :             _Ok = _Ostr.good(); // store test only after flushing tie

	jmp	SHORT $LN23@sentry
$LN4@sentry:

; 99   :                 _Ok = true;

	mov	al, 1
$LN23@sentry:

; 105  :         }

	mov	BYTE PTR [esi+4], al
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<wchar_t> >::max_size, COMDAT
; ___formal$dead$ = ecx

; 695  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	eax, 2147483647				; 7fffffffH

; 696  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 77   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 78   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	ecx, DWORD PTR [ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 79   :         return _Mystrbuf;

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 79   :             if (_Rdbuf) {

	test	ecx, ecx
	je	SHORT $LN2@Sentry_bas

; 80   :                 _Rdbuf->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 81   :             }
; 82   :         }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 70   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR __Ostr$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 79   :         return _Mystrbuf;

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 72   :             if (_Rdbuf) {

	test	ecx, ecx
	je	SHORT $LN6@Sentry_bas

; 73   :                 _Rdbuf->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN6@Sentry_bas:

; 74   :             }
; 75   :         }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z
_TEXT	SEGMENT
$T6 = -4						; size = 1
___$ReturnUdt$ = -4					; size = 4
__Right$dead$ = 8					; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$ = edx

; 4749 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, _In_z_ const _Elem* const _Right) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3121 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	eax, DWORD PTR [edx+20]

; 4749 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, _In_z_ const _Elem* const _Right) {

	push	esi
	push	edi

; 3120 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	edi, DWORD PTR [edx+16]

; 4749 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, _In_z_ const _Elem* const _Right) {

	mov	esi, ecx

; 3121 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	sub	eax, edi

; 4749 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, _In_z_ const _Elem* const _Right) {

	mov	DWORD PTR ___$ReturnUdt$[ebp], esi

; 3121 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	eax, 2
	jb	SHORT $LN10@operator

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [edx+20], 16			; 00000010H

; 3122 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [edi+2]
	mov	DWORD PTR [edx+16], eax

; 2263 :         value_type* _Result = _Bx._Buf;

	mov	ecx, edx

; 2264 :         if (_Large_string_engaged()) {

	jb	SHORT $LN13@operator

; 2265 :             _Result = _Unfancy(_Bx._Ptr);

	mov	ecx, DWORD PTR [edx]
$LN13@operator:

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	ax, WORD PTR ??_C@_02PLJDPFIO@00@
	mov	WORD PTR [ecx+edi], ax

; 3125 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [ecx+edi+2], 0

; 3126 :             return *this;

	jmp	SHORT $LN9@operator
$LN10@operator:

; 3127 :         }
; 3128 : 
; 3129 :         return _Reallocate_grow_by(

	push	2
	push	ecx
	mov	BYTE PTR $T6[ebp], 0
	mov	ecx, edx
	push	DWORD PTR $T6[ebp]
	push	2
	call	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
	mov	edx, eax
$LN9@operator:

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [esi], 0

; 4750 :     return _STD move(_Left.append(_Right));

	mov	eax, esi

; 2322 :     size_type _Mysize = 0; // current length of string

	mov	DWORD PTR [esi+16], 0

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

	mov	DWORD PTR [esi+20], 0

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [edx]

; 4750 :     return _STD move(_Left.append(_Right));

	pop	edi

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	XMMWORD PTR [esi], xmm0
	movq	xmm0, QWORD PTR [edx+16]
	movq	QWORD PTR [esi+16], xmm0

; 4562 :         _My_data._Mysize = 0;

	mov	DWORD PTR [edx+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR [edx+20], 15			; 0000000fH

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [edx], 0

; 4750 :     return _STD move(_Left.append(_Right));

	pop	esi

; 4751 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@QB_W@Z
_TEXT	SEGMENT
$T5 = -4						; size = 1
___$ReturnUdt$ = -4					; size = 4
__Right$dead$ = 8					; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@QB_W@Z PROC ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$ = edx

; 4749 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, _In_z_ const _Elem* const _Right) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3121 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	eax, DWORD PTR [edx+20]

; 4749 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, _In_z_ const _Elem* const _Right) {

	push	esi
	mov	esi, ecx

; 3120 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	ecx, DWORD PTR [edx+16]

; 3121 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	sub	eax, ecx

; 4749 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, _In_z_ const _Elem* const _Right) {

	mov	DWORD PTR ___$ReturnUdt$[ebp], esi

; 3121 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	eax, 2
	jb	SHORT $LN8@operator

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [edx+20], 8

; 2263 :         value_type* _Result = _Bx._Buf;

	mov	eax, edx

; 3122 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	push	edi
	lea	edi, DWORD PTR [ecx+2]
	mov	DWORD PTR [edx+16], edi

; 2264 :         if (_Large_string_engaged()) {

	jb	SHORT $LN11@operator

; 2265 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [edx]
$LN11@operator:

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	DWORD PTR [eax+ecx*2], 3211312		; 00310030H

; 3125 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	xor	ecx, ecx
	mov	WORD PTR [eax+edi*2], cx
	pop	edi

; 3126 :             return *this;

	jmp	SHORT $LN7@operator
$LN8@operator:

; 3127 :         }
; 3128 : 
; 3129 :         return _Reallocate_grow_by(

	push	2
	push	ecx
	mov	BYTE PTR $T5[ebp], 0
	mov	ecx, edx
	push	DWORD PTR $T5[ebp]
	push	2
	call	??$_Reallocate_grow_by@V<lambda_2fb699096920f2dc628cb0826b07831d>@@PB_WI@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_2fb699096920f2dc628cb0826b07831d>@@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_2fb699096920f2dc628cb0826b07831d>,wchar_t const *,unsigned int>
	mov	edx, eax
$LN7@operator:

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [esi], 0

; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	xor	eax, eax

; 2322 :     size_type _Mysize = 0; // current length of string

	mov	DWORD PTR [esi+16], 0

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

	mov	DWORD PTR [esi+20], 0

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [edx]
	movups	XMMWORD PTR [esi], xmm0
	movq	xmm0, QWORD PTR [edx+16]
	movq	QWORD PTR [esi+16], xmm0

; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [edx], ax

; 4750 :     return _STD move(_Left.append(_Right));

	mov	eax, esi

; 4562 :         _My_data._Mysize = 0;

	mov	DWORD PTR [edx+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR [edx+20], 7

; 4750 :     return _STD move(_Left.append(_Right));

	pop	esi

; 4751 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@QB_W@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??$?H_SU?$char_traits@_S@std@@V?$allocator@_S@1@@std@@YA?AV?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@0@$$QAV10@QB_S@Z
_TEXT	SEGMENT
$T5 = -4						; size = 1
___$ReturnUdt$ = -4					; size = 4
__Right$dead$ = 8					; size = 4
??$?H_SU?$char_traits@_S@std@@V?$allocator@_S@1@@std@@YA?AV?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@0@$$QAV10@QB_S@Z PROC ; std::operator+<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$ = edx

; 4749 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, _In_z_ const _Elem* const _Right) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3121 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	eax, DWORD PTR [edx+20]

; 4749 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, _In_z_ const _Elem* const _Right) {

	push	esi
	mov	esi, ecx

; 3120 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	ecx, DWORD PTR [edx+16]

; 3121 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	sub	eax, ecx

; 4749 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, _In_z_ const _Elem* const _Right) {

	mov	DWORD PTR ___$ReturnUdt$[ebp], esi

; 3121 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	eax, 2
	jb	SHORT $LN8@operator

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [edx+20], 8

; 2263 :         value_type* _Result = _Bx._Buf;

	mov	eax, edx

; 3122 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	push	edi
	lea	edi, DWORD PTR [ecx+2]
	mov	DWORD PTR [edx+16], edi

; 2264 :         if (_Large_string_engaged()) {

	jb	SHORT $LN11@operator

; 2265 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [edx]
$LN11@operator:

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	DWORD PTR [eax+ecx*2], 3276848		; 00320030H

; 3125 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	xor	ecx, ecx
	mov	WORD PTR [eax+edi*2], cx
	pop	edi

; 3126 :             return *this;

	jmp	SHORT $LN7@operator
$LN8@operator:

; 3127 :         }
; 3128 : 
; 3129 :         return _Reallocate_grow_by(

	push	2
	push	ecx
	mov	BYTE PTR $T5[ebp], 0
	mov	ecx, edx
	push	DWORD PTR $T5[ebp]
	push	2
	call	??$_Reallocate_grow_by@V<lambda_98ae700cc7810ca9f391bc310db97391>@@PB_SI@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEAAV01@IV<lambda_98ae700cc7810ca9f391bc310db97391>@@PB_SI@Z ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Reallocate_grow_by<<lambda_98ae700cc7810ca9f391bc310db97391>,char16_t const *,unsigned int>
	mov	edx, eax
$LN7@operator:

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [esi], 0

; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	xor	eax, eax

; 2322 :     size_type _Mysize = 0; // current length of string

	mov	DWORD PTR [esi+16], 0

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

	mov	DWORD PTR [esi+20], 0

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [edx]
	movups	XMMWORD PTR [esi], xmm0
	movq	xmm0, QWORD PTR [edx+16]
	movq	QWORD PTR [esi+16], xmm0

; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [edx], ax

; 4750 :     return _STD move(_Left.append(_Right));

	mov	eax, esi

; 4562 :         _My_data._Mysize = 0;

	mov	DWORD PTR [edx+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR [edx+20], 7

; 4750 :     return _STD move(_Left.append(_Right));

	pop	esi

; 4751 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?H_SU?$char_traits@_S@std@@V?$allocator@_S@1@@std@@YA?AV?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@0@$$QAV10@QB_S@Z ENDP ; std::operator+<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??$?H_UU?$char_traits@_U@std@@V?$allocator@_U@1@@std@@YA?AV?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@0@$$QAV10@QB_U@Z
_TEXT	SEGMENT
tv437 = -4						; size = 4
$T6 = -4						; size = 1
___$ReturnUdt$ = -4					; size = 4
__Right$dead$ = 8					; size = 4
??$?H_UU?$char_traits@_U@std@@V?$allocator@_U@1@@std@@YA?AV?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@0@$$QAV10@QB_U@Z PROC ; std::operator+<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$ = edx

; 4749 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, _In_z_ const _Elem* const _Right) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, edx
	mov	DWORD PTR ___$ReturnUdt$[ebp], edi

; 3141 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	eax, OFFSET ??_C@_2M@JLEBFLAK@?$AA?$AA?$AA0?$AA?$AA?$AA3@

; 144  :         size_t _Count = 0;

	xor	edx, edx
$LL8@operator:

; 145  :         while (*_First != _Elem()) {
; 146  :             ++_Count;
; 147  :             ++_First;

	lea	eax, DWORD PTR [eax+4]
	inc	edx
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LL8@operator

; 3121 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [esi+16]
	sub	eax, ecx
	cmp	edx, eax
	ja	SHORT $LN12@operator

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [esi+20], 4

; 3122 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [ecx+edx]
	push	ebx
	mov	DWORD PTR tv437[ebp], eax

; 2263 :         value_type* _Result = _Bx._Buf;

	mov	ebx, esi

; 3122 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	DWORD PTR [esi+16], eax

; 2264 :         if (_Large_string_engaged()) {

	jb	SHORT $LN15@operator

; 2265 :             _Result = _Unfancy(_Bx._Ptr);

	mov	ebx, DWORD PTR [esi]
$LN15@operator:

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	lea	eax, DWORD PTR [edx*4]
	push	eax

; 3124 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	lea	eax, DWORD PTR [ebx+ecx*4]

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	push	OFFSET ??_C@_2M@JLEBFLAK@?$AA?$AA?$AA0?$AA?$AA?$AA3@
	push	eax
	call	_memmove

; 3125 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	eax, DWORD PTR tv437[ebp]

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	add	esp, 12					; 0000000cH

; 3125 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	DWORD PTR [ebx+eax*4], 0
	pop	ebx

; 3126 :             return *this;

	jmp	SHORT $LN11@operator
$LN12@operator:

; 3127 :         }
; 3128 : 
; 3129 :         return _Reallocate_grow_by(

	push	edx
	push	ecx
	mov	BYTE PTR $T6[ebp], 0
	mov	ecx, esi
	push	DWORD PTR $T6[ebp]
	push	edx
	call	??$_Reallocate_grow_by@V<lambda_aabcc5df0dcdbd223414bc3ba38ad6d9>@@PB_UI@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEAAV01@IV<lambda_aabcc5df0dcdbd223414bc3ba38ad6d9>@@PB_UI@Z ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Reallocate_grow_by<<lambda_aabcc5df0dcdbd223414bc3ba38ad6d9>,char32_t const *,unsigned int>
	mov	esi, eax
$LN11@operator:

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [edi], 0

; 4750 :     return _STD move(_Left.append(_Right));

	mov	eax, edi

; 2322 :     size_type _Mysize = 0; // current length of string

	mov	DWORD PTR [edi+16], 0

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

	mov	DWORD PTR [edi+20], 0

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [esi]
	movups	XMMWORD PTR [edi], xmm0
	movq	xmm0, QWORD PTR [esi+16]
	movq	QWORD PTR [edi+16], xmm0

; 4750 :     return _STD move(_Left.append(_Right));

	pop	edi

; 4562 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 3

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	DWORD PTR [esi], 0

; 4750 :     return _STD move(_Left.append(_Right));

	pop	esi

; 4751 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?H_UU?$char_traits@_U@std@@V?$allocator@_U@1@@std@@YA?AV?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@0@$$QAV10@QB_U@Z ENDP ; std::operator+<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; __Ostr$ = ecx
; __Str$ = edx

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [edx+20], 16			; 00000010H

; 2272 :         const value_type* _Result = _Bx._Buf;

	mov	eax, edx

; 2273 :         if (_Large_string_engaged()) {

	jb	SHORT $LN6@operator

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [edx]
$LN6@operator:

; 4947 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

	push	DWORD PTR [edx+16]
	mov	edx, eax
	call	??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
	add	esp, 4

; 4948 : }

	ret	0
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 974  :     basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream

	push	ebp
	mov	ebp, esp
	push	esi

; 975  :     _Ostr.put(_Ostr.widen('\n'));

	mov	esi, DWORD PTR __Ostr$[ebp]
	push	10					; 0000000aH
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
	call	DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	movzx	ecx, al
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z

; 976  :     _Ostr.flush();

	mov	ecx, esi
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 977  :     return _Ostr;

	mov	eax, esi
	pop	esi

; 978  : }

	pop	ebp
	ret	0
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; __Ostr$ = ecx
; __Str$ = edx

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [edx+20], 8

; 2272 :         const value_type* _Result = _Bx._Buf;

	mov	eax, edx

; 2273 :         if (_Large_string_engaged()) {

	jb	SHORT $LN6@operator

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [edx]
$LN6@operator:

; 4947 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

	push	DWORD PTR [edx+16]
	mov	edx, eax
	call	??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z ; std::_Insert_string<wchar_t,std::char_traits<wchar_t>,unsigned int>
	add	esp, 4

; 4948 : }

	ret	0
??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??$endl@_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??$endl@_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@@Z PROC ; std::endl<wchar_t,std::char_traits<wchar_t> >, COMDAT

; 974  :     basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream

	push	ebp
	mov	ebp, esp
	push	esi

; 975  :     _Ostr.put(_Ostr.widen('\n'));

	mov	esi, DWORD PTR __Ostr$[ebp]
	push	10					; 0000000aH
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
	call	DWORD PTR __imp_?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z
	movzx	ecx, ax
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?put@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@_W@Z

; 976  :     _Ostr.flush();

	mov	ecx, esi
	call	DWORD PTR __imp_?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ

; 977  :     return _Ostr;

	mov	eax, esi
	pop	esi

; 978  : }

	pop	ebp
	ret	0
??$endl@_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@@Z ENDP ; std::endl<wchar_t,std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
_TEXT	SEGMENT
__Ok$ = -44						; size = 8
__Ch$1$ = -36						; size = 4
$T15 = -36						; size = 1
__Pad$22 = -32						; size = 8
$T6 = -28						; size = 1
__State$ = -24						; size = 4
__Ostr$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT
; __Ostr$ = ecx
; __Ch$ = edx

; 776  :     basic_ostream<char, _Traits>& _Ostr, char _Ch) { // insert a char into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Ch$1$[ebp], edx
	mov	DWORD PTR __Ostr$[ebp], ecx

; 71   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	edx, DWORD PTR [ecx]

; 777  :     using _Elem = char;
; 778  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 779  : 
; 780  :     ios_base::iostate _State = ios_base::goodbit;

	xor	esi, esi
	mov	DWORD PTR __State$[ebp], esi

; 70   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	mov	DWORD PTR __Ok$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 79   :         return _Mystrbuf;

	mov	eax, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [eax+ecx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 72   :             if (_Rdbuf) {

	test	edi, edi
	je	SHORT $LN29@operator

; 73   :                 _Rdbuf->_Lock();

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
$LN29@operator:

; 91   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 272  :         return _Mystate;

	mov	eax, DWORD PTR [edx+4]
	add	eax, ecx

; 291  :         return rdstate() == ios_base::goodbit;

	cmp	DWORD PTR [eax+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 92   :             if (!_Ostr.good()) {

	je	SHORT $LN23@operator

; 93   :                 _Ok = false;

	xor	al, al

; 94   :                 return;

	jmp	SHORT $LN97@operator
$LN23@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 69   :         return _Tiestr;

	mov	eax, DWORD PTR [eax+60]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 98   :             if (!_Tied || _Tied == &_Ostr) {

	test	eax, eax
	je	SHORT $LN25@operator
	cmp	eax, ecx
	je	SHORT $LN25@operator

; 100  :                 return;
; 101  :             }
; 102  : 
; 103  :             _Tied->flush();

	mov	ecx, eax
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 104  :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edi, DWORD PTR [ecx]
	mov	edx, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 272  :         return _Mystate;

	mov	eax, DWORD PTR [edi+4]

; 291  :         return rdstate() == ios_base::goodbit;

	cmp	DWORD PTR [eax+ecx+12], 0
	sete	al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 104  :             _Ok = _Ostr.good(); // store test only after flushing tie

	jmp	SHORT $LN98@operator
$LN25@operator:

; 99   :                 _Ok = true;

	mov	al, 1
$LN97@operator:

; 781  :     const typename _Myos::sentry _Ok(_Ostr);

	mov	edi, edx
$LN98@operator:
	mov	BYTE PTR __Ok$[ebp+4], al
	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 782  : 
; 783  :     if (_Ok) { // state okay, insert

	test	al, al
	je	$LN20@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 359  :         return _Wide;

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [eax+ecx+36]
	mov	edi, DWORD PTR [eax+ecx+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 784  :         streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

	test	ebx, ebx
	jg	SHORT $LN15@operator
	jl	SHORT $LN90@operator
	cmp	edi, 1
	ja	SHORT $LN15@operator
$LN90@operator:
	xorps	xmm0, xmm0
	movlpd	QWORD PTR __Pad$22[ebp], xmm0
	mov	ebx, DWORD PTR __Pad$22[ebp+4]
	mov	edi, DWORD PTR __Pad$22[ebp]
	jmp	SHORT $LN16@operator
$LN15@operator:
	sub	edi, 1
	sbb	ebx, 0
$LN16@operator:

; 785  : 
; 786  :         _TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 322  :         return _Fmtfl;

	mov	eax, DWORD PTR [eax+ecx+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 787  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN86@operator
$LL4@operator:

; 788  :             for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { // pad on left

	test	esi, esi
	jne	$LN6@operator
	test	ebx, ebx
	jl	SHORT $LN88@operator
	jg	SHORT $LN91@operator
	test	edi, edi
	je	SHORT $LN88@operator
$LN91@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 100  :         return _Fillch;

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	add	ecx, eax
	mov	al, BYTE PTR [ecx+64]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 789  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	ecx, DWORD PTR [ecx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 100  :         return _Fillch;

	mov	BYTE PTR $T6[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 789  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	push	DWORD PTR $T6[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	mov	ecx, DWORD PTR __Ostr$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 462  :         return _Left == _Right;

	cmp	eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 789  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	eax, 4
	cmove	esi, eax
	add	edi, -1
	mov	DWORD PTR __State$[ebp], esi
	adc	ebx, -1
	jmp	SHORT $LL4@operator
$LN88@operator:
	mov	edx, DWORD PTR [ecx]
$LN86@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 79   :         return _Mystrbuf;

	mov	eax, DWORD PTR [edx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 795  :         if (_State == ios_base::goodbit && _Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ch))) {

	push	DWORD PTR __Ch$1$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+56]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	eax, -1
	mov	eax, 4
	cmove	esi, eax
$LN99@operator:

; 796  :             _State |= ios_base::badbit;
; 797  :         }
; 798  : 
; 799  :         for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { // pad on right

	mov	DWORD PTR __State$[ebp], esi
	test	esi, esi
	jne	SHORT $LN6@operator
	test	ebx, ebx
	jl	SHORT $LN6@operator
	jg	SHORT $LN92@operator
	test	edi, edi
	je	SHORT $LN6@operator
$LN92@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 100  :         return _Fillch;

	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	add	ecx, eax
	mov	al, BYTE PTR [ecx+64]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 800  :             if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	ecx, DWORD PTR [ecx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 100  :         return _Fillch;

	mov	BYTE PTR $T15[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 800  :             if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	push	DWORD PTR $T15[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 462  :         return _Left == _Right;

	cmp	eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 800  :             if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	eax, 4
	cmove	esi, eax
	add	edi, -1
	adc	ebx, -1
	jmp	SHORT $LN99@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$0:

; 801  :                 _State |= ios_base::badbit;
; 802  :             }
; 803  :         }
; 804  :         _CATCH_IO_(ios_base, _Ostr)

	mov	edx, DWORD PTR __Ostr$[ebp]
	push	1
	push	4
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	mov	eax, $LN21@operator
	ret	0
$LN21@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
	mov	esi, DWORD PTR __State$[ebp]
$LN6@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 805  :     }
; 806  : 
; 807  :     _Ostr.width(0);

	mov	DWORD PTR __$EHRec$[ebp+12], 1
$LN20@operator:
	mov	ebx, DWORD PTR __Ostr$[ebp]

; 808  :     _Ostr.setstate(_State);

	push	0
	push	esi
	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 364  :         _Wide                      = _Newwidth;

	mov	DWORD PTR [eax+ebx+32], 0
	mov	DWORD PTR [eax+ebx+36], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 808  :     _Ostr.setstate(_State);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, ebx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 108  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

	mov	DWORD PTR __$EHRec$[ebp+12], 4

; 109  : #if !_HAS_EXCEPTIONS
; 110  :             const bool _Zero_uncaught_exceptions = true;
; 111  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 112  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ

; 113  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 114  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 115  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 116  : 
; 117  :             if (_Zero_uncaught_exceptions) {

	mov	esi, DWORD PTR __Ok$[ebp]
	test	al, al
	jne	SHORT $LN68@operator

; 118  :                 this->_Myostr._Osfx();

	mov	ecx, esi
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN68@operator:

; 77   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

	mov	BYTE PTR __$EHRec$[ebp+12], 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 79   :         return _Mystrbuf;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 79   :             if (_Rdbuf) {

	test	ecx, ecx
	je	SHORT $LN93@operator

; 80   :                 _Rdbuf->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN93@operator:

; 809  :     return _Ostr;
; 810  : }

	mov	eax, ebx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$3:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
__Ok$ = -44						; size = 8
__Pad$ = -44						; size = 8
__State$ = -36						; size = 4
__Val$1$ = -32						; size = 4
$T14 = -32						; size = 1
tv664 = -28						; size = 4
$T8 = -28						; size = 1
__Ostr$ = -24						; size = 4
__Count$2$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT
; __Ostr$ = ecx
; __Val$ = edx

; 731  :     const char* _Val) { // insert NTBS into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	eax, edx
	mov	DWORD PTR __Val$1$[ebp], eax
	mov	ebx, ecx
	mov	DWORD PTR __Ostr$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	mov	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 735  :     ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	lea	esi, DWORD PTR [ecx+1]
$LL92@operator:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL92@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 737  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

	mov	edx, DWORD PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	sub	ecx, esi
	mov	DWORD PTR __Count$2$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 359  :         return _Wide;

	mov	eax, DWORD PTR [edx+4]
	add	eax, ebx
	mov	DWORD PTR tv664[ebp], eax
	mov	edi, DWORD PTR [eax+36]
	mov	esi, DWORD PTR [eax+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 737  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

	test	edi, edi
	jl	SHORT $LN17@operator
	jg	SHORT $LN94@operator
	test	esi, esi
	je	SHORT $LN17@operator
	test	edi, edi
	jl	SHORT $LN17@operator
	jg	SHORT $LN94@operator
	cmp	esi, ecx
	jbe	SHORT $LN17@operator
$LN94@operator:
	sub	esi, ecx
	sbb	edi, 0
	jmp	SHORT $LN18@operator
$LN17@operator:
	xorps	xmm0, xmm0
	movlpd	QWORD PTR __Pad$[ebp], xmm0
	mov	edi, DWORD PTR __Pad$[ebp+4]
	mov	esi, DWORD PTR __Pad$[ebp]
$LN18@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 79   :         return _Mystrbuf;

	mov	eax, DWORD PTR [eax+56]
	mov	ecx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 70   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	mov	DWORD PTR __Ok$[ebp], ebx

; 71   :             const auto _Rdbuf = _Myostr.rdbuf();
; 72   :             if (_Rdbuf) {

	test	eax, eax
	je	SHORT $LN39@operator

; 73   :                 _Rdbuf->_Lock();

	mov	ecx, DWORD PTR tv664[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	call	DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ebx]
	mov	ecx, edx
$LN39@operator:

; 91   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 272  :         return _Mystate;

	mov	eax, DWORD PTR [edx+4]
	add	eax, ebx

; 291  :         return rdstate() == ios_base::goodbit;

	cmp	DWORD PTR [eax+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 92   :             if (!_Ostr.good()) {

	je	SHORT $LN33@operator

; 93   :                 _Ok = false;

	xor	al, al

; 94   :                 return;

	jmp	SHORT $LN107@operator
$LN33@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 69   :         return _Tiestr;

	mov	eax, DWORD PTR [eax+60]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 98   :             if (!_Tied || _Tied == &_Ostr) {

	test	eax, eax
	je	SHORT $LN35@operator
	cmp	eax, ebx
	je	SHORT $LN35@operator

; 100  :                 return;
; 101  :             }
; 102  : 
; 103  :             _Tied->flush();

	mov	ecx, eax
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 104  :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	edx, DWORD PTR [ebx]
	mov	ecx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 272  :         return _Mystate;

	mov	eax, DWORD PTR [edx+4]

; 291  :         return rdstate() == ios_base::goodbit;

	cmp	DWORD PTR [eax+ebx+12], 0
	sete	al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 104  :             _Ok = _Ostr.good(); // store test only after flushing tie

	jmp	SHORT $LN107@operator
$LN35@operator:

; 99   :                 _Ok = true;

	mov	al, 1
$LN107@operator:

; 738  :     const typename _Myos::sentry _Ok(_Ostr);

	mov	BYTE PTR __Ok$[ebp+4], al
	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 739  : 
; 740  :     if (!_Ok) {

	test	al, al
	jne	SHORT $LN8@operator

; 741  :         _State |= ios_base::badbit;

	mov	ecx, 4

; 742  :     } else { // state okay, insert

	jmp	$LN22@operator
$LN8@operator:

; 743  :         _TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 322  :         return _Fmtfl;

	mov	eax, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [eax+ebx+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 744  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN87@operator
	npad	6
$LL4@operator:

; 745  :             for (; 0 < _Pad; --_Pad) { // pad on left

	test	edi, edi
	jl	SHORT $LN89@operator
	jg	SHORT $LN95@operator
	test	esi, esi
	je	SHORT $LN89@operator
$LN95@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 100  :         return _Fillch;

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]
	mov	al, BYTE PTR [ecx+ebx+64]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 746  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	ecx, DWORD PTR [ecx+ebx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 100  :         return _Fillch;

	mov	BYTE PTR $T8[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 746  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	push	DWORD PTR $T8[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	eax, -1
	jne	SHORT $LN2@operator

; 747  :                     _State |= ios_base::badbit; // insertion failed, quit

	lea	ecx, DWORD PTR [eax+5]

; 748  :                     break;

	jmp	SHORT $LN6@operator
$LN2@operator:

; 745  :             for (; 0 < _Pad; --_Pad) { // pad on left

	add	esi, -1
	adc	edi, -1
	jmp	SHORT $LL4@operator
$LN89@operator:

; 753  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

	mov	ecx, DWORD PTR [ebx]
$LN87@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 79   :         return _Mystrbuf;

	mov	eax, DWORD PTR [ecx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 753  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

	push	0
	push	DWORD PTR __Count$2$[ebp]
	push	DWORD PTR __Val$1$[ebp]
	mov	ecx, DWORD PTR [eax+ebx+56]
	call	DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
	cmp	eax, DWORD PTR __Count$2$[ebp]
	jne	SHORT $LN96@operator
	test	edx, edx
	jne	SHORT $LN96@operator
$LL98@operator:

; 754  :             _State |= ios_base::badbit;
; 755  :         }
; 756  : 
; 757  :         if (_State == ios_base::goodbit) {
; 758  :             for (; 0 < _Pad; --_Pad) { // pad on right

	test	edi, edi
	jl	SHORT $LN102@operator
	jg	SHORT $LN97@operator
	test	esi, esi
	je	SHORT $LN102@operator
$LN97@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 100  :         return _Fillch;

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]
	mov	al, BYTE PTR [ecx+ebx+64]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 759  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	ecx, DWORD PTR [ecx+ebx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 100  :         return _Fillch;

	mov	BYTE PTR $T14[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 759  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	push	DWORD PTR $T14[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	eax, -1
	jne	SHORT $LN5@operator
$LN96@operator:

; 760  :                     _State |= ios_base::badbit; // insertion failed, quit
; 761  :                     break;
; 762  :                 }
; 763  :             }
; 764  :         }
; 765  : 
; 766  :         _Ostr.width(0);

	mov	ecx, 4
	jmp	SHORT $LN6@operator
$LN5@operator:

; 754  :             _State |= ios_base::badbit;
; 755  :         }
; 756  : 
; 757  :         if (_State == ios_base::goodbit) {
; 758  :             for (; 0 < _Pad; --_Pad) { // pad on right

	add	esi, -1
	adc	edi, -1
	jmp	SHORT $LL98@operator
$LN102@operator:

; 760  :                     _State |= ios_base::badbit; // insertion failed, quit
; 761  :                     break;
; 762  :                 }
; 763  :             }
; 764  :         }
; 765  : 
; 766  :         _Ostr.width(0);

	xor	ecx, ecx
$LN6@operator:
	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 364  :         _Wide                      = _Newwidth;

	mov	DWORD PTR [eax+ebx+32], 0
	mov	DWORD PTR [eax+ebx+36], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
	jmp	SHORT $LN108@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 767  :         _CATCH_IO_(ios_base, _Ostr)

	mov	edx, DWORD PTR __Ostr$[ebp]
	push	1
	push	4
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	mov	eax, $LN23@operator
	ret	0
$LN23@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
	mov	ebx, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR __State$[ebp]
$LN108@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 768  :     }
; 769  : 
; 770  :     _Ostr.setstate(_State);

	mov	DWORD PTR __$EHRec$[ebp+12], 1
$LN22@operator:
	mov	eax, DWORD PTR [ebx]
	push	0
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, ebx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 108  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

	mov	DWORD PTR __$EHRec$[ebp+12], 4

; 109  : #if !_HAS_EXCEPTIONS
; 110  :             const bool _Zero_uncaught_exceptions = true;
; 111  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 112  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ

; 113  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 114  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 115  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 116  : 
; 117  :             if (_Zero_uncaught_exceptions) {

	mov	esi, DWORD PTR __Ok$[ebp]
	test	al, al
	jne	SHORT $LN72@operator

; 118  :                 this->_Myostr._Osfx();

	mov	ecx, esi
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN72@operator:

; 77   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

	mov	BYTE PTR __$EHRec$[ebp+12], 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 79   :         return _Mystrbuf;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 79   :             if (_Rdbuf) {

	test	ecx, ecx
	je	SHORT $LN99@operator

; 80   :                 _Rdbuf->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN99@operator:

; 771  :     return _Ostr;
; 772  : }

	mov	eax, ebx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$min@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
??$min@I@std@@YAABIABI0@Z PROC				; std::min<unsigned int>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 65   :     // return smaller of _Left and _Right
; 66   :     return _Right < _Left ? _Right : _Left;

	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [ecx]
	cmovb	ecx, edx
	mov	eax, ecx

; 67   : }

	ret	0
??$min@I@std@@YAABIABI0@Z ENDP				; std::min<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@_U@std@@V?$_String_val@U?$_Simple_types@_U@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@_U@std@@V?$_String_val@U?$_Simple_types@_U@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char32_t>,std::_String_val<std::_Simple_types<char32_t> >,1>::_Compressed_pair<std::allocator<char32_t>,std::_String_val<std::_Simple_types<char32_t> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2322 :     size_type _Mysize = 0; // current length of string

	mov	DWORD PTR [ecx+16], 0

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

	mov	DWORD PTR [ecx+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$allocator@_U@std@@V?$_String_val@U?$_Simple_types@_U@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char32_t>,std::_String_val<std::_Simple_types<char32_t> >,1>::_Compressed_pair<std::allocator<char32_t>,std::_String_val<std::_Simple_types<char32_t> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@_S@std@@V?$_String_val@U?$_Simple_types@_S@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@_S@std@@V?$_String_val@U?$_Simple_types@_S@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char16_t>,std::_String_val<std::_Simple_types<char16_t> >,1>::_Compressed_pair<std::allocator<char16_t>,std::_String_val<std::_Simple_types<char16_t> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2322 :     size_type _Mysize = 0; // current length of string

	mov	DWORD PTR [ecx+16], 0

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

	mov	DWORD PTR [ecx+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$allocator@_S@std@@V?$_String_val@U?$_Simple_types@_S@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char16_t>,std::_String_val<std::_Simple_types<char16_t> >,1>::_Compressed_pair<std::allocator<char16_t>,std::_String_val<std::_Simple_types<char16_t> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAV?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z PROC ; std::move<std::allocator<wchar_t> &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAV?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z ENDP ; std::move<std::allocator<wchar_t> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@_W@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@_W@1@@Z PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1336 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2322 :     size_type _Mysize = 0; // current length of string

	mov	DWORD PTR [ecx+16], 0

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

	mov	DWORD PTR [ecx+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1336 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	8
??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@_W@1@@Z ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2322 :     size_type _Mysize = 0; // current length of string

	mov	DWORD PTR [ecx+16], 0

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

	mov	DWORD PTR [ecx+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Convert_size@I@std@@YAII@Z
_TEXT	SEGMENT
??$_Convert_size@I@std@@YAII@Z PROC			; std::_Convert_size<unsigned int>, COMDAT
; __Len$ = ecx

; 922  :     // convert size_t to _Size_type, avoiding truncation
; 923  :     if constexpr (!is_same_v<_Size_type, size_t>) {
; 924  :         if (_Len > (numeric_limits<_Size_type>::max)()) {
; 925  :             _Xlength_error("size_t too long for _Size_type");
; 926  :         }
; 927  :     }
; 928  : 
; 929  :     return static_cast<_Size_type>(_Len);

	mov	eax, ecx

; 930  : }

	ret	0
??$_Convert_size@I@std@@YAII@Z ENDP			; std::_Convert_size<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::move<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1336 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2322 :     size_type _Mysize = 0; // current length of string

	mov	DWORD PTR [ecx+16], 0

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

	mov	DWORD PTR [ecx+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1336 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	8
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2322 :     size_type _Mysize = 0; // current length of string

	mov	DWORD PTR [ecx+16], 0

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

	mov	DWORD PTR [ecx+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PA_U@std@@YAXAAPA_U@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PA_U@std@@YAXAAPA_U@Z PROC		; std::_Destroy_in_place<char32_t *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PA_U@std@@YAXAAPA_U@Z ENDP		; std::_Destroy_in_place<char32_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_02ffc73a80c062ba6e5e6c9f53d514cc>@@PB_U@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEAAV01@IV<lambda_02ffc73a80c062ba6e5e6c9f53d514cc>@@PB_U@Z
_TEXT	SEGMENT
$T10 = -4						; size = 4
__New_size$dead$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$dead$ = 16					; size = 4
??$_Reallocate_for@V<lambda_02ffc73a80c062ba6e5e6c9f53d514cc>@@PB_U@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEAAV01@IV<lambda_02ffc73a80c062ba6e5e6c9f53d514cc>@@PB_U@Z PROC ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Reallocate_for<<lambda_02ffc73a80c062ba6e5e6c9f53d514cc>,char32_t const *>, COMDAT
; _this$ = ecx

; 4471 :     _CONSTEXPR20_CONTAINER basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	eax, 1073741822				; 3ffffffeH

; 4472 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4473 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4474 :         if (_New_size > max_size()) {
; 4475 :             _Xlen_string(); // result too long
; 4476 :         }
; 4477 : 
; 4478 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

	mov	ebx, DWORD PTR [edi+20]

; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	ecx, ebx
	shr	ecx, 1
	sub	eax, ecx
	cmp	ebx, eax
	jbe	SHORT $LN10@Reallocate

; 4460 :             return _Max;

	mov	DWORD PTR $T10[ebp], 1073741822		; 3ffffffeH
	mov	eax, -4					; fffffffcH
	jmp	SHORT $LN62@Reallocate
$LN10@Reallocate:

; 4461 :         }
; 4462 : 
; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [ecx+ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 43   :     return _Left < _Right ? _Right : _Left;

	mov	esi, 7
	cmp	eax, esi
	cmova	esi, eax
	mov	DWORD PTR $T10[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4481 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [esi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 60   :         if (_Count > _Max_possible) {

	cmp	eax, 1073741823				; 3fffffffH
	ja	$LN63@Reallocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	shl	eax, 2

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN21@Reallocate
$LN62@Reallocate:

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	ecx, DWORD PTR [eax+35]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	ecx, eax
	jbe	$LN63@Reallocate

; 79   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	$LN56@Reallocate

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	esi, DWORD PTR [eax+35]
	and	esi, -32				; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [esi-4], eax

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN20@Reallocate
$LN21@Reallocate:

; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

	test	eax, eax
	je	SHORT $LN22@Reallocate

; 79   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 235  :         return _Traits::_Allocate(_Bytes);

	mov	esi, eax
	jmp	SHORT $LN20@Reallocate
$LN22@Reallocate:

; 236  :     }
; 237  : 
; 238  :     return nullptr;

	xor	esi, esi
$LN20@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4490 :         _Mypair._Myval2._Myres  = _New_capacity;

	mov	eax, DWORD PTR $T10[ebp]
	mov	DWORD PTR [edi+16], 5
	mov	DWORD PTR [edi+20], eax

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR ??_C@_2BI@CPCKAEFF@?$AA?$AA?$AAE?$AA?$AA?$AAt?$AA?$AA?$AAh?$AA?$AA?$AAa?$AA?$AA?$AAn@
	movups	XMMWORD PTR [esi], xmm0
	mov	eax, DWORD PTR ??_C@_2BI@CPCKAEFF@?$AA?$AA?$AAE?$AA?$AA?$AAt?$AA?$AA?$AAh?$AA?$AA?$AAa?$AA?$AA?$AAn@+16
	mov	DWORD PTR [esi+16], eax

; 3224 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	DWORD PTR [esi+20], 0

; 4491 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
; 4492 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	ebx, 4
	jb	SHORT $LN3@Reallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR [ebx*4+4]

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN59@Reallocate

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN56@Reallocate

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN59@Reallocate:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN3@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4499 :         return *this;

	mov	DWORD PTR [edi], esi
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 4500 :     }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN56@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN63@Reallocate:

; 131  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN64@Reallocate:
	int	3
??$_Reallocate_for@V<lambda_02ffc73a80c062ba6e5e6c9f53d514cc>@@PB_U@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEAAV01@IV<lambda_02ffc73a80c062ba6e5e6c9f53d514cc>@@PB_U@Z ENDP ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Reallocate_for<<lambda_02ffc73a80c062ba6e5e6c9f53d514cc>,char32_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@_U@std@@YAPA_UPA_U@Z
_TEXT	SEGMENT
??$_Unfancy@_U@std@@YAPA_UPA_U@Z PROC			; std::_Unfancy<char32_t>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@_U@std@@YAPA_UPA_U@Z ENDP			; std::_Unfancy<char32_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PA_S@std@@YAXAAPA_S@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PA_S@std@@YAXAAPA_S@Z PROC		; std::_Destroy_in_place<char16_t *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PA_S@std@@YAXAAPA_S@Z ENDP		; std::_Destroy_in_place<char16_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_493290ea8cd8fcd66ff9f3cecf244fbc>@@PB_S@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEAAV01@IV<lambda_493290ea8cd8fcd66ff9f3cecf244fbc>@@PB_S@Z
_TEXT	SEGMENT
$T10 = -4						; size = 4
__New_size$dead$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$dead$ = 16					; size = 4
??$_Reallocate_for@V<lambda_493290ea8cd8fcd66ff9f3cecf244fbc>@@PB_S@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEAAV01@IV<lambda_493290ea8cd8fcd66ff9f3cecf244fbc>@@PB_S@Z PROC ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Reallocate_for<<lambda_493290ea8cd8fcd66ff9f3cecf244fbc>,char16_t const *>, COMDAT
; _this$ = ecx

; 4471 :     _CONSTEXPR20_CONTAINER basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	eax, 2147483646				; 7ffffffeH

; 4472 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4473 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4474 :         if (_New_size > max_size()) {
; 4475 :             _Xlen_string(); // result too long
; 4476 :         }
; 4477 : 
; 4478 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

	mov	ebx, DWORD PTR [edi+20]

; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	ecx, ebx
	shr	ecx, 1
	sub	eax, ecx
	cmp	ebx, eax
	jbe	SHORT $LN10@Reallocate

; 4460 :             return _Max;

	mov	DWORD PTR $T10[ebp], 2147483646		; 7ffffffeH
	mov	eax, -2					; fffffffeH
	jmp	SHORT $LN62@Reallocate
$LN10@Reallocate:

; 4461 :         }
; 4462 : 
; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [ecx+ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 43   :     return _Left < _Right ? _Right : _Left;

	mov	esi, 7
	cmp	eax, esi
	cmova	esi, eax
	mov	DWORD PTR $T10[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4481 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [esi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 60   :         if (_Count > _Max_possible) {

	cmp	eax, 2147483647				; 7fffffffH
	ja	$LN63@Reallocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	add	eax, eax

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN21@Reallocate
$LN62@Reallocate:

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	ecx, DWORD PTR [eax+35]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	ecx, eax
	jbe	$LN63@Reallocate

; 79   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	$LN56@Reallocate

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	esi, DWORD PTR [eax+35]
	and	esi, -32				; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [esi-4], eax

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN20@Reallocate
$LN21@Reallocate:

; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

	test	eax, eax
	je	SHORT $LN22@Reallocate

; 79   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 235  :         return _Traits::_Allocate(_Bytes);

	mov	esi, eax
	jmp	SHORT $LN20@Reallocate
$LN22@Reallocate:

; 236  :     }
; 237  : 
; 238  :     return nullptr;

	xor	esi, esi
$LN20@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4490 :         _Mypair._Myval2._Myres  = _New_capacity;

	mov	eax, DWORD PTR $T10[ebp]
	mov	DWORD PTR [edi+20], eax
	mov	DWORD PTR [edi+16], 5

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movq	xmm0, QWORD PTR ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@
	movq	QWORD PTR [esi], xmm0
	mov	ax, WORD PTR ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@+8
	mov	WORD PTR [esi+8], ax

; 3224 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	xor	eax, eax
	mov	WORD PTR [esi+10], ax

; 4491 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
; 4492 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	ebx, 8
	jb	SHORT $LN3@Reallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR [ebx*2+2]

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN59@Reallocate

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN56@Reallocate

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN59@Reallocate:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN3@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4499 :         return *this;

	mov	DWORD PTR [edi], esi
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 4500 :     }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN56@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN63@Reallocate:

; 131  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN64@Reallocate:
	int	3
??$_Reallocate_for@V<lambda_493290ea8cd8fcd66ff9f3cecf244fbc>@@PB_S@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEAAV01@IV<lambda_493290ea8cd8fcd66ff9f3cecf244fbc>@@PB_S@Z ENDP ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Reallocate_for<<lambda_493290ea8cd8fcd66ff9f3cecf244fbc>,char16_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@_S@std@@YAPA_SPA_S@Z
_TEXT	SEGMENT
??$_Unfancy@_S@std@@YAPA_SPA_S@Z PROC			; std::_Unfancy<char16_t>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@_S@std@@YAPA_SPA_S@Z ENDP			; std::_Unfancy<char16_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z PROC		; std::_Destroy_in_place<wchar_t *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z ENDP		; std::_Destroy_in_place<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@Z
_TEXT	SEGMENT
__Old$1$ = -4						; size = 4
__New_size$dead$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$dead$ = 16					; size = 4
??$_Reallocate_for@V<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_for<<lambda_03628ca18370b1f44a99b655e704819b>,wchar_t const *>, COMDAT
; _this$ = ecx

; 4471 :     _CONSTEXPR20_CONTAINER basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	eax, 2147483646				; 7ffffffeH

; 4472 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4473 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4474 :         if (_New_size > max_size()) {
; 4475 :             _Xlen_string(); // result too long
; 4476 :         }
; 4477 : 
; 4478 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

	mov	edx, DWORD PTR [edi+20]

; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	ecx, edx
	shr	ecx, 1
	sub	eax, ecx

; 4472 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4473 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4474 :         if (_New_size > max_size()) {
; 4475 :             _Xlen_string(); // result too long
; 4476 :         }
; 4477 : 
; 4478 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

	mov	DWORD PTR __Old$1$[ebp], edx

; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	cmp	edx, eax
	jbe	SHORT $LN10@Reallocate

; 4460 :             return _Max;

	mov	ebx, 2147483646				; 7ffffffeH
	jmp	SHORT $LN8@Reallocate
$LN10@Reallocate:

; 4461 :         }
; 4462 : 
; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [ecx+edx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 43   :     return _Left < _Right ? _Right : _Left;

	mov	ebx, 7
	cmp	eax, ebx
	cmova	ebx, eax
$LN8@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4481 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	xor	ecx, ecx
	mov	eax, ebx
	add	eax, 1
	setb	cl
	neg	ecx
	or	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 60   :         if (_Count > _Max_possible) {

	cmp	ecx, 2147483647				; 7fffffffH
	ja	$LN62@Reallocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	add	ecx, ecx

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN21@Reallocate

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	eax, ecx
	jbe	$LN62@Reallocate

; 79   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	$LN56@Reallocate

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	edx, DWORD PTR __Old$1$[ebp]

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	esi, DWORD PTR [eax+35]
	and	esi, -32				; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [esi-4], eax

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN20@Reallocate
$LN21@Reallocate:

; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

	test	ecx, ecx
	je	SHORT $LN22@Reallocate

; 79   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new

; 235  :         return _Traits::_Allocate(_Bytes);

	mov	edx, DWORD PTR __Old$1$[ebp]

; 79   :         return ::operator new(_Bytes);

	add	esp, 4

; 235  :         return _Traits::_Allocate(_Bytes);

	mov	esi, eax
	jmp	SHORT $LN20@Reallocate
$LN22@Reallocate:

; 236  :     }
; 237  : 
; 238  :     return nullptr;

	xor	esi, esi
$LN20@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4489 :         _Mypair._Myval2._Mysize = _New_size;

	mov	DWORD PTR [edi+16], 5

; 4490 :         _Mypair._Myval2._Myres  = _New_capacity;

	mov	DWORD PTR [edi+20], ebx

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movq	xmm0, QWORD PTR ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@
	movq	QWORD PTR [esi], xmm0
	mov	ax, WORD PTR ??_C@_1M@MIBHDLFD@?$AAE?$AAt?$AAh?$AAa?$AAn@+8
	mov	WORD PTR [esi+8], ax

; 3224 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	xor	eax, eax
	mov	WORD PTR [esi+10], ax

; 4491 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
; 4492 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	edx, 8
	jb	SHORT $LN3@Reallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR [edx*2+2]

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN59@Reallocate

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN56@Reallocate

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN59@Reallocate:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN3@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4499 :         return *this;

	mov	DWORD PTR [edi], esi
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 4500 :     }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN56@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN62@Reallocate:

; 131  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN63@Reallocate:
	int	3
??$_Reallocate_for@V<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_for<<lambda_03628ca18370b1f44a99b655e704819b>,wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Construct_in_place@PA_WAAPA_W@std@@YAXAAPA_W0@Z
_TEXT	SEGMENT
??$_Construct_in_place@PA_WAAPA_W@std@@YAXAAPA_W0@Z PROC ; std::_Construct_in_place<wchar_t *,wchar_t * &>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 142  :     is_nothrow_constructible_v<_Ty, _Types...>) {

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 143  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 144  :     if (_STD is_constant_evaluated()) {
; 145  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 146  :     } else
; 147  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 148  :     {
; 149  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 150  :     }
; 151  : }

	ret	0
??$_Construct_in_place@PA_WAAPA_W@std@@YAXAAPA_W0@Z ENDP ; std::_Construct_in_place<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@_W@std@@YAPA_WPA_W@Z
_TEXT	SEGMENT
??$_Unfancy@_W@std@@YAPA_WPA_W@Z PROC			; std::_Unfancy<wchar_t>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@_W@std@@YAPA_WPA_W@Z ENDP			; std::_Unfancy<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__Old$1$ = -8						; size = 4
_<_Args_0>$GSCopy$1$ = -4				; size = 4
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 4471 :     _CONSTEXPR20_CONTAINER basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	ebx
	mov	DWORD PTR _<_Args_0>$GSCopy$1$[ebp], eax
	mov	ebx, ecx

; 4472 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4473 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4474 :         if (_New_size > max_size()) {

	mov	eax, DWORD PTR __New_size$[ebp]
	push	edi
	cmp	eax, 2147483647				; 7fffffffH
	ja	$LN61@Reallocate

; 4476 :         }
; 4477 : 
; 4478 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

	mov	ecx, DWORD PTR [ebx+20]
	push	esi

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	esi, eax

; 4476 :         }
; 4477 : 
; 4478 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

	mov	DWORD PTR __Old$1$[ebp], ecx

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	esi, 15					; 0000000fH
	cmp	esi, 2147483647				; 7fffffffH

; 4455 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN9@Reallocate

; 4456 :             return _Max;

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN8@Reallocate
$LN9@Reallocate:

; 4457 :         }
; 4458 : 
; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	edx, ecx
	mov	eax, 2147483647				; 7fffffffH
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN10@Reallocate

; 4460 :             return _Max;

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN8@Reallocate
$LN10@Reallocate:

; 4461 :         }
; 4462 : 
; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 43   :     return _Left < _Right ? _Right : _Left;

	cmp	esi, eax
	cmovb	esi, eax
$LN8@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4481 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	xor	ecx, ecx
	mov	eax, esi
	add	eax, 1
	setb	cl
	neg	ecx
	or	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN17@Reallocate

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	eax, ecx
	jbe	$LN62@Reallocate

; 79   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	SHORT $LN53@Reallocate

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	edi, DWORD PTR [eax+35]
	and	edi, -32				; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [edi-4], eax

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN16@Reallocate
$LN17@Reallocate:

; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

	test	ecx, ecx
	je	SHORT $LN18@Reallocate

; 79   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 235  :         return _Traits::_Allocate(_Bytes);

	mov	edi, eax
	jmp	SHORT $LN16@Reallocate
$LN18@Reallocate:

; 236  :     }
; 237  : 
; 238  :     return nullptr;

	xor	edi, edi
$LN16@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4489 :         _Mypair._Myval2._Mysize = _New_size;

	mov	eax, DWORD PTR __New_size$[ebp]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	push	eax
	push	DWORD PTR _<_Args_0>$GSCopy$1$[ebp]

; 4489 :         _Mypair._Myval2._Mysize = _New_size;

	mov	DWORD PTR [ebx+16], eax

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	push	edi

; 4490 :         _Mypair._Myval2._Myres  = _New_capacity;

	mov	DWORD PTR [ebx+20], esi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	_memcpy

; 3224 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	eax, DWORD PTR __New_size$[ebp]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	add	esp, 12					; 0000000cH

; 4491 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
; 4492 :         if (_BUF_SIZE <= _Old_capacity) {

	mov	ecx, DWORD PTR __Old$1$[ebp]

; 3224 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	BYTE PTR [edi+eax], 0

; 4491 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
; 4492 :         if (_BUF_SIZE <= _Old_capacity) {

	pop	esi
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN3@Reallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4493 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

	inc	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN56@Reallocate

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN53@Reallocate

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN56@Reallocate:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN3@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4499 :         return *this;

	mov	DWORD PTR [ebx], edi
	mov	eax, ebx
	pop	edi
	pop	ebx

; 4500 :     }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN53@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN61@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4475 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
$LN62@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 131  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN59@Reallocate:
	int	3
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z
_TEXT	SEGMENT
__Old$1$ = -12						; size = 4
tv467 = -8						; size = 4
__New_size$1$ = -8					; size = 4
tv466 = -4						; size = 4
__Old_size$1$ = -4					; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$dead$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>, COMDAT
; _this$ = ecx

; 4504 :         const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	mov	ebx, ecx

; 4505 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4506 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4507 :         auto& _My_data            = _Mypair._Myval2;
; 4508 :         const size_type _Old_size = _My_data._Mysize;
; 4509 :         if (max_size() - _Old_size < _Size_increase) {

	mov	ecx, 2147483647				; 7fffffffH
	mov	eax, ecx
	push	esi
	mov	esi, DWORD PTR __Size_increase$[ebp]
	mov	edx, DWORD PTR [ebx+16]
	sub	eax, edx
	mov	DWORD PTR __Old_size$1$[ebp], edx
	push	edi
	cmp	eax, esi
	jb	$LN69@Reallocate

; 4514 :         const size_type _Old_capacity = _My_data._Myres;

	mov	edi, DWORD PTR [ebx+20]
	lea	eax, DWORD PTR [edx+esi]

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	esi, eax

; 4511 :         }
; 4512 : 
; 4513 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	DWORD PTR __New_size$1$[ebp], eax

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	esi, 15					; 0000000fH

; 4514 :         const size_type _Old_capacity = _My_data._Myres;

	mov	DWORD PTR __Old$1$[ebp], edi

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	esi, ecx

; 4455 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN9@Reallocate

; 4456 :             return _Max;

	mov	esi, ecx
	jmp	SHORT $LN8@Reallocate
$LN9@Reallocate:

; 4457 :         }
; 4458 : 
; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	eax, edi
	shr	eax, 1
	sub	ecx, eax
	cmp	edi, ecx
	jbe	SHORT $LN10@Reallocate

; 4460 :             return _Max;

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN8@Reallocate
$LN10@Reallocate:

; 4461 :         }
; 4462 : 
; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

	add	eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 43   :     return _Left < _Right ? _Right : _Left;

	cmp	esi, eax
	cmovb	esi, eax
$LN8@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4517 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	xor	ecx, ecx
	mov	eax, esi
	add	eax, 1
	setb	cl
	neg	ecx
	or	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN17@Reallocate

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	eax, ecx
	jbe	$LN70@Reallocate

; 79   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	$LN55@Reallocate

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	edx, DWORD PTR __Old_size$1$[ebp]

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	edi, DWORD PTR [eax+35]
	and	edi, -32				; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [edi-4], eax

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN16@Reallocate
$LN17@Reallocate:

; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

	test	ecx, ecx
	je	SHORT $LN18@Reallocate

; 79   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new

; 235  :         return _Traits::_Allocate(_Bytes);

	mov	edx, DWORD PTR __Old_size$1$[ebp]

; 79   :         return ::operator new(_Bytes);

	add	esp, 4

; 235  :         return _Traits::_Allocate(_Bytes);

	mov	edi, eax
	jmp	SHORT $LN16@Reallocate
$LN18@Reallocate:

; 236  :     }
; 237  : 
; 238  :     return nullptr;

	xor	edi, edi
$LN16@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4525 :         _My_data._Mysize      = _New_size;

	mov	eax, DWORD PTR __New_size$1$[ebp]
	mov	DWORD PTR [ebx+16], eax

; 4526 :         _My_data._Myres       = _New_capacity;
; 4527 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	eax, DWORD PTR _<_Args_1>$[ebp]
	mov	DWORD PTR [ebx+20], esi
	lea	esi, DWORD PTR [edi+edx]
	add	eax, esi
	mov	DWORD PTR tv467[ebp], esi

; 4528 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	DWORD PTR __Old$1$[ebp], 16		; 00000010H
	mov	DWORD PTR tv466[ebp], eax
	push	edx
	jb	SHORT $LN3@Reallocate

; 4529 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	esi, DWORD PTR [ebx]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	push	esi
	push	edi
	call	_memcpy
	push	DWORD PTR _<_Args_1>$[ebp]
	push	OFFSET ??_C@_02PLJDPFIO@00@
	push	DWORD PTR tv467[ebp]
	call	_memcpy

; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	eax, DWORD PTR tv466[ebp]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	add	esp, 24					; 00000018H

; 4530 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4531 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	ecx, DWORD PTR __Old$1$[ebp]
	inc	ecx

; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN58@Reallocate

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [esi-4]
	add	ecx, 35					; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	esi, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [esi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN55@Reallocate

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	esi, edx
$LN58@Reallocate:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4538 :         return *this;

	mov	DWORD PTR [ebx], edi
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx

; 4539 :     }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN55@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN3@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	push	ebx
	push	edi
	call	_memcpy
	push	DWORD PTR _<_Args_1>$[ebp]
	push	OFFSET ??_C@_02PLJDPFIO@00@
	push	esi
	call	_memcpy

; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	eax, DWORD PTR tv466[ebp]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	add	esp, 24					; 00000018H

; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [eax], 0

; 4538 :         return *this;

	mov	eax, ebx
	mov	DWORD PTR [ebx], edi
	pop	edi
	pop	esi
	pop	ebx

; 4539 :     }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN69@Reallocate:

; 4510 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
$LN70@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 131  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN67@Reallocate:
	int	3
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 142  :     is_nothrow_constructible_v<_Ty, _Types...>) {

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 143  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 144  :     if (_STD is_constant_evaluated()) {
; 145  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 146  :     } else
; 147  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 148  :     {
; 149  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 150  :     }
; 151  : }

	ret	0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Construct_in_place@PADAAPAD@std@@YAXAAPAD0@Z
_TEXT	SEGMENT
??$_Construct_in_place@PADAAPAD@std@@YAXAAPAD0@Z PROC	; std::_Construct_in_place<char *,char * &>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 142  :     is_nothrow_constructible_v<_Ty, _Types...>) {

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 143  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 144  :     if (_STD is_constant_evaluated()) {
; 145  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 146  :     } else
; 147  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 148  :     {
; 149  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 150  :     }
; 151  : }

	ret	0
??$_Construct_in_place@PADAAPAD@std@@YAXAAPAD0@Z ENDP	; std::_Construct_in_place<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT
; __Ptr$ = ecx
; __Bytes$ = edx

; 243  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 244  : #ifdef __cpp_lib_constexpr_dynamic_alloc // TRANSITION, GH-1532
; 245  :     if (_STD is_constant_evaluated()) {
; 246  :         ::operator delete(_Ptr);
; 247  :     } else
; 248  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN13@Deallocate

; 147  :     _Bytes += _Non_user_size;

	push	esi

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	esi, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	ecx, esi

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [ecx-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN10@Deallocate

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	ecx, esi
	pop	esi
$LN13@Deallocate:

; 252  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 253  :         }
; 254  : #endif // defined(_M_IX86) || defined(_M_X64)
; 255  :         ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 256  :     }
; 257  : }

	ret	0
$LN10@Deallocate:

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN15@Deallocate:
	int	3
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@_W@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@_W@std@@@0@AAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@_W@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z
_TEXT	SEGMENT
??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z PROC ; std::_Construct_in_place<wchar_t *,wchar_t * const &>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 142  :     is_nothrow_constructible_v<_Ty, _Types...>) {

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 143  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 144  :     if (_STD is_constant_evaluated()) {
; 145  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 146  :     } else
; 147  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 148  :     {
; 149  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 150  :     }
; 151  : }

	ret	0
??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z ENDP ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@_W@std@@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@_W@std@@@0@ABV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > const >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@$$CBV?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@_W@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > const >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YAII@Z
_TEXT	SEGMENT
??$_Get_size_of_n@$00@std@@YAII@Z PROC			; std::_Get_size_of_n<1>, COMDAT
; __Count$ = ecx

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 57   : 
; 58   :     if constexpr (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 60   :         if (_Count > _Max_possible) {
; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	mov	eax, ecx

; 66   : }

	ret	0
??$_Get_size_of_n@$00@std@@YAII@Z ENDP			; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT
; __Bytes$ = ecx

; 222  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 223  : #if defined(_M_IX86) || defined(_M_X64)
; 224  : #ifdef __cpp_lib_constexpr_dynamic_alloc // TRANSITION, GH-1532
; 225  :     if (!_STD is_constant_evaluated())
; 226  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 227  :     {
; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN2@Allocate

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	eax, ecx
	jbe	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length

; 79   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new

; 134  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 79   :         return ::operator new(_Bytes);

	add	esp, 4

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN11@Allocate

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 239  : }

	ret	0
$LN11@Allocate:

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2@Allocate:

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

	test	ecx, ecx
	je	SHORT $LN3@Allocate

; 79   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 239  : }

	ret	0
$LN3@Allocate:

; 235  :         return _Traits::_Allocate(_Bytes);
; 236  :     }
; 237  : 
; 238  :     return nullptr;

	xor	eax, eax

; 239  : }

	ret	0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_2fb699096920f2dc628cb0826b07831d>@@PB_WI@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_2fb699096920f2dc628cb0826b07831d>@@PB_WI@Z
_TEXT	SEGMENT
tv497 = -16						; size = 4
__Old$1$ = -12						; size = 4
tv496 = -8						; size = 4
__New_size$1$ = -8					; size = 4
tv495 = -4						; size = 4
__Old_size$1$ = -4					; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$dead$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
??$_Reallocate_grow_by@V<lambda_2fb699096920f2dc628cb0826b07831d>@@PB_WI@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_2fb699096920f2dc628cb0826b07831d>@@PB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_2fb699096920f2dc628cb0826b07831d>,wchar_t const *,unsigned int>, COMDAT
; _this$ = ecx

; 4504 :         const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 4505 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4506 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4507 :         auto& _My_data            = _Mypair._Myval2;
; 4508 :         const size_type _Old_size = _My_data._Mysize;
; 4509 :         if (max_size() - _Old_size < _Size_increase) {

	mov	edx, DWORD PTR __Size_increase$[ebp]
	push	ebx
	mov	ebx, ecx
	mov	ecx, 2147483646				; 7ffffffeH
	push	esi
	mov	eax, ecx
	push	edi
	mov	esi, DWORD PTR [ebx+16]
	sub	eax, esi
	mov	DWORD PTR __Old_size$1$[ebp], esi
	cmp	eax, edx
	jb	$LN73@Reallocate

; 4511 :         }
; 4512 : 
; 4513 :         const size_type _New_size     = _Old_size + _Size_increase;

	lea	eax, DWORD PTR [esi+edx]

; 4514 :         const size_type _Old_capacity = _My_data._Myres;

	mov	esi, DWORD PTR [ebx+20]

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	edi, eax

; 4511 :         }
; 4512 : 
; 4513 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	DWORD PTR __New_size$1$[ebp], eax

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	edi, 7

; 4514 :         const size_type _Old_capacity = _My_data._Myres;

	mov	DWORD PTR __Old$1$[ebp], esi

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	edi, ecx

; 4455 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN9@Reallocate

; 4456 :             return _Max;

	mov	edi, ecx
	jmp	SHORT $LN8@Reallocate
$LN9@Reallocate:

; 4457 :         }
; 4458 : 
; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	eax, esi
	shr	eax, 1
	sub	ecx, eax
	cmp	esi, ecx
	jbe	SHORT $LN10@Reallocate

; 4460 :             return _Max;

	mov	edi, 2147483646				; 7ffffffeH
	jmp	SHORT $LN8@Reallocate
$LN10@Reallocate:

; 4461 :         }
; 4462 : 
; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

	add	eax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 43   :     return _Left < _Right ? _Right : _Left;

	cmp	edi, eax
	cmovb	edi, eax
$LN8@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4517 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	xor	ecx, ecx
	mov	eax, edi
	add	eax, 1
	setb	cl
	neg	ecx
	or	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 60   :         if (_Count > _Max_possible) {

	cmp	ecx, 2147483647				; 7fffffffH
	ja	$LN70@Reallocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	add	ecx, ecx

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN21@Reallocate

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	eax, ecx
	jbe	$LN70@Reallocate

; 79   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	$LN58@Reallocate

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	esi, DWORD PTR [eax+35]
	and	esi, -32				; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [esi-4], eax

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN20@Reallocate
$LN21@Reallocate:

; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

	test	ecx, ecx
	je	SHORT $LN22@Reallocate

; 79   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 235  :         return _Traits::_Allocate(_Bytes);

	mov	esi, eax
	jmp	SHORT $LN20@Reallocate
$LN22@Reallocate:

; 236  :     }
; 237  : 
; 238  :     return nullptr;

	xor	esi, esi
$LN20@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4525 :         _My_data._Mysize      = _New_size;

	mov	eax, DWORD PTR __New_size$1$[ebp]
	mov	DWORD PTR [ebx+16], eax

; 4526 :         _My_data._Myres       = _New_capacity;
; 4527 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	eax, DWORD PTR __Old_size$1$[ebp]
	mov	DWORD PTR [ebx+20], edi
	lea	ecx, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _<_Args_1>$[ebp]
	lea	edx, DWORD PTR [ecx+esi]
	mov	DWORD PTR tv496[ebp], edx

; 4528 :         if (_BUF_SIZE <= _Old_capacity) {

	push	ecx
	lea	edi, DWORD PTR [eax+eax]
	add	eax, DWORD PTR __Old_size$1$[ebp]
	cmp	DWORD PTR __Old$1$[ebp], 8
	mov	DWORD PTR tv497[ebp], edi
	lea	eax, DWORD PTR [esi+eax*2]
	mov	DWORD PTR tv495[ebp], eax
	jb	SHORT $LN3@Reallocate

; 4529 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	edi, DWORD PTR [ebx]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	push	edi
	push	esi
	call	_memcpy
	push	DWORD PTR tv497[ebp]
	push	OFFSET ??_C@_15CNAMGDF@?$AA0?$AA1@
	push	DWORD PTR tv496[ebp]
	call	_memcpy

; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	eax, DWORD PTR tv495[ebp]
	xor	ecx, ecx

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	add	esp, 24					; 00000018H

; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	WORD PTR [eax], cx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR __Old$1$[ebp]
	lea	ecx, DWORD PTR [eax*2+2]

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN61@Reallocate

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [edi-4]
	add	ecx, 35					; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	edi, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [edi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN58@Reallocate

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	edi, edx
$LN61@Reallocate:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4538 :         return *this;

	mov	DWORD PTR [ebx], esi
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx

; 4539 :     }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN58@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN3@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	push	ebx
	push	esi
	call	_memcpy
	push	edi
	push	OFFSET ??_C@_15CNAMGDF@?$AA0?$AA1@
	push	DWORD PTR tv496[ebp]
	call	_memcpy

; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	eax, DWORD PTR tv495[ebp]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	add	esp, 24					; 00000018H

; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	xor	ecx, ecx
	mov	WORD PTR [eax], cx

; 4538 :         return *this;

	mov	eax, ebx
	pop	edi
	mov	DWORD PTR [ebx], esi
	pop	esi
	pop	ebx

; 4539 :     }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN70@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 131  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN73@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4510 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
$LN71@Reallocate:
	int	3
??$_Reallocate_grow_by@V<lambda_2fb699096920f2dc628cb0826b07831d>@@PB_WI@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_2fb699096920f2dc628cb0826b07831d>@@PB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_2fb699096920f2dc628cb0826b07831d>,wchar_t const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Get_size_of_n@$01@std@@YAII@Z
_TEXT	SEGMENT
??$_Get_size_of_n@$01@std@@YAII@Z PROC			; std::_Get_size_of_n<2>, COMDAT
; __Count$ = ecx

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 57   : 
; 58   :     if constexpr (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 60   :         if (_Count > _Max_possible) {

	cmp	ecx, 2147483647				; 7fffffffH
	ja	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	lea	eax, DWORD PTR [ecx+ecx]

; 66   : }

	ret	0
??$_Get_size_of_n@$01@std@@YAII@Z ENDP			; std::_Get_size_of_n<2>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@ABEII@Z
_TEXT	SEGMENT
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@ABEII@Z PROC ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4466 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Requested) const noexcept {

	push	ebp
	mov	ebp, esp

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	edx, DWORD PTR __Requested$[ebp]

; 4455 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	mov	eax, 1073741822				; 3ffffffeH
	or	edx, 3

; 4466 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Requested) const noexcept {

	push	esi

; 4467 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	esi, DWORD PTR [ecx+20]

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	edx, eax

; 4455 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN3@Calculate_

; 4456 :             return _Max;
; 4457 :         }
; 4458 : 
; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	ecx, esi
	shr	ecx, 1
	sub	eax, ecx
	cmp	esi, eax
	jbe	SHORT $LN5@Calculate_

; 4467 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	eax, 1073741822				; 3ffffffeH
	pop	esi

; 4468 :     }

	pop	ebp
	ret	4
$LN5@Calculate_:

; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

	add	ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 43   :     return _Left < _Right ? _Right : _Left;

	cmp	edx, ecx
	cmovb	edx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4467 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	eax, edx
$LN3@Calculate_:
	pop	esi

; 4468 :     }

	pop	ebp
	ret	4
?_Calculate_growth@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@ABEII@Z ENDP ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?max_size@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QBEIXZ PROC ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::max_size, COMDAT
; _this$dead$ = ecx

; 3910 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());
; 3911 :         const size_type _Storage_max = // can always store small string
; 3912 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 3913 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	eax, 1073741822				; 3ffffffeH

; 3914 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3915 :         );
; 3916 :     }

	ret	0
?max_size@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QBEIXZ ENDP ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?append@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAEAAV12@QB_U@Z
_TEXT	SEGMENT
tv237 = -4						; size = 4
$T5 = -4						; size = 1
__Ptr$dead$ = 8						; size = 4
?append@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAEAAV12@QB_U@Z PROC ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::append, COMDAT
; _this$ = ecx

; 3140 :     _CONSTEXPR20_CONTAINER basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 3141 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	eax, OFFSET ??_C@_2M@JLEBFLAK@?$AA?$AA?$AA0?$AA?$AA?$AA3@

; 144  :         size_t _Count = 0;

	xor	ecx, ecx
	npad	2
$LL4@append:

; 145  :         while (*_First != _Elem()) {
; 146  :             ++_Count;
; 147  :             ++_First;

	lea	eax, DWORD PTR [eax+4]
	inc	ecx
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LL4@append

; 3121 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	eax, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [esi+16]
	sub	eax, edx
	cmp	ecx, eax
	ja	SHORT $LN8@append

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [esi+20], 4

; 3122 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [edx+ecx]
	push	edi
	mov	DWORD PTR tv237[ebp], eax

; 2263 :         value_type* _Result = _Bx._Buf;

	mov	edi, esi

; 3122 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	DWORD PTR [esi+16], eax

; 2264 :         if (_Large_string_engaged()) {

	jb	SHORT $LN11@append

; 2265 :             _Result = _Unfancy(_Bx._Ptr);

	mov	edi, DWORD PTR [esi]
$LN11@append:

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	shl	ecx, 2
	push	ecx

; 3124 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	lea	ecx, DWORD PTR [edi+edx*4]

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	push	OFFSET ??_C@_2M@JLEBFLAK@?$AA?$AA?$AA0?$AA?$AA?$AA3@
	push	ecx
	call	_memmove

; 3125 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	eax, DWORD PTR tv237[ebp]

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	add	esp, 12					; 0000000cH

; 3125 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	DWORD PTR [edi+eax*4], 0

; 3141 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	eax, esi
	pop	edi
	pop	esi

; 3142 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN8@append:

; 3129 :         return _Reallocate_grow_by(

	push	ecx
	push	ecx
	mov	BYTE PTR $T5[ebp], 0
	push	DWORD PTR $T5[ebp]
	push	ecx
	mov	ecx, esi
	call	??$_Reallocate_grow_by@V<lambda_aabcc5df0dcdbd223414bc3ba38ad6d9>@@PB_UI@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEAAV01@IV<lambda_aabcc5df0dcdbd223414bc3ba38ad6d9>@@PB_UI@Z ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Reallocate_grow_by<<lambda_aabcc5df0dcdbd223414bc3ba38ad6d9>,char32_t const *,unsigned int>
	pop	esi

; 3142 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?append@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAEAAV12@QB_U@Z ENDP ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >, COMDAT
; _this$ = ecx

; 2571 :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

	push	ebp
	mov	ebp, esp

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	eax, DWORD PTR __Right$[ebp]

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [ecx], 0

; 2322 :     size_type _Mysize = 0; // current length of string

	mov	DWORD PTR [ecx+16], 0

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

	mov	DWORD PTR [ecx+20], 0

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 4562 :         _My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 3

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	DWORD PTR [eax], 0

; 2572 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2573 :         _Take_contents(_Right);
; 2574 :     }

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@_U@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@_U@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char32_t> >::_String_val<std::_Simple_types<char32_t> >, COMDAT
; _this$ = ecx

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [ecx], 0

; 2251 :     _CONSTEXPR20_CONTAINER _String_val() noexcept : _Bx() {}

	mov	eax, ecx

; 2314 : 
; 2315 :         _CONSTEXPR20_CONTAINER ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2316 : 
; 2317 :         value_type _Buf[_BUF_SIZE];
; 2318 :         pointer _Ptr;
; 2319 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2320 :     } _Bx;
; 2321 : 
; 2322 :     size_type _Mysize = 0; // current length of string

	mov	DWORD PTR [ecx+16], 0

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

	mov	DWORD PTR [ecx+20], 0
	ret	0
??0?$_String_val@U?$_Simple_types@_U@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char32_t> >::_String_val<std::_Simple_types<char32_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@_U@std@@QAEPA_UI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@_U@std@@QAEPA_UI@Z PROC		; std::allocator<char32_t>::allocate, COMDAT
; _this$dead$ = ecx

; 800  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

	push	ebp
	mov	ebp, esp

; 60   :         if (_Count > _Max_possible) {

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, 1073741823				; 3fffffffH
	ja	SHORT $LN27@allocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	shl	eax, 2

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN8@allocate

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	ecx, DWORD PTR [eax+35]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	ecx, eax
	jbe	SHORT $LN27@allocate

; 79   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new

; 134  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 79   :         return ::operator new(_Bytes);

	add	esp, 4

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN17@allocate

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 801  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 802  :     }

	pop	ebp
	ret	4
$LN17@allocate:

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN8@allocate:

; 234  :     if (_Bytes != 0) {

	test	eax, eax
	je	SHORT $LN9@allocate

; 79   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 801  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 802  :     }

	pop	ebp
	ret	4
$LN9@allocate:

; 238  :     return nullptr;

	xor	eax, eax

; 801  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 802  :     }

	pop	ebp
	ret	4
$LN27@allocate:

; 131  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN28@allocate:
	int	3
?allocate@?$allocator@_U@std@@QAEPA_UI@Z ENDP		; std::allocator<char32_t>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@_U@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@_U@std@@QAE@XZ PROC			; std::allocator<char32_t>::allocator<char32_t>, COMDAT
; _this$ = ecx

; 787  :     constexpr allocator() noexcept {}

	mov	eax, ecx
	ret	0
??0?$allocator@_U@std@@QAE@XZ ENDP			; std::allocator<char32_t>::allocator<char32_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@ABEII@Z
_TEXT	SEGMENT
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@ABEII@Z PROC ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4466 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Requested) const noexcept {

	push	ebp
	mov	ebp, esp

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	edx, DWORD PTR __Requested$[ebp]

; 4455 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	mov	eax, 2147483646				; 7ffffffeH
	or	edx, 7

; 4466 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Requested) const noexcept {

	push	esi

; 4467 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	esi, DWORD PTR [ecx+20]

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	edx, eax

; 4455 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN3@Calculate_

; 4456 :             return _Max;
; 4457 :         }
; 4458 : 
; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	ecx, esi
	shr	ecx, 1
	sub	eax, ecx
	cmp	esi, eax
	jbe	SHORT $LN5@Calculate_

; 4467 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	eax, 2147483646				; 7ffffffeH
	pop	esi

; 4468 :     }

	pop	ebp
	ret	4
$LN5@Calculate_:

; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

	add	ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 43   :     return _Left < _Right ? _Right : _Left;

	cmp	edx, ecx
	cmovb	edx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4467 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	eax, edx
$LN3@Calculate_:
	pop	esi

; 4468 :     }

	pop	ebp
	ret	4
?_Calculate_growth@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@ABEII@Z ENDP ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?max_size@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QBEIXZ PROC ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::max_size, COMDAT
; _this$dead$ = ecx

; 3910 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());
; 3911 :         const size_type _Storage_max = // can always store small string
; 3912 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 3913 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	eax, 2147483646				; 7ffffffeH

; 3914 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3915 :         );
; 3916 :     }

	ret	0
?max_size@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QBEIXZ ENDP ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?append@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAEAAV12@QB_S@Z
_TEXT	SEGMENT
$T4 = -4						; size = 1
__Ptr$dead$ = 8						; size = 4
?append@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAEAAV12@QB_S@Z PROC ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::append, COMDAT
; _this$ = ecx

; 3140 :     _CONSTEXPR20_CONTAINER basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3121 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	eax, DWORD PTR [ecx+20]
	mov	edx, DWORD PTR [ecx+16]
	sub	eax, edx
	cmp	eax, 2
	jb	SHORT $LN4@append

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 8

; 2263 :         value_type* _Result = _Bx._Buf;

	mov	eax, ecx

; 3122 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	push	edi
	lea	edi, DWORD PTR [edx+2]
	mov	DWORD PTR [ecx+16], edi

; 2264 :         if (_Large_string_engaged()) {

	jb	SHORT $LN7@append

; 2265 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [ecx]
$LN7@append:

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	DWORD PTR [eax+edx*2], 3276848		; 00320030H

; 3125 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	xor	edx, edx
	mov	WORD PTR [eax+edi*2], dx

; 3141 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	eax, ecx
	pop	edi

; 3142 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN4@append:

; 3129 :         return _Reallocate_grow_by(

	push	2
	push	ecx
	mov	BYTE PTR $T4[ebp], 0
	push	DWORD PTR $T4[ebp]
	push	2
	call	??$_Reallocate_grow_by@V<lambda_98ae700cc7810ca9f391bc310db97391>@@PB_SI@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEAAV01@IV<lambda_98ae700cc7810ca9f391bc310db97391>@@PB_SI@Z ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Reallocate_grow_by<<lambda_98ae700cc7810ca9f391bc310db97391>,char16_t const *,unsigned int>

; 3142 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?append@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAEAAV12@QB_S@Z ENDP ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >, COMDAT
; _this$ = ecx

; 2571 :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

	push	ebp
	mov	ebp, esp

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	eax, DWORD PTR __Right$[ebp]

; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	xor	edx, edx

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [ecx], 0

; 2322 :     size_type _Mysize = 0; // current length of string

	mov	DWORD PTR [ecx+16], 0

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

	mov	DWORD PTR [ecx+20], 0

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 4562 :         _My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 7

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	WORD PTR [eax], dx

; 2572 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2573 :         _Take_contents(_Right);
; 2574 :     }

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@_S@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@_S@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char16_t> >::_String_val<std::_Simple_types<char16_t> >, COMDAT
; _this$ = ecx

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [ecx], 0

; 2251 :     _CONSTEXPR20_CONTAINER _String_val() noexcept : _Bx() {}

	mov	eax, ecx

; 2314 : 
; 2315 :         _CONSTEXPR20_CONTAINER ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2316 : 
; 2317 :         value_type _Buf[_BUF_SIZE];
; 2318 :         pointer _Ptr;
; 2319 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2320 :     } _Bx;
; 2321 : 
; 2322 :     size_type _Mysize = 0; // current length of string

	mov	DWORD PTR [ecx+16], 0

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

	mov	DWORD PTR [ecx+20], 0
	ret	0
??0?$_String_val@U?$_Simple_types@_S@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char16_t> >::_String_val<std::_Simple_types<char16_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@_S@std@@QAEPA_SI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@_S@std@@QAEPA_SI@Z PROC		; std::allocator<char16_t>::allocate, COMDAT
; _this$dead$ = ecx

; 800  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

	push	ebp
	mov	ebp, esp

; 60   :         if (_Count > _Max_possible) {

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, 2147483647				; 7fffffffH
	ja	SHORT $LN27@allocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	add	eax, eax

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN8@allocate

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	ecx, DWORD PTR [eax+35]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	ecx, eax
	jbe	SHORT $LN27@allocate

; 79   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new

; 134  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 79   :         return ::operator new(_Bytes);

	add	esp, 4

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN17@allocate

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 801  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 802  :     }

	pop	ebp
	ret	4
$LN17@allocate:

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN8@allocate:

; 234  :     if (_Bytes != 0) {

	test	eax, eax
	je	SHORT $LN9@allocate

; 79   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 801  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 802  :     }

	pop	ebp
	ret	4
$LN9@allocate:

; 238  :     return nullptr;

	xor	eax, eax

; 801  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 802  :     }

	pop	ebp
	ret	4
$LN27@allocate:

; 131  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN28@allocate:
	int	3
?allocate@?$allocator@_S@std@@QAEPA_SI@Z ENDP		; std::allocator<char16_t>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@_S@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@_S@std@@QAE@XZ PROC			; std::allocator<char16_t>::allocator<char16_t>, COMDAT
; _this$ = ecx

; 787  :     constexpr allocator() noexcept {}

	mov	eax, ecx
	ret	0
??0?$allocator@_S@std@@QAE@XZ ENDP			; std::allocator<char16_t>::allocator<char16_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEII@Z
_TEXT	SEGMENT
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEII@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4466 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Requested) const noexcept {

	push	ebp
	mov	ebp, esp

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	edx, DWORD PTR __Requested$[ebp]

; 4455 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	mov	eax, 2147483646				; 7ffffffeH
	or	edx, 7

; 4466 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Requested) const noexcept {

	push	esi

; 4467 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	esi, DWORD PTR [ecx+20]

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	edx, eax

; 4455 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN3@Calculate_

; 4456 :             return _Max;
; 4457 :         }
; 4458 : 
; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	ecx, esi
	shr	ecx, 1
	sub	eax, ecx
	cmp	esi, eax
	jbe	SHORT $LN5@Calculate_

; 4467 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	eax, 2147483646				; 7ffffffeH
	pop	esi

; 4468 :     }

	pop	ebp
	ret	4
$LN5@Calculate_:

; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

	add	ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 43   :     return _Left < _Right ? _Right : _Left;

	cmp	edx, ecx
	cmovb	edx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4467 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	eax, edx
$LN3@Calculate_:
	pop	esi

; 4468 :     }

	pop	ebp
	ret	4
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEII@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data, COMDAT
; _this$ = ecx

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 8

; 2273 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@data

; 3892 :         return _Mypair._Myval2._Myptr();

	mov	eax, DWORD PTR [ecx]

; 3893 :     }

	ret	0
$LN8@data:

; 3892 :         return _Mypair._Myval2._Myptr();

	mov	eax, ecx

; 3893 :     }

	ret	0
?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_W@Z
_TEXT	SEGMENT
$T4 = -4						; size = 1
__Ptr$dead$ = 8						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 3140 :     _CONSTEXPR20_CONTAINER basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3121 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	eax, DWORD PTR [ecx+20]
	mov	edx, DWORD PTR [ecx+16]
	sub	eax, edx
	cmp	eax, 2
	jb	SHORT $LN4@append

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 8

; 2263 :         value_type* _Result = _Bx._Buf;

	mov	eax, ecx

; 3122 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	push	edi
	lea	edi, DWORD PTR [edx+2]
	mov	DWORD PTR [ecx+16], edi

; 2264 :         if (_Large_string_engaged()) {

	jb	SHORT $LN7@append

; 2265 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR [ecx]
$LN7@append:

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	DWORD PTR [eax+edx*2], 3211312		; 00310030H

; 3125 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	xor	edx, edx
	mov	WORD PTR [eax+edi*2], dx

; 3141 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	eax, ecx
	pop	edi

; 3142 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN4@append:

; 3129 :         return _Reallocate_grow_by(

	push	2
	push	ecx
	mov	BYTE PTR $T4[ebp], 0
	push	DWORD PTR $T4[ebp]
	push	2
	call	??$_Reallocate_grow_by@V<lambda_2fb699096920f2dc628cb0826b07831d>@@PB_WI@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_2fb699096920f2dc628cb0826b07831d>@@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_2fb699096920f2dc628cb0826b07831d>,wchar_t const *,unsigned int>

; 3142 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >, COMDAT
; _this$ = ecx

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [ecx], 0

; 2251 :     _CONSTEXPR20_CONTAINER _String_val() noexcept : _Bx() {}

	mov	eax, ecx

; 2314 : 
; 2315 :         _CONSTEXPR20_CONTAINER ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2316 : 
; 2317 :         value_type _Buf[_BUF_SIZE];
; 2318 :         pointer _Ptr;
; 2319 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2320 :     } _Bx;
; 2321 : 
; 2322 :     size_type _Mysize = 0; // current length of string

	mov	DWORD PTR [ecx+16], 0

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

	mov	DWORD PTR [ecx+20], 0
	ret	0
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@_W@std@@QAE@XZ PROC			; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT
; _this$ = ecx

; 787  :     constexpr allocator() noexcept {}

	mov	eax, ecx
	ret	0
??0?$allocator@_W@std@@QAE@XZ ENDP			; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4466 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Requested) const noexcept {

	push	ebp
	mov	ebp, esp

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	edx, DWORD PTR __Requested$[ebp]

; 4455 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	mov	eax, 2147483647				; 7fffffffH
	or	edx, 15					; 0000000fH

; 4466 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Requested) const noexcept {

	push	esi

; 4467 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	esi, DWORD PTR [ecx+20]

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	edx, eax

; 4455 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN3@Calculate_

; 4456 :             return _Max;
; 4457 :         }
; 4458 : 
; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	ecx, esi
	shr	ecx, 1
	sub	eax, ecx
	cmp	esi, eax
	jbe	SHORT $LN5@Calculate_

; 4467 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	eax, 2147483647				; 7fffffffH
	pop	esi

; 4468 :     }

	pop	ebp
	ret	4
$LN5@Calculate_:

; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

	add	ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 43   :     return _Left < _Right ? _Right : _Left;

	cmp	edx, ecx
	cmovb	edx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4467 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	eax, edx
$LN3@Calculate_:
	pop	esi

; 4468 :     }

	pop	ebp
	ret	4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data, COMDAT
; _this$ = ecx

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2273 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@data

; 3892 :         return _Mypair._Myval2._Myptr();

	mov	eax, DWORD PTR [ecx]

; 3893 :     }

	ret	0
$LN8@data:

; 3892 :         return _Mypair._Myval2._Myptr();

	mov	eax, ecx

; 3893 :     }

	ret	0
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [ecx], 0

; 2251 :     _CONSTEXPR20_CONTAINER _String_val() noexcept : _Bx() {}

	mov	eax, ecx

; 2314 : 
; 2315 :         _CONSTEXPR20_CONTAINER ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2316 : 
; 2317 :         value_type _Buf[_BUF_SIZE];
; 2318 :         pointer _Ptr;
; 2319 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2320 :     } _Bx;
; 2321 : 
; 2322 :     size_type _Mysize = 0; // current length of string

	mov	DWORD PTR [ecx+16], 0

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

	mov	DWORD PTR [ecx+20], 0
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 787  :     constexpr allocator() noexcept {}

	mov	eax, ecx
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 124  :             return _Ok;

	mov	al, BYTE PTR [ecx+4]

; 125  :         }

	ret	0
??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 108  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 109  : #if !_HAS_EXCEPTIONS
; 110  :             const bool _Zero_uncaught_exceptions = true;
; 111  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 112  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ

; 113  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 114  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 115  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 116  : 
; 117  :             if (_Zero_uncaught_exceptions) {

	test	al, al
	jne	SHORT $LN2@sentry

; 118  :                 this->_Myostr._Osfx();

	mov	ecx, DWORD PTR [esi]
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$LN2@sentry:

; 77   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 78   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	ecx, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 79   :         return _Mystrbuf;

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 79   :             if (_Rdbuf) {

	test	ecx, ecx
	je	SHORT $LN5@sentry

; 80   :                 _Rdbuf->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN5@sentry:

; 119  :             }
; 120  :         }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry, COMDAT
; _this$ = ecx

; 91   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	mov	edi, DWORD PTR __Ostr$[ebp]

; 70   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	mov	DWORD PTR [esi], edi

; 71   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	edx, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 79   :         return _Mystrbuf;

	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+edi+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 72   :             if (_Rdbuf) {

	test	ecx, ecx
	je	SHORT $LN8@sentry

; 73   :                 _Rdbuf->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
	mov	edx, DWORD PTR [edi]
$LN8@sentry:

; 91   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 272  :         return _Mystate;

	mov	eax, DWORD PTR [edx+4]

; 291  :         return rdstate() == ios_base::goodbit;

	cmp	DWORD PTR [eax+edi+12], 0

; 272  :         return _Mystate;

	lea	ecx, DWORD PTR [eax+edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 92   :             if (!_Ostr.good()) {

	je	SHORT $LN2@sentry

; 93   :                 _Ok = false;

	xor	al, al

; 94   :                 return;

	jmp	SHORT $LN23@sentry
$LN2@sentry:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 69   :         return _Tiestr;

	mov	ecx, DWORD PTR [ecx+60]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 98   :             if (!_Tied || _Tied == &_Ostr) {

	test	ecx, ecx
	je	SHORT $LN4@sentry
	cmp	ecx, edi
	je	SHORT $LN4@sentry

; 100  :                 return;
; 101  :             }
; 102  : 
; 103  :             _Tied->flush();

	call	DWORD PTR __imp_?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 291  :         return rdstate() == ios_base::goodbit;

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax+edi+12], 0
	sete	al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 104  :             _Ok = _Ostr.good(); // store test only after flushing tie

	jmp	SHORT $LN23@sentry
$LN4@sentry:

; 99   :                 _Ok = true;

	mov	al, 1
$LN23@sentry:

; 105  :         }

	mov	BYTE PTR [esi+4], al
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Getal@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@ABEABV?$allocator@_U@2@XZ
_TEXT	SEGMENT
?_Getal@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@ABEABV?$allocator@_U@2@XZ PROC ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Getal, COMDAT
; _this$ = ecx

; 4621 :         return _Mypair._Get_first();

	mov	eax, ecx

; 4622 :     }

	ret	0
?_Getal@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@ABEABV?$allocator@_U@2@XZ ENDP ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@CAIIII@Z
_TEXT	SEGMENT
__Max$ = 8						; size = 4
?_Calculate_growth@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@CAIIII@Z PROC ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Calculate_growth, COMDAT
; __Requested$ = ecx
; __Old$ = edx

; 4453 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	edi, DWORD PTR __Max$[ebp]
	or	ecx, 3
	cmp	ecx, edi

; 4455 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN7@Calculate_

; 4456 :             return _Max;
; 4457 :         }
; 4458 : 
; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	esi, edx
	mov	eax, edi
	shr	esi, 1
	sub	eax, esi
	cmp	edx, eax
	ja	SHORT $LN7@Calculate_

; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [esi+edx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 43   :     return _Left < _Right ? _Right : _Left;

	cmp	ecx, eax
	pop	edi
	cmovb	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

	mov	eax, ecx

; 4464 :     }

	pop	esi
	pop	ebp
	ret	0
$LN7@Calculate_:

; 4460 :             return _Max;

	mov	eax, edi
	pop	edi

; 4464 :     }

	pop	esi
	pop	ebp
	ret	0
?_Calculate_growth@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@CAIIII@Z ENDP ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?append@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAEAAV12@QB_UI@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
tv203 = 12						; size = 4
$T3 = 12						; size = 1
__Count$ = 12						; size = 4
?append@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAEAAV12@QB_UI@Z PROC ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::append, COMDAT
; _this$ = ecx

; 3118 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 3119 :         // append [_Ptr, _Ptr + _Count)
; 3120 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3121 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [esi+16]
	sub	eax, edx
	cmp	ecx, eax
	ja	SHORT $LN2@append

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [esi+20], 4

; 3122 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [edx+ecx]
	push	edi
	mov	DWORD PTR tv203[ebp], eax

; 2263 :         value_type* _Result = _Bx._Buf;

	mov	edi, esi

; 3122 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	DWORD PTR [esi+16], eax

; 2264 :         if (_Large_string_engaged()) {

	jb	SHORT $LN5@append

; 2265 :             _Result = _Unfancy(_Bx._Ptr);

	mov	edi, DWORD PTR [esi]
$LN5@append:

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	lea	eax, DWORD PTR [ecx*4]
	push	eax

; 3123 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3124 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	lea	eax, DWORD PTR [edi+edx*4]

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	push	OFFSET ??_C@_2M@JLEBFLAK@?$AA?$AA?$AA0?$AA?$AA?$AA3@
	push	eax
	call	_memmove

; 3125 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	eax, DWORD PTR tv203[ebp]

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	add	esp, 12					; 0000000cH

; 3125 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	DWORD PTR [edi+eax*4], 0

; 3126 :             return *this;

	mov	eax, esi
	pop	edi
	pop	esi

; 3130 :             _Count,
; 3131 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 3132 :                 const size_type _Count) {
; 3133 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3134 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 3136 :             },
; 3137 :             _Ptr, _Count);
; 3138 :     }

	pop	ebp
	ret	8
$LN2@append:

; 3127 :         }
; 3128 : 
; 3129 :         return _Reallocate_grow_by(

	push	ecx
	push	ecx
	mov	BYTE PTR $T3[ebp], 0
	push	DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, esi
	call	??$_Reallocate_grow_by@V<lambda_aabcc5df0dcdbd223414bc3ba38ad6d9>@@PB_UI@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEAAV01@IV<lambda_aabcc5df0dcdbd223414bc3ba38ad6d9>@@PB_UI@Z ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Reallocate_grow_by<<lambda_aabcc5df0dcdbd223414bc3ba38ad6d9>,char32_t const *,unsigned int>
	pop	esi

; 3130 :             _Count,
; 3131 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 3132 :                 const size_type _Count) {
; 3133 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3134 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 3136 :             },
; 3137 :             _Ptr, _Count);
; 3138 :     }

	pop	ebp
	ret	8
?append@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@QAEAAV12@QB_UI@Z ENDP ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??R<lambda_aabcc5df0dcdbd223414bc3ba38ad6d9>@@QBE@QA_UQB_UI1I@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ptr$dead$ = 20					; size = 4
__Count$ = 24						; size = 4
??R<lambda_aabcc5df0dcdbd223414bc3ba38ad6d9>@@QBE@QA_UQB_UI1I@Z PROC ; <lambda_aabcc5df0dcdbd223414bc3ba38ad6d9>::operator(), COMDAT
; _this$dead$ = ecx

; 3132 :                 const size_type _Count) {

	push	ebp
	mov	ebp, esp
	push	ebx

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	ebx, DWORD PTR __New_ptr$[ebp]

; 3132 :                 const size_type _Count) {

	push	esi
	push	edi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	edi, DWORD PTR __Old_size$[ebp]
	shl	edi, 2
	push	edi
	push	DWORD PTR __Old_ptr$[ebp]
	push	ebx
	call	_memcpy
	mov	esi, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [esi*4]
	push	eax

; 3133 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3134 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

	lea	eax, DWORD PTR [edi+ebx]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	push	OFFSET ??_C@_2M@JLEBFLAK@?$AA?$AA?$AA0?$AA?$AA?$AA3@
	push	eax
	call	_memcpy

; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	eax, DWORD PTR __Old_size$[ebp]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	add	esp, 24					; 00000018H

; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	add	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx+eax*4], 0
	pop	ebx

; 3136 :             },

	pop	ebp
	ret	20					; 00000014H
??R<lambda_aabcc5df0dcdbd223414bc3ba38ad6d9>@@QBE@QA_UQB_UI1I@Z ENDP ; <lambda_aabcc5df0dcdbd223414bc3ba38ad6d9>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEXAAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Take_contents@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEXAAV12@@Z PROC ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Take_contents, COMDAT
; _this$ = ecx

; 2838 :     _CONSTEXPR20_CONTAINER void _Take_contents(basic_string& _Right) noexcept {

	push	ebp
	mov	ebp, esp

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	eax, DWORD PTR __Right$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 4562 :         _My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 3

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	DWORD PTR [eax], 0

; 2839 :         // assign by stealing _Right's buffer
; 2840 :         // pre: this != &_Right
; 2841 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2842 :         // pre: *this owns no memory, iterators orphaned
; 2843 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2844 :         auto& _My_data    = _Mypair._Myval2;
; 2845 :         auto& _Right_data = _Right._Mypair._Myval2;
; 2846 : 
; 2847 :         if constexpr (_Can_memcpy_val) {
; 2848 : #ifdef __cpp_lib_constexpr_string
; 2849 :             if (!_STD is_constant_evaluated())
; 2850 : #endif // __cpp_lib_constexpr_string
; 2851 :             {
; 2852 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2853 :                 if (_Right_data._Large_string_engaged()) {
; 2854 :                     // take ownership of _Right's iterators along with its buffer
; 2855 :                     _Swap_proxy_and_iterators(_Right);
; 2856 :                 } else {
; 2857 :                     _Right_data._Orphan_all();
; 2858 :                 }
; 2859 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2860 : 
; 2861 :                 _Memcpy_val_from(_Right);
; 2862 :                 _Right._Tidy_init();
; 2863 :                 return;
; 2864 :             }
; 2865 :         }
; 2866 : 
; 2867 :         if (_Right_data._Large_string_engaged()) { // steal buffer
; 2868 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
; 2869 :             _Right_data._Bx._Ptr = nullptr;
; 2870 :             _Swap_proxy_and_iterators(_Right);
; 2871 :         } else { // copy small string buffer
; 2872 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
; 2873 :             _Right_data._Orphan_all();
; 2874 :         }
; 2875 : 
; 2876 :         _My_data._Mysize = _Right_data._Mysize;
; 2877 :         _My_data._Myres  = _Right_data._Myres;
; 2878 :         _Right._Tidy_init();
; 2879 :     }

	pop	ebp
	ret	4
?_Take_contents@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEXAAV12@@Z ENDP ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@_U@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@_U@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char32_t> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@_U@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char32_t> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@_U@std@@@std@@SAIABV?$allocator@_U@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@_U@std@@@std@@SAIABV?$allocator@_U@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char32_t> >::max_size, COMDAT
; ___formal$dead$ = ecx

; 695  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	eax, 1073741823				; 3fffffffH

; 696  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@_U@std@@@std@@SAIABV?$allocator@_U@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char32_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Getal@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@ABEABV?$allocator@_S@2@XZ
_TEXT	SEGMENT
?_Getal@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@ABEABV?$allocator@_S@2@XZ PROC ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Getal, COMDAT
; _this$ = ecx

; 4621 :         return _Mypair._Get_first();

	mov	eax, ecx

; 4622 :     }

	ret	0
?_Getal@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@ABEABV?$allocator@_S@2@XZ ENDP ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@CAIIII@Z
_TEXT	SEGMENT
__Max$ = 8						; size = 4
?_Calculate_growth@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@CAIIII@Z PROC ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Calculate_growth, COMDAT
; __Requested$ = ecx
; __Old$ = edx

; 4453 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	edi, DWORD PTR __Max$[ebp]
	or	ecx, 7
	cmp	ecx, edi

; 4455 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN7@Calculate_

; 4456 :             return _Max;
; 4457 :         }
; 4458 : 
; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	esi, edx
	mov	eax, edi
	shr	esi, 1
	sub	eax, esi
	cmp	edx, eax
	ja	SHORT $LN7@Calculate_

; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [esi+edx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 43   :     return _Left < _Right ? _Right : _Left;

	cmp	ecx, eax
	pop	edi
	cmovb	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

	mov	eax, ecx

; 4464 :     }

	pop	esi
	pop	ebp
	ret	0
$LN7@Calculate_:

; 4460 :             return _Max;

	mov	eax, edi
	pop	edi

; 4464 :     }

	pop	esi
	pop	ebp
	ret	0
?_Calculate_growth@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@CAIIII@Z ENDP ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?append@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAEAAV12@QB_SI@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
tv201 = 12						; size = 4
$T3 = 12						; size = 1
__Count$ = 12						; size = 4
?append@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAEAAV12@QB_SI@Z PROC ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::append, COMDAT
; _this$ = ecx

; 3118 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 3119 :         // append [_Ptr, _Ptr + _Count)
; 3120 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3121 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [esi+16]
	sub	eax, edx
	cmp	ecx, eax
	ja	SHORT $LN2@append

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [esi+20], 8

; 3122 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [edx+ecx]
	push	edi
	mov	DWORD PTR tv201[ebp], eax

; 2263 :         value_type* _Result = _Bx._Buf;

	mov	edi, esi

; 3122 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	DWORD PTR [esi+16], eax

; 2264 :         if (_Large_string_engaged()) {

	jb	SHORT $LN5@append

; 2265 :             _Result = _Unfancy(_Bx._Ptr);

	mov	edi, DWORD PTR [esi]
$LN5@append:

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	lea	eax, DWORD PTR [ecx+ecx]
	push	eax

; 3123 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3124 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	lea	eax, DWORD PTR [edi+edx*2]

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	push	OFFSET ??_C@_15BAGFGJNL@?$AA0?$AA2@
	push	eax
	call	_memmove

; 3125 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	eax, DWORD PTR tv201[ebp]

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	add	esp, 12					; 0000000cH

; 3125 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	xor	ecx, ecx
	mov	WORD PTR [edi+eax*2], cx

; 3126 :             return *this;

	mov	eax, esi
	pop	edi
	pop	esi

; 3130 :             _Count,
; 3131 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 3132 :                 const size_type _Count) {
; 3133 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3134 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 3136 :             },
; 3137 :             _Ptr, _Count);
; 3138 :     }

	pop	ebp
	ret	8
$LN2@append:

; 3127 :         }
; 3128 : 
; 3129 :         return _Reallocate_grow_by(

	push	ecx
	push	ecx
	mov	BYTE PTR $T3[ebp], 0
	push	DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, esi
	call	??$_Reallocate_grow_by@V<lambda_98ae700cc7810ca9f391bc310db97391>@@PB_SI@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEAAV01@IV<lambda_98ae700cc7810ca9f391bc310db97391>@@PB_SI@Z ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Reallocate_grow_by<<lambda_98ae700cc7810ca9f391bc310db97391>,char16_t const *,unsigned int>
	pop	esi

; 3130 :             _Count,
; 3131 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 3132 :                 const size_type _Count) {
; 3133 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3134 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 3136 :             },
; 3137 :             _Ptr, _Count);
; 3138 :     }

	pop	ebp
	ret	8
?append@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@QAEAAV12@QB_SI@Z ENDP ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??R<lambda_98ae700cc7810ca9f391bc310db97391>@@QBE@QA_SQB_SI1I@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ptr$dead$ = 20					; size = 4
__Count$ = 24						; size = 4
??R<lambda_98ae700cc7810ca9f391bc310db97391>@@QBE@QA_SQB_SI1I@Z PROC ; <lambda_98ae700cc7810ca9f391bc310db97391>::operator(), COMDAT
; _this$dead$ = ecx

; 3132 :                 const size_type _Count) {

	push	ebp
	mov	ebp, esp
	push	ebx

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	ebx, DWORD PTR __New_ptr$[ebp]

; 3132 :                 const size_type _Count) {

	push	esi
	push	edi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	edi, DWORD PTR __Old_size$[ebp]
	add	edi, edi
	push	edi
	push	DWORD PTR __Old_ptr$[ebp]
	push	ebx
	call	_memcpy
	mov	esi, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [esi+esi]
	push	eax

; 3133 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3134 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

	lea	eax, DWORD PTR [edi+ebx]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	push	OFFSET ??_C@_15BAGFGJNL@?$AA0?$AA2@
	push	eax
	call	_memcpy

; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	eax, DWORD PTR __Old_size$[ebp]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	add	esp, 24					; 00000018H

; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	add	eax, esi
	xor	ecx, ecx
	pop	edi
	pop	esi
	mov	WORD PTR [ebx+eax*2], cx
	pop	ebx

; 3136 :             },

	pop	ebp
	ret	20					; 00000014H
??R<lambda_98ae700cc7810ca9f391bc310db97391>@@QBE@QA_SQB_SI1I@Z ENDP ; <lambda_98ae700cc7810ca9f391bc310db97391>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEXAAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Take_contents@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEXAAV12@@Z PROC ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Take_contents, COMDAT
; _this$ = ecx

; 2838 :     _CONSTEXPR20_CONTAINER void _Take_contents(basic_string& _Right) noexcept {

	push	ebp
	mov	ebp, esp

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	eax, DWORD PTR __Right$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	xor	ecx, ecx
	mov	DWORD PTR [eax+16], 0
	mov	DWORD PTR [eax+20], 7
	mov	WORD PTR [eax], cx

; 2839 :         // assign by stealing _Right's buffer
; 2840 :         // pre: this != &_Right
; 2841 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2842 :         // pre: *this owns no memory, iterators orphaned
; 2843 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2844 :         auto& _My_data    = _Mypair._Myval2;
; 2845 :         auto& _Right_data = _Right._Mypair._Myval2;
; 2846 : 
; 2847 :         if constexpr (_Can_memcpy_val) {
; 2848 : #ifdef __cpp_lib_constexpr_string
; 2849 :             if (!_STD is_constant_evaluated())
; 2850 : #endif // __cpp_lib_constexpr_string
; 2851 :             {
; 2852 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2853 :                 if (_Right_data._Large_string_engaged()) {
; 2854 :                     // take ownership of _Right's iterators along with its buffer
; 2855 :                     _Swap_proxy_and_iterators(_Right);
; 2856 :                 } else {
; 2857 :                     _Right_data._Orphan_all();
; 2858 :                 }
; 2859 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2860 : 
; 2861 :                 _Memcpy_val_from(_Right);
; 2862 :                 _Right._Tidy_init();
; 2863 :                 return;
; 2864 :             }
; 2865 :         }
; 2866 : 
; 2867 :         if (_Right_data._Large_string_engaged()) { // steal buffer
; 2868 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
; 2869 :             _Right_data._Bx._Ptr = nullptr;
; 2870 :             _Swap_proxy_and_iterators(_Right);
; 2871 :         } else { // copy small string buffer
; 2872 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
; 2873 :             _Right_data._Orphan_all();
; 2874 :         }
; 2875 : 
; 2876 :         _My_data._Mysize = _Right_data._Mysize;
; 2877 :         _My_data._Myres  = _Right_data._Myres;
; 2878 :         _Right._Tidy_init();
; 2879 :     }

	pop	ebp
	ret	4
?_Take_contents@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEXAAV12@@Z ENDP ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@_S@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@_S@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char16_t> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@_S@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char16_t> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@_S@std@@@std@@SAIABV?$allocator@_S@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@_S@std@@@std@@SAIABV?$allocator@_S@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char16_t> >::max_size, COMDAT
; ___formal$dead$ = ecx

; 695  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	eax, 2147483647				; 7fffffffH

; 696  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@_S@std@@@std@@SAIABV?$allocator@_S@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char16_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAIIII@Z
_TEXT	SEGMENT
__Max$ = 8						; size = 4
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAIIII@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth, COMDAT
; __Requested$ = ecx
; __Old$ = edx

; 4453 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	edi, DWORD PTR __Max$[ebp]
	or	ecx, 7
	cmp	ecx, edi

; 4455 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN7@Calculate_

; 4456 :             return _Max;
; 4457 :         }
; 4458 : 
; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	esi, edx
	mov	eax, edi
	shr	esi, 1
	sub	eax, esi
	cmp	edx, eax
	ja	SHORT $LN7@Calculate_

; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [esi+edx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 43   :     return _Left < _Right ? _Right : _Left;

	cmp	ecx, eax
	pop	edi
	cmovb	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

	mov	eax, ecx

; 4464 :     }

	pop	esi
	pop	ebp
	ret	0
$LN7@Calculate_:

; 4460 :             return _Max;

	mov	eax, edi
	pop	edi

; 4464 :     }

	pop	esi
	pop	ebp
	ret	0
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAIIII@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z
_TEXT	SEGMENT
__Max$ = 8						; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; __Requested$ = ecx
; __Old$ = edx

; 4453 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	edi, DWORD PTR __Max$[ebp]
	or	ecx, 15					; 0000000fH
	cmp	ecx, edi

; 4455 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN7@Calculate_

; 4456 :             return _Max;
; 4457 :         }
; 4458 : 
; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	esi, edx
	mov	eax, edi
	shr	esi, 1
	sub	eax, esi
	cmp	edx, eax
	ja	SHORT $LN7@Calculate_

; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [esi+edx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 43   :     return _Left < _Right ? _Right : _Left;

	cmp	ecx, eax
	pop	edi
	cmovb	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

	mov	eax, ecx

; 4464 :     }

	pop	esi
	pop	ebp
	ret	0
$LN7@Calculate_:

; 4460 :             return _Max;

	mov	eax, edi
	pop	edi

; 4464 :     }

	pop	esi
	pop	ebp
	ret	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?length@?$_Char_traits@_UI@std@@SAIPB_U@Z
_TEXT	SEGMENT
?length@?$_Char_traits@_UI@std@@SAIPB_U@Z PROC		; std::_Char_traits<char32_t,unsigned int>::length, COMDAT
; __First$dead$ = ecx

; 142  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* _First) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	ecx, OFFSET ??_C@_2M@JLEBFLAK@?$AA?$AA?$AA0?$AA?$AA?$AA3@

; 143  :         // find length of null-terminated sequence
; 144  :         size_t _Count = 0;

	xor	eax, eax
	npad	5
$LL2@length:

; 145  :         while (*_First != _Elem()) {
; 146  :             ++_Count;
; 147  :             ++_First;

	lea	ecx, DWORD PTR [ecx+4]
	inc	eax
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LL2@length

; 148  :         }
; 149  : 
; 150  :         return _Count;
; 151  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$_Char_traits@_UI@std@@SAIPB_U@Z ENDP		; std::_Char_traits<char32_t,unsigned int>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?length@?$_WChar_traits@_S@std@@SAIPB_S@Z
_TEXT	SEGMENT
?length@?$_WChar_traits@_S@std@@SAIPB_S@Z PROC		; std::_WChar_traits<char16_t>::length, COMDAT
; __First$dead$ = ecx

; 260  :         // find length of null-terminated sequence
; 261  : #if _HAS_CXX17
; 262  :         if constexpr (is_same_v<_Elem, wchar_t>) {
; 263  :             return __builtin_wcslen(_First);
; 264  :         } else {
; 265  :             return _Primary_char_traits::length(_First);
; 266  :         }
; 267  : #else // _HAS_CXX17
; 268  :         return _CSTD wcslen(reinterpret_cast<const wchar_t*>(_First));

	mov	eax, 2

; 269  : #endif // _HAS_CXX17
; 270  :     }

	ret	0
?length@?$_WChar_traits@_S@std@@SAIPB_S@Z ENDP		; std::_WChar_traits<char16_t>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 77   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 78   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	ecx, DWORD PTR [ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 79   :         return _Mystrbuf;

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 79   :             if (_Rdbuf) {

	test	ecx, ecx
	je	SHORT $LN2@Sentry_bas

; 80   :                 _Rdbuf->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 81   :             }
; 82   :         }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 70   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR __Ostr$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 79   :         return _Mystrbuf;

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 72   :             if (_Rdbuf) {

	test	ecx, ecx
	je	SHORT $LN6@Sentry_bas

; 73   :                 _Rdbuf->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN6@Sentry_bas:

; 74   :             }
; 75   :         }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@_U@std@@V?$_String_val@U?$_Simple_types@_U@std@@@2@$00@std@@QBEABV?$allocator@_U@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@_U@std@@V?$_String_val@U?$_Simple_types@_U@std@@@2@$00@std@@QBEABV?$allocator@_U@2@XZ PROC ; std::_Compressed_pair<std::allocator<char32_t>,std::_String_val<std::_Simple_types<char32_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@_U@std@@V?$_String_val@U?$_Simple_types@_U@std@@@2@$00@std@@QBEABV?$allocator@_U@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char32_t>,std::_String_val<std::_Simple_types<char32_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Swap_proxy_and_iterators@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEXAAV12@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
?_Swap_proxy_and_iterators@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEXAAV12@@Z PROC ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Swap_proxy_and_iterators, COMDAT
; _this$dead$ = ecx

; 4613 :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 4614 :     }

	ret	4
?_Swap_proxy_and_iterators@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEXAAV12@@Z ENDP ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Memcpy_val_from@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEXABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Memcpy_val_from@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEXABV12@@Z PROC ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Memcpy_val_from, COMDAT
; _this$ = ecx

; 2829 :     void _Memcpy_val_from(const basic_string& _Right) noexcept {

	push	ebp
	mov	ebp, esp

; 2830 :         _STL_INTERNAL_CHECK(_Can_memcpy_val); // TRANSITION, if constexpr
; 2831 :         const auto _My_data_mem =
; 2832 :             reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 2833 :         const auto _Right_data_mem =
; 2834 :             reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	eax, DWORD PTR __Right$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 2836 :     }

	pop	ebp
	ret	4
?_Memcpy_val_from@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEXABV12@@Z ENDP ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Memcpy_val_from
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@_S@std@@V?$_String_val@U?$_Simple_types@_S@std@@@2@$00@std@@QBEABV?$allocator@_S@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@_S@std@@V?$_String_val@U?$_Simple_types@_S@std@@@2@$00@std@@QBEABV?$allocator@_S@2@XZ PROC ; std::_Compressed_pair<std::allocator<char16_t>,std::_String_val<std::_Simple_types<char16_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@_S@std@@V?$_String_val@U?$_Simple_types@_S@std@@@2@$00@std@@QBEABV?$allocator@_S@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char16_t>,std::_String_val<std::_Simple_types<char16_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Swap_proxy_and_iterators@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEXAAV12@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
?_Swap_proxy_and_iterators@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEXAAV12@@Z PROC ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Swap_proxy_and_iterators, COMDAT
; _this$dead$ = ecx

; 4613 :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 4614 :     }

	ret	4
?_Swap_proxy_and_iterators@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEXAAV12@@Z ENDP ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Memcpy_val_from@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEXABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Memcpy_val_from@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEXABV12@@Z PROC ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Memcpy_val_from, COMDAT
; _this$ = ecx

; 2829 :     void _Memcpy_val_from(const basic_string& _Right) noexcept {

	push	ebp
	mov	ebp, esp

; 2830 :         _STL_INTERNAL_CHECK(_Can_memcpy_val); // TRANSITION, if constexpr
; 2831 :         const auto _My_data_mem =
; 2832 :             reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 2833 :         const auto _Right_data_mem =
; 2834 :             reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	eax, DWORD PTR __Right$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 2836 :     }

	pop	ebp
	ret	4
?_Memcpy_val_from@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEXABV12@@Z ENDP ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Memcpy_val_from
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@@std@@YA$$QAV?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@@std@@YA$$QAV?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAV?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@@std@@YA$$QAV?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@@std@@YA$$QAV?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@@std@@YA$$QAV?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAV?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@@std@@YA$$QAV?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
_TEXT	SEGMENT
__Ok$ = -40						; size = 8
__Data$1$ = -32						; size = 4
$T13 = -32						; size = 1
tv693 = -28						; size = 4
$T7 = -28						; size = 1
__State$ = -24						; size = 4
__Ostr$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Size$ = 8						; size = 4
??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z PROC ; std::_Insert_string<char,std::char_traits<char>,unsigned int>, COMDAT
; __Ostr$ = ecx
; __Data$ = edx

; 491  :     basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* const _Data, const _SizeT _Size) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Data$1$[ebp], edx
	mov	ebx, ecx
	mov	DWORD PTR __Ostr$[ebp], ebx

; 497  :     if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {

	mov	ecx, DWORD PTR [ebx]
	xor	edi, edi
	mov	DWORD PTR __State$[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 359  :         return _Wide;

	mov	edx, DWORD PTR [ecx+4]
	add	edx, ebx
	mov	DWORD PTR tv693[ebp], edx
	mov	esi, DWORD PTR [edx+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 497  :     if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {

	cmp	DWORD PTR [edx+36], edi
	jl	SHORT $LN10@Insert_str
	jg	SHORT $LN93@Insert_str
	test	esi, esi
	je	SHORT $LN10@Insert_str
$LN93@Insert_str:
	mov	eax, DWORD PTR __Size$[ebp]
	cmp	esi, eax
	jbe	SHORT $LN10@Insert_str

; 499  :     } else {
; 500  :         _Pad = static_cast<_SizeT>(_Ostr.width()) - _Size;

	sub	esi, eax
	jmp	SHORT $LN9@Insert_str
$LN10@Insert_str:

; 498  :         _Pad = 0;

	xor	esi, esi
$LN9@Insert_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 79   :         return _Mystrbuf;

	mov	eax, DWORD PTR [edx+56]
	mov	edx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 70   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	mov	DWORD PTR __Ok$[ebp], ebx

; 71   :             const auto _Rdbuf = _Myostr.rdbuf();
; 72   :             if (_Rdbuf) {

	test	eax, eax
	je	SHORT $LN38@Insert_str

; 73   :                 _Rdbuf->_Lock();

	mov	ecx, DWORD PTR tv693[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	call	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [ebx]
	mov	edx, ecx
$LN38@Insert_str:

; 91   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 272  :         return _Mystate;

	mov	eax, DWORD PTR [ecx+4]
	add	eax, ebx

; 291  :         return rdstate() == ios_base::goodbit;

	cmp	DWORD PTR [eax+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 92   :             if (!_Ostr.good()) {

	je	SHORT $LN32@Insert_str

; 93   :                 _Ok = false;

	xor	al, al

; 94   :                 return;

	jmp	SHORT $LN101@Insert_str
$LN32@Insert_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 69   :         return _Tiestr;

	mov	eax, DWORD PTR [eax+60]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 98   :             if (!_Tied || _Tied == &_Ostr) {

	test	eax, eax
	je	SHORT $LN34@Insert_str
	cmp	eax, ebx
	je	SHORT $LN34@Insert_str

; 100  :                 return;
; 101  :             }
; 102  : 
; 103  :             _Tied->flush();

	mov	ecx, eax
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 104  :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	ecx, DWORD PTR [ebx]
	mov	edx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 272  :         return _Mystate;

	mov	eax, DWORD PTR [ecx+4]

; 291  :         return rdstate() == ios_base::goodbit;

	cmp	DWORD PTR [eax+ebx+12], 0
	sete	al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 104  :             _Ok = _Ostr.good(); // store test only after flushing tie

	jmp	SHORT $LN101@Insert_str
$LN34@Insert_str:

; 99   :                 _Ok = true;

	mov	al, 1
$LN101@Insert_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 503  :     const typename _Ostr_t::sentry _Ok(_Ostr);

	mov	BYTE PTR __Ok$[ebp+4], al
	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 504  : 
; 505  :     if (!_Ok) {

	test	al, al
	jne	SHORT $LN11@Insert_str

; 506  :         _State |= _Ostr_t::badbit;

	mov	edi, 4

; 507  :     } else { // state okay, insert characters

	jmp	$LN23@Insert_str
$LN11@Insert_str:

; 508  :         _TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 322  :         return _Fmtfl;

	mov	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+ebx+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 509  :         if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {

	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN88@Insert_str
$LL4@Insert_str:

; 510  :             for (; 0 < _Pad; --_Pad) { // pad on left

	test	esi, esi
	je	SHORT $LN90@Insert_str
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 100  :         return _Fillch;

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]
	mov	al, BYTE PTR [ecx+ebx+64]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 511  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	ecx, DWORD PTR [ecx+ebx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 100  :         return _Fillch;

	mov	BYTE PTR $T7[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 511  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	push	DWORD PTR $T7[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	eax, -1
	jne	SHORT $LN2@Insert_str

; 512  :                     _State |= _Ostr_t::badbit; // insertion failed, quit

	mov	edi, 4
	mov	DWORD PTR __State$[ebp], edi

; 513  :                     break;

	jmp	SHORT $LL95@Insert_str
$LN2@Insert_str:

; 510  :             for (; 0 < _Pad; --_Pad) { // pad on left

	dec	esi
	jmp	SHORT $LL4@Insert_str
$LN90@Insert_str:

; 519  :             && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {

	mov	edx, DWORD PTR [ebx]
$LN88@Insert_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 79   :         return _Mystrbuf;

	mov	eax, DWORD PTR [edx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 519  :             && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {

	push	0
	push	DWORD PTR __Size$[ebp]
	push	DWORD PTR __Data$1$[ebp]
	mov	ecx, DWORD PTR [eax+ebx+56]
	call	DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
	cmp	eax, DWORD PTR __Size$[ebp]
	jne	SHORT $LN94@Insert_str
	test	edx, edx
	jne	SHORT $LN94@Insert_str
$LL95@Insert_str:

; 521  :         } else {
; 522  :             for (; 0 < _Pad; --_Pad) { // pad on right

	test	esi, esi
	je	SHORT $LN6@Insert_str
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 100  :         return _Fillch;

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]
	mov	al, BYTE PTR [ecx+ebx+64]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 523  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	ecx, DWORD PTR [ecx+ebx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 100  :         return _Fillch;

	mov	BYTE PTR $T13[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 523  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	push	DWORD PTR $T13[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	eax, -1
	jne	SHORT $LN5@Insert_str

; 524  :                     _State |= _Ostr_t::badbit; // insertion failed, quit

	or	edi, 4

; 525  :                     break;

	jmp	SHORT $LN6@Insert_str
$LN5@Insert_str:

; 521  :         } else {
; 522  :             for (; 0 < _Pad; --_Pad) { // pad on right

	dec	esi
	jmp	SHORT $LL95@Insert_str
$LN94@Insert_str:

; 520  :             _State |= _Ostr_t::badbit;

	mov	edi, 4
$LN6@Insert_str:

; 526  :                 }
; 527  :             }
; 528  :         }
; 529  : 
; 530  :         _Ostr.width(0);

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 364  :         _Wide                      = _Newwidth;

	mov	DWORD PTR [eax+ebx+32], 0
	mov	DWORD PTR [eax+ebx+36], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
	jmp	SHORT $LN102@Insert_str
__catch$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$0:

; 531  :         _CATCH_IO_(_Ostr_t, _Ostr)

	mov	edx, DWORD PTR __Ostr$[ebp]
	push	1
	push	4
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	mov	eax, $LN24@Insert_str
	ret	0
$LN24@Insert_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
	mov	ebx, DWORD PTR __Ostr$[ebp]
	mov	edi, DWORD PTR __State$[ebp]
$LN102@Insert_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 532  :     }
; 533  : 
; 534  :     _Ostr.setstate(_State);

	mov	DWORD PTR __$EHRec$[ebp+12], 1
$LN23@Insert_str:
	mov	eax, DWORD PTR [ebx]
	push	0
	push	edi
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, ebx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 108  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

	mov	DWORD PTR __$EHRec$[ebp+12], 4

; 109  : #if !_HAS_EXCEPTIONS
; 110  :             const bool _Zero_uncaught_exceptions = true;
; 111  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 112  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ

; 113  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 114  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 115  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 116  : 
; 117  :             if (_Zero_uncaught_exceptions) {

	mov	esi, DWORD PTR __Ok$[ebp]
	test	al, al
	jne	SHORT $LN71@Insert_str

; 118  :                 this->_Myostr._Osfx();

	mov	ecx, esi
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN71@Insert_str:

; 77   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

	mov	BYTE PTR __$EHRec$[ebp+12], 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 79   :         return _Mystrbuf;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 79   :             if (_Rdbuf) {

	test	ecx, ecx
	je	SHORT $LN96@Insert_str

; 80   :                 _Rdbuf->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN96@Insert_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 536  : }

	mov	eax, ebx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$3:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ENDP ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z
_TEXT	SEGMENT
__Ok$ = -40						; size = 8
__Data$1$ = -32						; size = 4
tv692 = -28						; size = 4
__State$ = -24						; size = 4
__Ostr$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Size$ = 8						; size = 4
??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z PROC ; std::_Insert_string<wchar_t,std::char_traits<wchar_t>,unsigned int>, COMDAT
; __Ostr$ = ecx
; __Data$ = edx

; 491  :     basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* const _Data, const _SizeT _Size) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Data$1$[ebp], edx
	mov	edi, ecx
	mov	DWORD PTR __Ostr$[ebp], edi

; 497  :     if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {

	mov	ecx, DWORD PTR [edi]
	xor	ebx, ebx
	mov	DWORD PTR __State$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 359  :         return _Wide;

	mov	eax, DWORD PTR [ecx+4]
	add	eax, edi
	mov	DWORD PTR tv692[ebp], eax
	mov	esi, DWORD PTR [eax+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 497  :     if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {

	cmp	DWORD PTR [eax+36], ebx
	jl	SHORT $LN10@Insert_str
	jg	SHORT $LN93@Insert_str
	test	esi, esi
	je	SHORT $LN10@Insert_str
$LN93@Insert_str:
	mov	edx, DWORD PTR __Size$[ebp]
	cmp	esi, edx
	jbe	SHORT $LN10@Insert_str

; 499  :     } else {
; 500  :         _Pad = static_cast<_SizeT>(_Ostr.width()) - _Size;

	sub	esi, edx
	jmp	SHORT $LN9@Insert_str
$LN10@Insert_str:

; 498  :         _Pad = 0;

	xor	esi, esi
$LN9@Insert_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 79   :         return _Mystrbuf;

	mov	eax, DWORD PTR [eax+56]
	mov	edx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 70   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	mov	DWORD PTR __Ok$[ebp], edi

; 71   :             const auto _Rdbuf = _Myostr.rdbuf();
; 72   :             if (_Rdbuf) {

	test	eax, eax
	je	SHORT $LN38@Insert_str

; 73   :                 _Rdbuf->_Lock();

	mov	ecx, DWORD PTR tv692[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	call	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [edi]
	mov	edx, ecx
$LN38@Insert_str:

; 91   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 272  :         return _Mystate;

	mov	eax, DWORD PTR [ecx+4]
	add	eax, edi

; 291  :         return rdstate() == ios_base::goodbit;

	cmp	DWORD PTR [eax+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 92   :             if (!_Ostr.good()) {

	je	SHORT $LN32@Insert_str

; 93   :                 _Ok = false;

	xor	al, al

; 94   :                 return;

	jmp	SHORT $LN102@Insert_str
$LN32@Insert_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 69   :         return _Tiestr;

	mov	eax, DWORD PTR [eax+60]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 98   :             if (!_Tied || _Tied == &_Ostr) {

	test	eax, eax
	je	SHORT $LN34@Insert_str
	cmp	eax, edi
	je	SHORT $LN34@Insert_str

; 100  :                 return;
; 101  :             }
; 102  : 
; 103  :             _Tied->flush();

	mov	ecx, eax
	call	DWORD PTR __imp_?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ

; 104  :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	ecx, DWORD PTR [edi]
	mov	edx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 272  :         return _Mystate;

	mov	eax, DWORD PTR [ecx+4]

; 291  :         return rdstate() == ios_base::goodbit;

	cmp	DWORD PTR [eax+edi+12], 0
	sete	al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 104  :             _Ok = _Ostr.good(); // store test only after flushing tie

	jmp	SHORT $LN102@Insert_str
$LN34@Insert_str:

; 99   :                 _Ok = true;

	mov	al, 1
$LN102@Insert_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 503  :     const typename _Ostr_t::sentry _Ok(_Ostr);

	mov	BYTE PTR __Ok$[ebp+4], al
	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 504  : 
; 505  :     if (!_Ok) {

	test	al, al
	jne	SHORT $LN11@Insert_str

; 506  :         _State |= _Ostr_t::badbit;

	mov	ebx, 4

; 507  :     } else { // state okay, insert characters

	jmp	$LN23@Insert_str
$LN11@Insert_str:

; 508  :         _TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 322  :         return _Fmtfl;

	mov	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+edi+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 509  :         if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {

	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN88@Insert_str
$LL4@Insert_str:

; 510  :             for (; 0 < _Pad; --_Pad) { // pad on left

	test	esi, esi
	je	SHORT $LN90@Insert_str
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 100  :         return _Fillch;

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	movzx	edx, WORD PTR [eax+edi+64]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 511  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	ecx, DWORD PTR [eax+edi+56]
	push	edx
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
	mov	cx, ax
	mov	eax, 65535				; 0000ffffH
	cmp	ax, cx
	jne	SHORT $LN2@Insert_str

; 512  :                     _State |= _Ostr_t::badbit; // insertion failed, quit

	mov	ebx, 4
	mov	DWORD PTR __State$[ebp], ebx

; 513  :                     break;

	jmp	SHORT $LL95@Insert_str
$LN2@Insert_str:

; 510  :             for (; 0 < _Pad; --_Pad) { // pad on left

	dec	esi
	jmp	SHORT $LL4@Insert_str
$LN90@Insert_str:

; 519  :             && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {

	mov	edx, DWORD PTR [edi]
$LN88@Insert_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 79   :         return _Mystrbuf;

	mov	eax, DWORD PTR [edx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 519  :             && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {

	push	0
	push	DWORD PTR __Size$[ebp]
	push	DWORD PTR __Data$1$[ebp]
	mov	ecx, DWORD PTR [eax+edi+56]
	call	DWORD PTR __imp_?sputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAE_JPB_W_J@Z
	cmp	eax, DWORD PTR __Size$[ebp]
	jne	SHORT $LN94@Insert_str
	test	edx, edx
	jne	SHORT $LN94@Insert_str
$LL95@Insert_str:

; 521  :         } else {
; 522  :             for (; 0 < _Pad; --_Pad) { // pad on right

	test	esi, esi
	je	SHORT $LN6@Insert_str
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 100  :         return _Fillch;

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	movzx	edx, WORD PTR [eax+edi+64]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 523  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	ecx, DWORD PTR [eax+edi+56]
	push	edx
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
	mov	cx, ax
	mov	eax, 65535				; 0000ffffH
	cmp	ax, cx
	jne	SHORT $LN5@Insert_str

; 524  :                     _State |= _Ostr_t::badbit; // insertion failed, quit

	or	ebx, 4

; 525  :                     break;

	jmp	SHORT $LN6@Insert_str
$LN5@Insert_str:

; 521  :         } else {
; 522  :             for (; 0 < _Pad; --_Pad) { // pad on right

	dec	esi
	jmp	SHORT $LL95@Insert_str
$LN94@Insert_str:

; 520  :             _State |= _Ostr_t::badbit;

	mov	ebx, 4
$LN6@Insert_str:

; 526  :                 }
; 527  :             }
; 528  :         }
; 529  : 
; 530  :         _Ostr.width(0);

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xiosbase

; 364  :         _Wide                      = _Newwidth;

	mov	DWORD PTR [eax+edi+32], 0
	mov	DWORD PTR [eax+edi+36], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
	jmp	SHORT $LN103@Insert_str
__catch$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z$0:

; 531  :         _CATCH_IO_(_Ostr_t, _Ostr)

	mov	edx, DWORD PTR __Ostr$[ebp]
	push	1
	push	4
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
	mov	eax, $LN24@Insert_str
	ret	0
$LN24@Insert_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios
	mov	edi, DWORD PTR __Ostr$[ebp]
	mov	ebx, DWORD PTR __State$[ebp]
$LN103@Insert_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 532  :     }
; 533  : 
; 534  :     _Ostr.setstate(_State);

	mov	DWORD PTR __$EHRec$[ebp+12], 1
$LN23@Insert_str:
	mov	eax, DWORD PTR [edi]
	push	0
	push	ebx
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edi
	call	DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 108  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

	mov	DWORD PTR __$EHRec$[ebp+12], 4

; 109  : #if !_HAS_EXCEPTIONS
; 110  :             const bool _Zero_uncaught_exceptions = true;
; 111  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 112  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ

; 113  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 114  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 115  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 116  : 
; 117  :             if (_Zero_uncaught_exceptions) {

	mov	esi, DWORD PTR __Ok$[ebp]
	test	al, al
	jne	SHORT $LN71@Insert_str

; 118  :                 this->_Myostr._Osfx();

	mov	ecx, esi
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$LN71@Insert_str:

; 77   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

	mov	BYTE PTR __$EHRec$[ebp+12], 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ios

; 79   :         return _Mystrbuf;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream

; 79   :             if (_Rdbuf) {

	test	ecx, ecx
	je	SHORT $LN96@Insert_str

; 80   :                 _Rdbuf->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN96@Insert_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 536  : }

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z$3:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z ENDP ; std::_Insert_string<wchar_t,std::char_traits<wchar_t>,unsigned int>
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@V?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z PROC ; std::forward<std::allocator<wchar_t> >, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@V?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z ENDP ; std::forward<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Construct_in_place@PA_UABQA_U@std@@YAXAAPA_UABQA_U@Z
_TEXT	SEGMENT
??$_Construct_in_place@PA_UABQA_U@std@@YAXAAPA_UABQA_U@Z PROC ; std::_Construct_in_place<char32_t *,char32_t * const &>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 142  :     is_nothrow_constructible_v<_Ty, _Types...>) {

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 143  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 144  :     if (_STD is_constant_evaluated()) {
; 145  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 146  :     } else
; 147  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 148  :     {
; 149  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 150  :     }
; 151  : }

	ret	0
??$_Construct_in_place@PA_UABQA_U@std@@YAXAAPA_UABQA_U@Z ENDP ; std::_Construct_in_place<char32_t *,char32_t * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Construct_in_place@PA_SABQA_S@std@@YAXAAPA_SABQA_S@Z
_TEXT	SEGMENT
??$_Construct_in_place@PA_SABQA_S@std@@YAXAAPA_SABQA_S@Z PROC ; std::_Construct_in_place<char16_t *,char16_t * const &>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 142  :     is_nothrow_constructible_v<_Ty, _Types...>) {

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 143  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 144  :     if (_STD is_constant_evaluated()) {
; 145  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 146  :     } else
; 147  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 148  :     {
; 149  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 150  :     }
; 151  : }

	ret	0
??$_Construct_in_place@PA_SABQA_S@std@@YAXAAPA_SABQA_S@Z ENDP ; std::_Construct_in_place<char16_t *,char16_t * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z
_TEXT	SEGMENT
??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z PROC		; std::addressof<wchar_t *>, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z ENDP		; std::addressof<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PAPA_W@std@@YAPAXPAPA_W@Z
_TEXT	SEGMENT
??$_Voidify_iter@PAPA_W@std@@YAPAXPAPA_W@Z PROC		; std::_Voidify_iter<wchar_t * *>, COMDAT
; __It$ = ecx

; 124  :     if constexpr (is_pointer_v<_Iter>) {
; 125  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

	mov	eax, ecx

; 126  :     } else {
; 127  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 128  :     }
; 129  : }

	ret	0
??$_Voidify_iter@PAPA_W@std@@YAPAXPAPA_W@Z ENDP		; std::_Voidify_iter<wchar_t * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
_TEXT	SEGMENT
??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z PROC		; std::forward<wchar_t * &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ENDP		; std::forward<wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z
_TEXT	SEGMENT
??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z PROC		; std::_Voidify_iter<char * *>, COMDAT
; __It$ = ecx

; 124  :     if constexpr (is_pointer_v<_Iter>) {
; 125  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

	mov	eax, ecx

; 126  :     } else {
; 127  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 128  :     }
; 129  : }

	ret	0
??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z ENDP		; std::_Voidify_iter<char * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABQAD@std@@YAABQADABQAD@Z
_TEXT	SEGMENT
??$forward@ABQAD@std@@YAABQADABQAD@Z PROC		; std::forward<char * const &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ABQAD@std@@YAABQADABQAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABQA_W@std@@YAABQA_WABQA_W@Z
_TEXT	SEGMENT
??$forward@ABQA_W@std@@YAABQA_WABQA_W@Z PROC		; std::forward<wchar_t * const &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ABQA_W@std@@YAABQA_WABQA_W@Z ENDP		; std::forward<wchar_t * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT
; __Bytes$ = ecx

; 128  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	eax, ecx
	jbe	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length

; 79   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new

; 131  :         _Throw_bad_array_new_length(); // add overflow
; 132  :     }
; 133  : 
; 134  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 79   :         return ::operator new(_Bytes);

	add	esp, 4

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN7@Allocate_m

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 138  : 
; 139  : #ifdef _DEBUG
; 140  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 141  : #endif // _DEBUG
; 142  :     return _Ptr;
; 143  : }

	ret	0
$LN7@Allocate_m:

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAV?$allocator@_U@std@@@std@@YA$$QAV?$allocator@_U@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$allocator@_U@std@@@std@@YA$$QAV?$allocator@_U@0@AAV10@@Z PROC ; std::move<std::allocator<char32_t> &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAV?$allocator@_U@std@@@std@@YA$$QAV?$allocator@_U@0@AAV10@@Z ENDP ; std::move<std::allocator<char32_t> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0V?$allocator@_U@std@@$$V@?$_Compressed_pair@V?$allocator@_U@std@@V?$_String_val@U?$_Simple_types@_U@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@_U@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0V?$allocator@_U@std@@$$V@?$_Compressed_pair@V?$allocator@_U@std@@V?$_String_val@U?$_Simple_types@_U@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@_U@1@@Z PROC ; std::_Compressed_pair<std::allocator<char32_t>,std::_String_val<std::_Simple_types<char32_t> >,1>::_Compressed_pair<std::allocator<char32_t>,std::_String_val<std::_Simple_types<char32_t> >,1><std::allocator<char32_t> >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1336 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2322 :     size_type _Mysize = 0; // current length of string

	mov	DWORD PTR [ecx+16], 0

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

	mov	DWORD PTR [ecx+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1336 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	8
??$?0V?$allocator@_U@std@@$$V@?$_Compressed_pair@V?$allocator@_U@std@@V?$_String_val@U?$_Simple_types@_U@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@_U@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char32_t>,std::_String_val<std::_Simple_types<char32_t> >,1>::_Compressed_pair<std::allocator<char32_t>,std::_String_val<std::_Simple_types<char32_t> >,1><std::allocator<char32_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Get_size_of_n@$03@std@@YAII@Z
_TEXT	SEGMENT
??$_Get_size_of_n@$03@std@@YAII@Z PROC			; std::_Get_size_of_n<4>, COMDAT
; __Count$ = ecx

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 57   : 
; 58   :     if constexpr (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 60   :         if (_Count > _Max_possible) {

	cmp	ecx, 1073741823				; 3fffffffH
	ja	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	lea	eax, DWORD PTR [ecx*4]

; 66   : }

	ret	0
??$_Get_size_of_n@$03@std@@YAII@Z ENDP			; std::_Get_size_of_n<4>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAV?$allocator@_S@std@@@std@@YA$$QAV?$allocator@_S@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$allocator@_S@std@@@std@@YA$$QAV?$allocator@_S@0@AAV10@@Z PROC ; std::move<std::allocator<char16_t> &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAV?$allocator@_S@std@@@std@@YA$$QAV?$allocator@_S@0@AAV10@@Z ENDP ; std::move<std::allocator<char16_t> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0V?$allocator@_S@std@@$$V@?$_Compressed_pair@V?$allocator@_S@std@@V?$_String_val@U?$_Simple_types@_S@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@_S@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0V?$allocator@_S@std@@$$V@?$_Compressed_pair@V?$allocator@_S@std@@V?$_String_val@U?$_Simple_types@_S@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@_S@1@@Z PROC ; std::_Compressed_pair<std::allocator<char16_t>,std::_String_val<std::_Simple_types<char16_t> >,1>::_Compressed_pair<std::allocator<char16_t>,std::_String_val<std::_Simple_types<char16_t> >,1><std::allocator<char16_t> >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1336 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2322 :     size_type _Mysize = 0; // current length of string

	mov	DWORD PTR [ecx+16], 0

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

	mov	DWORD PTR [ecx+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1336 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	8
??$?0V?$allocator@_S@std@@$$V@?$_Compressed_pair@V?$allocator@_S@std@@V?$_String_val@U?$_Simple_types@_S@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@_S@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char16_t>,std::_String_val<std::_Simple_types<char16_t> >,1>::_Compressed_pair<std::allocator<char16_t>,std::_String_val<std::_Simple_types<char16_t> >,1><std::allocator<char16_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_aabcc5df0dcdbd223414bc3ba38ad6d9>@@PB_UI@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEAAV01@IV<lambda_aabcc5df0dcdbd223414bc3ba38ad6d9>@@PB_UI@Z
_TEXT	SEGMENT
tv501 = -16						; size = 4
__Old$1$ = -12						; size = 4
tv500 = -8						; size = 4
__New_size$1$ = -8					; size = 4
tv499 = -4						; size = 4
__Old_size$1$ = -4					; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$dead$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
??$_Reallocate_grow_by@V<lambda_aabcc5df0dcdbd223414bc3ba38ad6d9>@@PB_UI@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEAAV01@IV<lambda_aabcc5df0dcdbd223414bc3ba38ad6d9>@@PB_UI@Z PROC ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Reallocate_grow_by<<lambda_aabcc5df0dcdbd223414bc3ba38ad6d9>,char32_t const *,unsigned int>, COMDAT
; _this$ = ecx

; 4504 :         const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 4505 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4506 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4507 :         auto& _My_data            = _Mypair._Myval2;
; 4508 :         const size_type _Old_size = _My_data._Mysize;
; 4509 :         if (max_size() - _Old_size < _Size_increase) {

	mov	edx, DWORD PTR __Size_increase$[ebp]
	push	ebx
	mov	ebx, ecx
	mov	ecx, 1073741822				; 3ffffffeH
	push	esi
	mov	eax, ecx
	push	edi
	mov	esi, DWORD PTR [ebx+16]
	sub	eax, esi
	mov	DWORD PTR __Old_size$1$[ebp], esi
	cmp	eax, edx
	jb	$LN73@Reallocate

; 4511 :         }
; 4512 : 
; 4513 :         const size_type _New_size     = _Old_size + _Size_increase;

	lea	eax, DWORD PTR [esi+edx]

; 4514 :         const size_type _Old_capacity = _My_data._Myres;

	mov	esi, DWORD PTR [ebx+20]

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	edi, eax

; 4511 :         }
; 4512 : 
; 4513 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	DWORD PTR __New_size$1$[ebp], eax

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	edi, 3

; 4514 :         const size_type _Old_capacity = _My_data._Myres;

	mov	DWORD PTR __Old$1$[ebp], esi

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	edi, ecx

; 4455 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN9@Reallocate

; 4456 :             return _Max;

	mov	edi, ecx
	jmp	SHORT $LN8@Reallocate
$LN9@Reallocate:

; 4457 :         }
; 4458 : 
; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	eax, esi
	shr	eax, 1
	sub	ecx, eax
	cmp	esi, ecx
	jbe	SHORT $LN10@Reallocate

; 4460 :             return _Max;

	mov	edi, 1073741822				; 3ffffffeH
	jmp	SHORT $LN8@Reallocate
$LN10@Reallocate:

; 4461 :         }
; 4462 : 
; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

	add	eax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 43   :     return _Left < _Right ? _Right : _Left;

	cmp	edi, eax
	cmovb	edi, eax
$LN8@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4517 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	xor	ecx, ecx
	mov	eax, edi
	add	eax, 1
	setb	cl
	neg	ecx
	or	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 60   :         if (_Count > _Max_possible) {

	cmp	ecx, 1073741823				; 3fffffffH
	ja	$LN70@Reallocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	shl	ecx, 2

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN21@Reallocate

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	eax, ecx
	jbe	$LN70@Reallocate

; 79   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	$LN58@Reallocate

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	esi, DWORD PTR [eax+35]
	and	esi, -32				; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [esi-4], eax

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN20@Reallocate
$LN21@Reallocate:

; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

	test	ecx, ecx
	je	SHORT $LN22@Reallocate

; 79   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 235  :         return _Traits::_Allocate(_Bytes);

	mov	esi, eax
	jmp	SHORT $LN20@Reallocate
$LN22@Reallocate:

; 236  :     }
; 237  : 
; 238  :     return nullptr;

	xor	esi, esi
$LN20@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4525 :         _My_data._Mysize      = _New_size;

	mov	eax, DWORD PTR __New_size$1$[ebp]
	mov	DWORD PTR [ebx+16], eax

; 4526 :         _My_data._Myres       = _New_capacity;
; 4527 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	eax, DWORD PTR __Old_size$1$[ebp]
	mov	DWORD PTR [ebx+20], edi
	lea	ecx, DWORD PTR [eax*4]
	mov	eax, DWORD PTR _<_Args_1>$[ebp]
	lea	edx, DWORD PTR [ecx+esi]
	mov	DWORD PTR tv500[ebp], edx

; 4528 :         if (_BUF_SIZE <= _Old_capacity) {

	push	ecx
	lea	edi, DWORD PTR [eax*4]
	add	eax, DWORD PTR __Old_size$1$[ebp]
	cmp	DWORD PTR __Old$1$[ebp], 4
	mov	DWORD PTR tv501[ebp], edi
	lea	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR tv499[ebp], eax
	jb	SHORT $LN3@Reallocate

; 4529 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	edi, DWORD PTR [ebx]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	push	edi
	push	esi
	call	_memcpy
	push	DWORD PTR tv501[ebp]
	push	OFFSET ??_C@_2M@JLEBFLAK@?$AA?$AA?$AA0?$AA?$AA?$AA3@
	push	DWORD PTR tv500[ebp]
	call	_memcpy

; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	eax, DWORD PTR tv499[ebp]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	add	esp, 24					; 00000018H

; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	DWORD PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR __Old$1$[ebp]
	lea	ecx, DWORD PTR [eax*4+4]

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN61@Reallocate

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [edi-4]
	add	ecx, 35					; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	edi, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [edi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN58@Reallocate

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	edi, edx
$LN61@Reallocate:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4538 :         return *this;

	mov	DWORD PTR [ebx], esi
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx

; 4539 :     }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN58@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN3@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	push	ebx
	push	esi
	call	_memcpy
	push	edi
	push	OFFSET ??_C@_2M@JLEBFLAK@?$AA?$AA?$AA0?$AA?$AA?$AA3@
	push	DWORD PTR tv500[ebp]
	call	_memcpy

; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	eax, DWORD PTR tv499[ebp]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	add	esp, 24					; 00000018H

; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	DWORD PTR [eax], 0

; 4538 :         return *this;

	mov	eax, ebx
	pop	edi
	mov	DWORD PTR [ebx], esi
	pop	esi
	pop	ebx

; 4539 :     }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN70@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 131  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN73@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4510 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
$LN71@Reallocate:
	int	3
??$_Reallocate_grow_by@V<lambda_aabcc5df0dcdbd223414bc3ba38ad6d9>@@PB_UI@?$basic_string@_UU?$char_traits@_U@std@@V?$allocator@_U@2@@std@@AAEAAV01@IV<lambda_aabcc5df0dcdbd223414bc3ba38ad6d9>@@PB_UI@Z ENDP ; std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >::_Reallocate_grow_by<<lambda_aabcc5df0dcdbd223414bc3ba38ad6d9>,char32_t const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Construct_in_place@PA_UAAPA_U@std@@YAXAAPA_U0@Z
_TEXT	SEGMENT
??$_Construct_in_place@PA_UAAPA_U@std@@YAXAAPA_U0@Z PROC ; std::_Construct_in_place<char32_t *,char32_t * &>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 142  :     is_nothrow_constructible_v<_Ty, _Types...>) {

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 143  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 144  :     if (_STD is_constant_evaluated()) {
; 145  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 146  :     } else
; 147  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 148  :     {
; 149  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 150  :     }
; 151  : }

	ret	0
??$_Construct_in_place@PA_UAAPA_U@std@@YAXAAPA_U0@Z ENDP ; std::_Construct_in_place<char32_t *,char32_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_98ae700cc7810ca9f391bc310db97391>@@PB_SI@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEAAV01@IV<lambda_98ae700cc7810ca9f391bc310db97391>@@PB_SI@Z
_TEXT	SEGMENT
tv497 = -16						; size = 4
__Old$1$ = -12						; size = 4
tv496 = -8						; size = 4
__New_size$1$ = -8					; size = 4
tv495 = -4						; size = 4
__Old_size$1$ = -4					; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$dead$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
??$_Reallocate_grow_by@V<lambda_98ae700cc7810ca9f391bc310db97391>@@PB_SI@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEAAV01@IV<lambda_98ae700cc7810ca9f391bc310db97391>@@PB_SI@Z PROC ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Reallocate_grow_by<<lambda_98ae700cc7810ca9f391bc310db97391>,char16_t const *,unsigned int>, COMDAT
; _this$ = ecx

; 4504 :         const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 4505 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4506 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4507 :         auto& _My_data            = _Mypair._Myval2;
; 4508 :         const size_type _Old_size = _My_data._Mysize;
; 4509 :         if (max_size() - _Old_size < _Size_increase) {

	mov	edx, DWORD PTR __Size_increase$[ebp]
	push	ebx
	mov	ebx, ecx
	mov	ecx, 2147483646				; 7ffffffeH
	push	esi
	mov	eax, ecx
	push	edi
	mov	esi, DWORD PTR [ebx+16]
	sub	eax, esi
	mov	DWORD PTR __Old_size$1$[ebp], esi
	cmp	eax, edx
	jb	$LN73@Reallocate

; 4511 :         }
; 4512 : 
; 4513 :         const size_type _New_size     = _Old_size + _Size_increase;

	lea	eax, DWORD PTR [esi+edx]

; 4514 :         const size_type _Old_capacity = _My_data._Myres;

	mov	esi, DWORD PTR [ebx+20]

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	edi, eax

; 4511 :         }
; 4512 : 
; 4513 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	DWORD PTR __New_size$1$[ebp], eax

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	edi, 7

; 4514 :         const size_type _Old_capacity = _My_data._Myres;

	mov	DWORD PTR __Old$1$[ebp], esi

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	edi, ecx

; 4455 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN9@Reallocate

; 4456 :             return _Max;

	mov	edi, ecx
	jmp	SHORT $LN8@Reallocate
$LN9@Reallocate:

; 4457 :         }
; 4458 : 
; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	eax, esi
	shr	eax, 1
	sub	ecx, eax
	cmp	esi, ecx
	jbe	SHORT $LN10@Reallocate

; 4460 :             return _Max;

	mov	edi, 2147483646				; 7ffffffeH
	jmp	SHORT $LN8@Reallocate
$LN10@Reallocate:

; 4461 :         }
; 4462 : 
; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

	add	eax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 43   :     return _Left < _Right ? _Right : _Left;

	cmp	edi, eax
	cmovb	edi, eax
$LN8@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4517 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	xor	ecx, ecx
	mov	eax, edi
	add	eax, 1
	setb	cl
	neg	ecx
	or	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 60   :         if (_Count > _Max_possible) {

	cmp	ecx, 2147483647				; 7fffffffH
	ja	$LN70@Reallocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	add	ecx, ecx

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN21@Reallocate

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	eax, ecx
	jbe	$LN70@Reallocate

; 79   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	$LN58@Reallocate

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	esi, DWORD PTR [eax+35]
	and	esi, -32				; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [esi-4], eax

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN20@Reallocate
$LN21@Reallocate:

; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

	test	ecx, ecx
	je	SHORT $LN22@Reallocate

; 79   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 235  :         return _Traits::_Allocate(_Bytes);

	mov	esi, eax
	jmp	SHORT $LN20@Reallocate
$LN22@Reallocate:

; 236  :     }
; 237  : 
; 238  :     return nullptr;

	xor	esi, esi
$LN20@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4525 :         _My_data._Mysize      = _New_size;

	mov	eax, DWORD PTR __New_size$1$[ebp]
	mov	DWORD PTR [ebx+16], eax

; 4526 :         _My_data._Myres       = _New_capacity;
; 4527 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	eax, DWORD PTR __Old_size$1$[ebp]
	mov	DWORD PTR [ebx+20], edi
	lea	ecx, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _<_Args_1>$[ebp]
	lea	edx, DWORD PTR [ecx+esi]
	mov	DWORD PTR tv496[ebp], edx

; 4528 :         if (_BUF_SIZE <= _Old_capacity) {

	push	ecx
	lea	edi, DWORD PTR [eax+eax]
	add	eax, DWORD PTR __Old_size$1$[ebp]
	cmp	DWORD PTR __Old$1$[ebp], 8
	mov	DWORD PTR tv497[ebp], edi
	lea	eax, DWORD PTR [esi+eax*2]
	mov	DWORD PTR tv495[ebp], eax
	jb	SHORT $LN3@Reallocate

; 4529 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	edi, DWORD PTR [ebx]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	push	edi
	push	esi
	call	_memcpy
	push	DWORD PTR tv497[ebp]
	push	OFFSET ??_C@_15BAGFGJNL@?$AA0?$AA2@
	push	DWORD PTR tv496[ebp]
	call	_memcpy

; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	eax, DWORD PTR tv495[ebp]
	xor	ecx, ecx

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	add	esp, 24					; 00000018H

; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	WORD PTR [eax], cx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR __Old$1$[ebp]
	lea	ecx, DWORD PTR [eax*2+2]

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN61@Reallocate

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [edi-4]
	add	ecx, 35					; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	edi, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [edi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN58@Reallocate

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	edi, edx
$LN61@Reallocate:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4538 :         return *this;

	mov	DWORD PTR [ebx], esi
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx

; 4539 :     }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN58@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN3@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	push	ebx
	push	esi
	call	_memcpy
	push	edi
	push	OFFSET ??_C@_15BAGFGJNL@?$AA0?$AA2@
	push	DWORD PTR tv496[ebp]
	call	_memcpy

; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	eax, DWORD PTR tv495[ebp]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	add	esp, 24					; 00000018H

; 3135 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	xor	ecx, ecx
	mov	WORD PTR [eax], cx

; 4538 :         return *this;

	mov	eax, ebx
	pop	edi
	mov	DWORD PTR [ebx], esi
	pop	esi
	pop	ebx

; 4539 :     }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN70@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 131  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN73@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4510 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
$LN71@Reallocate:
	int	3
??$_Reallocate_grow_by@V<lambda_98ae700cc7810ca9f391bc310db97391>@@PB_SI@?$basic_string@_SU?$char_traits@_S@std@@V?$allocator@_S@2@@std@@AAEAAV01@IV<lambda_98ae700cc7810ca9f391bc310db97391>@@PB_SI@Z ENDP ; std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >::_Reallocate_grow_by<<lambda_98ae700cc7810ca9f391bc310db97391>,char16_t const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Construct_in_place@PA_SAAPA_S@std@@YAXAAPA_S0@Z
_TEXT	SEGMENT
??$_Construct_in_place@PA_SAAPA_S@std@@YAXAAPA_S0@Z PROC ; std::_Construct_in_place<char16_t *,char16_t * &>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 142  :     is_nothrow_constructible_v<_Ty, _Types...>) {

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 143  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 144  :     if (_STD is_constant_evaluated()) {
; 145  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 146  :     } else
; 147  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 148  :     {
; 149  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 150  :     }
; 151  : }

	ret	0
??$_Construct_in_place@PA_SAAPA_S@std@@YAXAAPA_S0@Z ENDP ; std::_Construct_in_place<char16_t *,char16_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@_U@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@_U@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_String_val@U?$_Simple_types@_U@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@_U@std@@@0@AAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char32_t> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@_U@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@_U@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char32_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_String_val@U?$_Simple_types@_U@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@_U@std@@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$_String_val@U?$_Simple_types@_U@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@_U@std@@@0@ABV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char32_t> > const >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@$$CBV?$_String_val@U?$_Simple_types@_U@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@_U@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char32_t> > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@_S@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@_S@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_String_val@U?$_Simple_types@_S@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@_S@std@@@0@AAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char16_t> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@_S@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@_S@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char16_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_String_val@U?$_Simple_types@_S@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@_S@std@@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$_String_val@U?$_Simple_types@_S@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@_S@std@@@0@ABV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char16_t> > const >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@$$CBV?$_String_val@U?$_Simple_types@_S@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@_S@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char16_t> > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@PA_U@std@@YAPAPA_UAAPA_U@Z
_TEXT	SEGMENT
??$addressof@PA_U@std@@YAPAPA_UAAPA_U@Z PROC		; std::addressof<char32_t *>, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@PA_U@std@@YAPAPA_UAAPA_U@Z ENDP		; std::addressof<char32_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PAPA_U@std@@YAPAXPAPA_U@Z
_TEXT	SEGMENT
??$_Voidify_iter@PAPA_U@std@@YAPAXPAPA_U@Z PROC		; std::_Voidify_iter<char32_t * *>, COMDAT
; __It$ = ecx

; 124  :     if constexpr (is_pointer_v<_Iter>) {
; 125  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

	mov	eax, ecx

; 126  :     } else {
; 127  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 128  :     }
; 129  : }

	ret	0
??$_Voidify_iter@PAPA_U@std@@YAPAXPAPA_U@Z ENDP		; std::_Voidify_iter<char32_t * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABQA_U@std@@YAABQA_UABQA_U@Z
_TEXT	SEGMENT
??$forward@ABQA_U@std@@YAABQA_UABQA_U@Z PROC		; std::forward<char32_t * const &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ABQA_U@std@@YAABQA_UABQA_U@Z ENDP		; std::forward<char32_t * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@PA_S@std@@YAPAPA_SAAPA_S@Z
_TEXT	SEGMENT
??$addressof@PA_S@std@@YAPAPA_SAAPA_S@Z PROC		; std::addressof<char16_t *>, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@PA_S@std@@YAPAPA_SAAPA_S@Z ENDP		; std::addressof<char16_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PAPA_S@std@@YAPAXPAPA_S@Z
_TEXT	SEGMENT
??$_Voidify_iter@PAPA_S@std@@YAPAXPAPA_S@Z PROC		; std::_Voidify_iter<char16_t * *>, COMDAT
; __It$ = ecx

; 124  :     if constexpr (is_pointer_v<_Iter>) {
; 125  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

	mov	eax, ecx

; 126  :     } else {
; 127  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 128  :     }
; 129  : }

	ret	0
??$_Voidify_iter@PAPA_S@std@@YAPAXPAPA_S@Z ENDP		; std::_Voidify_iter<char16_t * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABQA_S@std@@YAABQA_SABQA_S@Z
_TEXT	SEGMENT
??$forward@ABQA_S@std@@YAABQA_SABQA_S@Z PROC		; std::forward<char16_t * const &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ABQA_S@std@@YAABQA_SABQA_S@Z ENDP		; std::forward<char16_t * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@V?$allocator@_U@std@@@std@@YA$$QAV?$allocator@_U@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$allocator@_U@std@@@std@@YA$$QAV?$allocator@_U@0@AAV10@@Z PROC ; std::forward<std::allocator<char32_t> >, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@V?$allocator@_U@std@@@std@@YA$$QAV?$allocator@_U@0@AAV10@@Z ENDP ; std::forward<std::allocator<char32_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@V?$allocator@_S@std@@@std@@YA$$QAV?$allocator@_S@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$allocator@_S@std@@@std@@YA$$QAV?$allocator@_S@0@AAV10@@Z PROC ; std::forward<std::allocator<char16_t> >, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@V?$allocator@_S@std@@@std@@YA$$QAV?$allocator@_S@0@AAV10@@Z ENDP ; std::forward<std::allocator<char16_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAPA_U@std@@YAAAPA_UAAPA_U@Z
_TEXT	SEGMENT
??$forward@AAPA_U@std@@YAAAPA_UAAPA_U@Z PROC		; std::forward<char32_t * &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@AAPA_U@std@@YAAAPA_UAAPA_U@Z ENDP		; std::forward<char32_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAPA_S@std@@YAAAPA_SAAPA_S@Z
_TEXT	SEGMENT
??$forward@AAPA_S@std@@YAAAPA_SAAPA_S@Z PROC		; std::forward<char16_t * &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@AAPA_S@std@@YAAAPA_SAAPA_S@Z ENDP		; std::forward<char16_t * &>
_TEXT	ENDS
END
